
final.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <__udivsi3>:
 80000c0:	2200      	movs	r2, #0
 80000c2:	0843      	lsrs	r3, r0, #1
 80000c4:	428b      	cmp	r3, r1
 80000c6:	d374      	bcc.n	80001b2 <__udivsi3+0xf2>
 80000c8:	0903      	lsrs	r3, r0, #4
 80000ca:	428b      	cmp	r3, r1
 80000cc:	d35f      	bcc.n	800018e <__udivsi3+0xce>
 80000ce:	0a03      	lsrs	r3, r0, #8
 80000d0:	428b      	cmp	r3, r1
 80000d2:	d344      	bcc.n	800015e <__udivsi3+0x9e>
 80000d4:	0b03      	lsrs	r3, r0, #12
 80000d6:	428b      	cmp	r3, r1
 80000d8:	d328      	bcc.n	800012c <__udivsi3+0x6c>
 80000da:	0c03      	lsrs	r3, r0, #16
 80000dc:	428b      	cmp	r3, r1
 80000de:	d30d      	bcc.n	80000fc <__udivsi3+0x3c>
 80000e0:	22ff      	movs	r2, #255	; 0xff
 80000e2:	0209      	lsls	r1, r1, #8
 80000e4:	ba12      	rev	r2, r2
 80000e6:	0c03      	lsrs	r3, r0, #16
 80000e8:	428b      	cmp	r3, r1
 80000ea:	d302      	bcc.n	80000f2 <__udivsi3+0x32>
 80000ec:	1212      	asrs	r2, r2, #8
 80000ee:	0209      	lsls	r1, r1, #8
 80000f0:	d065      	beq.n	80001be <__udivsi3+0xfe>
 80000f2:	0b03      	lsrs	r3, r0, #12
 80000f4:	428b      	cmp	r3, r1
 80000f6:	d319      	bcc.n	800012c <__udivsi3+0x6c>
 80000f8:	e000      	b.n	80000fc <__udivsi3+0x3c>
 80000fa:	0a09      	lsrs	r1, r1, #8
 80000fc:	0bc3      	lsrs	r3, r0, #15
 80000fe:	428b      	cmp	r3, r1
 8000100:	d301      	bcc.n	8000106 <__udivsi3+0x46>
 8000102:	03cb      	lsls	r3, r1, #15
 8000104:	1ac0      	subs	r0, r0, r3
 8000106:	4152      	adcs	r2, r2
 8000108:	0b83      	lsrs	r3, r0, #14
 800010a:	428b      	cmp	r3, r1
 800010c:	d301      	bcc.n	8000112 <__udivsi3+0x52>
 800010e:	038b      	lsls	r3, r1, #14
 8000110:	1ac0      	subs	r0, r0, r3
 8000112:	4152      	adcs	r2, r2
 8000114:	0b43      	lsrs	r3, r0, #13
 8000116:	428b      	cmp	r3, r1
 8000118:	d301      	bcc.n	800011e <__udivsi3+0x5e>
 800011a:	034b      	lsls	r3, r1, #13
 800011c:	1ac0      	subs	r0, r0, r3
 800011e:	4152      	adcs	r2, r2
 8000120:	0b03      	lsrs	r3, r0, #12
 8000122:	428b      	cmp	r3, r1
 8000124:	d301      	bcc.n	800012a <__udivsi3+0x6a>
 8000126:	030b      	lsls	r3, r1, #12
 8000128:	1ac0      	subs	r0, r0, r3
 800012a:	4152      	adcs	r2, r2
 800012c:	0ac3      	lsrs	r3, r0, #11
 800012e:	428b      	cmp	r3, r1
 8000130:	d301      	bcc.n	8000136 <__udivsi3+0x76>
 8000132:	02cb      	lsls	r3, r1, #11
 8000134:	1ac0      	subs	r0, r0, r3
 8000136:	4152      	adcs	r2, r2
 8000138:	0a83      	lsrs	r3, r0, #10
 800013a:	428b      	cmp	r3, r1
 800013c:	d301      	bcc.n	8000142 <__udivsi3+0x82>
 800013e:	028b      	lsls	r3, r1, #10
 8000140:	1ac0      	subs	r0, r0, r3
 8000142:	4152      	adcs	r2, r2
 8000144:	0a43      	lsrs	r3, r0, #9
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x8e>
 800014a:	024b      	lsls	r3, r1, #9
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0a03      	lsrs	r3, r0, #8
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x9a>
 8000156:	020b      	lsls	r3, r1, #8
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	d2cd      	bcs.n	80000fa <__udivsi3+0x3a>
 800015e:	09c3      	lsrs	r3, r0, #7
 8000160:	428b      	cmp	r3, r1
 8000162:	d301      	bcc.n	8000168 <__udivsi3+0xa8>
 8000164:	01cb      	lsls	r3, r1, #7
 8000166:	1ac0      	subs	r0, r0, r3
 8000168:	4152      	adcs	r2, r2
 800016a:	0983      	lsrs	r3, r0, #6
 800016c:	428b      	cmp	r3, r1
 800016e:	d301      	bcc.n	8000174 <__udivsi3+0xb4>
 8000170:	018b      	lsls	r3, r1, #6
 8000172:	1ac0      	subs	r0, r0, r3
 8000174:	4152      	adcs	r2, r2
 8000176:	0943      	lsrs	r3, r0, #5
 8000178:	428b      	cmp	r3, r1
 800017a:	d301      	bcc.n	8000180 <__udivsi3+0xc0>
 800017c:	014b      	lsls	r3, r1, #5
 800017e:	1ac0      	subs	r0, r0, r3
 8000180:	4152      	adcs	r2, r2
 8000182:	0903      	lsrs	r3, r0, #4
 8000184:	428b      	cmp	r3, r1
 8000186:	d301      	bcc.n	800018c <__udivsi3+0xcc>
 8000188:	010b      	lsls	r3, r1, #4
 800018a:	1ac0      	subs	r0, r0, r3
 800018c:	4152      	adcs	r2, r2
 800018e:	08c3      	lsrs	r3, r0, #3
 8000190:	428b      	cmp	r3, r1
 8000192:	d301      	bcc.n	8000198 <__udivsi3+0xd8>
 8000194:	00cb      	lsls	r3, r1, #3
 8000196:	1ac0      	subs	r0, r0, r3
 8000198:	4152      	adcs	r2, r2
 800019a:	0883      	lsrs	r3, r0, #2
 800019c:	428b      	cmp	r3, r1
 800019e:	d301      	bcc.n	80001a4 <__udivsi3+0xe4>
 80001a0:	008b      	lsls	r3, r1, #2
 80001a2:	1ac0      	subs	r0, r0, r3
 80001a4:	4152      	adcs	r2, r2
 80001a6:	0843      	lsrs	r3, r0, #1
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xf0>
 80001ac:	004b      	lsls	r3, r1, #1
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	1a41      	subs	r1, r0, r1
 80001b4:	d200      	bcs.n	80001b8 <__udivsi3+0xf8>
 80001b6:	4601      	mov	r1, r0
 80001b8:	4152      	adcs	r2, r2
 80001ba:	4610      	mov	r0, r2
 80001bc:	4770      	bx	lr
 80001be:	e7ff      	b.n	80001c0 <__udivsi3+0x100>
 80001c0:	b501      	push	{r0, lr}
 80001c2:	2000      	movs	r0, #0
 80001c4:	f000 f806 	bl	80001d4 <__aeabi_idiv0>
 80001c8:	bd02      	pop	{r1, pc}
 80001ca:	46c0      	nop			; (mov r8, r8)

080001cc <__aeabi_uidivmod>:
 80001cc:	2900      	cmp	r1, #0
 80001ce:	d0f7      	beq.n	80001c0 <__udivsi3+0x100>
 80001d0:	e776      	b.n	80000c0 <__udivsi3>
 80001d2:	4770      	bx	lr

080001d4 <__aeabi_idiv0>:
 80001d4:	4770      	bx	lr
 80001d6:	46c0      	nop			; (mov r8, r8)

080001d8 <__aeabi_cfrcmple>:
 80001d8:	4684      	mov	ip, r0
 80001da:	0008      	movs	r0, r1
 80001dc:	4661      	mov	r1, ip
 80001de:	e7ff      	b.n	80001e0 <__aeabi_cfcmpeq>

080001e0 <__aeabi_cfcmpeq>:
 80001e0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80001e2:	f002 ff37 	bl	8003054 <__lesf2>
 80001e6:	2800      	cmp	r0, #0
 80001e8:	d401      	bmi.n	80001ee <__aeabi_cfcmpeq+0xe>
 80001ea:	2100      	movs	r1, #0
 80001ec:	42c8      	cmn	r0, r1
 80001ee:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

080001f0 <__aeabi_fcmpeq>:
 80001f0:	b510      	push	{r4, lr}
 80001f2:	f002 feb7 	bl	8002f64 <__eqsf2>
 80001f6:	4240      	negs	r0, r0
 80001f8:	3001      	adds	r0, #1
 80001fa:	bd10      	pop	{r4, pc}

080001fc <__aeabi_fcmplt>:
 80001fc:	b510      	push	{r4, lr}
 80001fe:	f002 ff29 	bl	8003054 <__lesf2>
 8000202:	2800      	cmp	r0, #0
 8000204:	db01      	blt.n	800020a <__aeabi_fcmplt+0xe>
 8000206:	2000      	movs	r0, #0
 8000208:	bd10      	pop	{r4, pc}
 800020a:	2001      	movs	r0, #1
 800020c:	bd10      	pop	{r4, pc}
 800020e:	46c0      	nop			; (mov r8, r8)

08000210 <__aeabi_fcmple>:
 8000210:	b510      	push	{r4, lr}
 8000212:	f002 ff1f 	bl	8003054 <__lesf2>
 8000216:	2800      	cmp	r0, #0
 8000218:	dd01      	ble.n	800021e <__aeabi_fcmple+0xe>
 800021a:	2000      	movs	r0, #0
 800021c:	bd10      	pop	{r4, pc}
 800021e:	2001      	movs	r0, #1
 8000220:	bd10      	pop	{r4, pc}
 8000222:	46c0      	nop			; (mov r8, r8)

08000224 <__aeabi_fcmpgt>:
 8000224:	b510      	push	{r4, lr}
 8000226:	f002 fec5 	bl	8002fb4 <__gesf2>
 800022a:	2800      	cmp	r0, #0
 800022c:	dc01      	bgt.n	8000232 <__aeabi_fcmpgt+0xe>
 800022e:	2000      	movs	r0, #0
 8000230:	bd10      	pop	{r4, pc}
 8000232:	2001      	movs	r0, #1
 8000234:	bd10      	pop	{r4, pc}
 8000236:	46c0      	nop			; (mov r8, r8)

08000238 <__aeabi_fcmpge>:
 8000238:	b510      	push	{r4, lr}
 800023a:	f002 febb 	bl	8002fb4 <__gesf2>
 800023e:	2800      	cmp	r0, #0
 8000240:	da01      	bge.n	8000246 <__aeabi_fcmpge+0xe>
 8000242:	2000      	movs	r0, #0
 8000244:	bd10      	pop	{r4, pc}
 8000246:	2001      	movs	r0, #1
 8000248:	bd10      	pop	{r4, pc}
 800024a:	46c0      	nop			; (mov r8, r8)

0800024c <__clzsi2>:
 800024c:	211c      	movs	r1, #28
 800024e:	2301      	movs	r3, #1
 8000250:	041b      	lsls	r3, r3, #16
 8000252:	4298      	cmp	r0, r3
 8000254:	d301      	bcc.n	800025a <__clzsi2+0xe>
 8000256:	0c00      	lsrs	r0, r0, #16
 8000258:	3910      	subs	r1, #16
 800025a:	0a1b      	lsrs	r3, r3, #8
 800025c:	4298      	cmp	r0, r3
 800025e:	d301      	bcc.n	8000264 <__clzsi2+0x18>
 8000260:	0a00      	lsrs	r0, r0, #8
 8000262:	3908      	subs	r1, #8
 8000264:	091b      	lsrs	r3, r3, #4
 8000266:	4298      	cmp	r0, r3
 8000268:	d301      	bcc.n	800026e <__clzsi2+0x22>
 800026a:	0900      	lsrs	r0, r0, #4
 800026c:	3904      	subs	r1, #4
 800026e:	a202      	add	r2, pc, #8	; (adr r2, 8000278 <__clzsi2+0x2c>)
 8000270:	5c10      	ldrb	r0, [r2, r0]
 8000272:	1840      	adds	r0, r0, r1
 8000274:	4770      	bx	lr
 8000276:	46c0      	nop			; (mov r8, r8)
 8000278:	02020304 	.word	0x02020304
 800027c:	01010101 	.word	0x01010101
	...

08000288 <deregister_tm_clones>:
 8000288:	4804      	ldr	r0, [pc, #16]	; (800029c <deregister_tm_clones+0x14>)
 800028a:	4b05      	ldr	r3, [pc, #20]	; (80002a0 <deregister_tm_clones+0x18>)
 800028c:	b510      	push	{r4, lr}
 800028e:	4283      	cmp	r3, r0
 8000290:	d003      	beq.n	800029a <deregister_tm_clones+0x12>
 8000292:	4b04      	ldr	r3, [pc, #16]	; (80002a4 <deregister_tm_clones+0x1c>)
 8000294:	2b00      	cmp	r3, #0
 8000296:	d000      	beq.n	800029a <deregister_tm_clones+0x12>
 8000298:	4798      	blx	r3
 800029a:	bd10      	pop	{r4, pc}
 800029c:	20000000 	.word	0x20000000
 80002a0:	20000000 	.word	0x20000000
 80002a4:	00000000 	.word	0x00000000

080002a8 <register_tm_clones>:
 80002a8:	4806      	ldr	r0, [pc, #24]	; (80002c4 <register_tm_clones+0x1c>)
 80002aa:	4907      	ldr	r1, [pc, #28]	; (80002c8 <register_tm_clones+0x20>)
 80002ac:	1a09      	subs	r1, r1, r0
 80002ae:	108b      	asrs	r3, r1, #2
 80002b0:	0fc9      	lsrs	r1, r1, #31
 80002b2:	18c9      	adds	r1, r1, r3
 80002b4:	b510      	push	{r4, lr}
 80002b6:	1049      	asrs	r1, r1, #1
 80002b8:	d003      	beq.n	80002c2 <register_tm_clones+0x1a>
 80002ba:	4b04      	ldr	r3, [pc, #16]	; (80002cc <register_tm_clones+0x24>)
 80002bc:	2b00      	cmp	r3, #0
 80002be:	d000      	beq.n	80002c2 <register_tm_clones+0x1a>
 80002c0:	4798      	blx	r3
 80002c2:	bd10      	pop	{r4, pc}
 80002c4:	20000000 	.word	0x20000000
 80002c8:	20000000 	.word	0x20000000
 80002cc:	00000000 	.word	0x00000000

080002d0 <__do_global_dtors_aux>:
 80002d0:	b510      	push	{r4, lr}
 80002d2:	4c07      	ldr	r4, [pc, #28]	; (80002f0 <__do_global_dtors_aux+0x20>)
 80002d4:	7823      	ldrb	r3, [r4, #0]
 80002d6:	2b00      	cmp	r3, #0
 80002d8:	d109      	bne.n	80002ee <__do_global_dtors_aux+0x1e>
 80002da:	f7ff ffd5 	bl	8000288 <deregister_tm_clones>
 80002de:	4b05      	ldr	r3, [pc, #20]	; (80002f4 <__do_global_dtors_aux+0x24>)
 80002e0:	2b00      	cmp	r3, #0
 80002e2:	d002      	beq.n	80002ea <__do_global_dtors_aux+0x1a>
 80002e4:	4804      	ldr	r0, [pc, #16]	; (80002f8 <__do_global_dtors_aux+0x28>)
 80002e6:	e000      	b.n	80002ea <__do_global_dtors_aux+0x1a>
 80002e8:	bf00      	nop
 80002ea:	2301      	movs	r3, #1
 80002ec:	7023      	strb	r3, [r4, #0]
 80002ee:	bd10      	pop	{r4, pc}
 80002f0:	20000000 	.word	0x20000000
 80002f4:	00000000 	.word	0x00000000
 80002f8:	080037b0 	.word	0x080037b0

080002fc <frame_dummy>:
 80002fc:	4b05      	ldr	r3, [pc, #20]	; (8000314 <frame_dummy+0x18>)
 80002fe:	b510      	push	{r4, lr}
 8000300:	2b00      	cmp	r3, #0
 8000302:	d003      	beq.n	800030c <frame_dummy+0x10>
 8000304:	4904      	ldr	r1, [pc, #16]	; (8000318 <frame_dummy+0x1c>)
 8000306:	4805      	ldr	r0, [pc, #20]	; (800031c <frame_dummy+0x20>)
 8000308:	e000      	b.n	800030c <frame_dummy+0x10>
 800030a:	bf00      	nop
 800030c:	f7ff ffcc 	bl	80002a8 <register_tm_clones>
 8000310:	bd10      	pop	{r4, pc}
 8000312:	46c0      	nop			; (mov r8, r8)
 8000314:	00000000 	.word	0x00000000
 8000318:	20000004 	.word	0x20000004
 800031c:	080037b0 	.word	0x080037b0

08000320 <Reset_Handler>:
 8000320:	480d      	ldr	r0, [pc, #52]	; (8000358 <LoopForever+0x2>)
 8000322:	4685      	mov	sp, r0
 8000324:	480d      	ldr	r0, [pc, #52]	; (800035c <LoopForever+0x6>)
 8000326:	490e      	ldr	r1, [pc, #56]	; (8000360 <LoopForever+0xa>)
 8000328:	4a0e      	ldr	r2, [pc, #56]	; (8000364 <LoopForever+0xe>)
 800032a:	2300      	movs	r3, #0
 800032c:	e002      	b.n	8000334 <LoopCopyDataInit>

0800032e <CopyDataInit>:
 800032e:	58d4      	ldr	r4, [r2, r3]
 8000330:	50c4      	str	r4, [r0, r3]
 8000332:	3304      	adds	r3, #4

08000334 <LoopCopyDataInit>:
 8000334:	18c4      	adds	r4, r0, r3
 8000336:	428c      	cmp	r4, r1
 8000338:	d3f9      	bcc.n	800032e <CopyDataInit>
 800033a:	4a0b      	ldr	r2, [pc, #44]	; (8000368 <LoopForever+0x12>)
 800033c:	4c0b      	ldr	r4, [pc, #44]	; (800036c <LoopForever+0x16>)
 800033e:	2300      	movs	r3, #0
 8000340:	e001      	b.n	8000346 <LoopFillZerobss>

08000342 <FillZerobss>:
 8000342:	6013      	str	r3, [r2, #0]
 8000344:	3204      	adds	r2, #4

08000346 <LoopFillZerobss>:
 8000346:	42a2      	cmp	r2, r4
 8000348:	d3fb      	bcc.n	8000342 <FillZerobss>
 800034a:	f000 f813 	bl	8000374 <SystemInit>
 800034e:	f003 fa0b 	bl	8003768 <__libc_init_array>
 8000352:	f000 f8b1 	bl	80004b8 <main>

08000356 <LoopForever>:
 8000356:	e7fe      	b.n	8000356 <LoopForever>
 8000358:	20004000 	.word	0x20004000
 800035c:	20000000 	.word	0x20000000
 8000360:	20000000 	.word	0x20000000
 8000364:	08003934 	.word	0x08003934
 8000368:	20000000 	.word	0x20000000
 800036c:	20000064 	.word	0x20000064

08000370 <ADC1_IRQHandler>:
 8000370:	e7fe      	b.n	8000370 <ADC1_IRQHandler>
	...

08000374 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000374:	b580      	push	{r7, lr}
 8000376:	af00      	add	r7, sp, #0
   */

  /* The following code sets the system clock frequency to 20 MHz */

  /* Turn on HSI (8MHz) */
  RCC->CR |= RCC_CR_HSION;
 8000378:	4b48      	ldr	r3, [pc, #288]	; (800049c <SystemInit+0x128>)
 800037a:	681a      	ldr	r2, [r3, #0]
 800037c:	4b47      	ldr	r3, [pc, #284]	; (800049c <SystemInit+0x128>)
 800037e:	2101      	movs	r1, #1
 8000380:	430a      	orrs	r2, r1
 8000382:	601a      	str	r2, [r3, #0]

  /* Wait for HSI to be ready */
  while ( ( RCC->CR & RCC_CR_HSIRDY ) == 0U )
 8000384:	46c0      	nop			; (mov r8, r8)
 8000386:	4b45      	ldr	r3, [pc, #276]	; (800049c <SystemInit+0x128>)
 8000388:	681b      	ldr	r3, [r3, #0]
 800038a:	2202      	movs	r2, #2
 800038c:	4013      	ands	r3, r2
 800038e:	d0fa      	beq.n	8000386 <SystemInit+0x12>
  {
    /* Do nothing */
  }

  /* Select HSI/2 (= 4MHz) as source for PLL */
  RCC->CFGR &= ~RCC_CFGR_PLLSRC;
 8000390:	4b42      	ldr	r3, [pc, #264]	; (800049c <SystemInit+0x128>)
 8000392:	685a      	ldr	r2, [r3, #4]
 8000394:	4b41      	ldr	r3, [pc, #260]	; (800049c <SystemInit+0x128>)
 8000396:	4942      	ldr	r1, [pc, #264]	; (80004a0 <SystemInit+0x12c>)
 8000398:	400a      	ands	r2, r1
 800039a:	605a      	str	r2, [r3, #4]

  /* PLL PREDIV, clock not divided (= 4MHz) */
  RCC->CFGR2 &= ~RCC_CFGR2_PREDIV_3;
 800039c:	4b3f      	ldr	r3, [pc, #252]	; (800049c <SystemInit+0x128>)
 800039e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003a0:	4b3e      	ldr	r3, [pc, #248]	; (800049c <SystemInit+0x128>)
 80003a2:	2108      	movs	r1, #8
 80003a4:	438a      	bics	r2, r1
 80003a6:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR2 &= ~RCC_CFGR2_PREDIV_2;
 80003a8:	4b3c      	ldr	r3, [pc, #240]	; (800049c <SystemInit+0x128>)
 80003aa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003ac:	4b3b      	ldr	r3, [pc, #236]	; (800049c <SystemInit+0x128>)
 80003ae:	2104      	movs	r1, #4
 80003b0:	438a      	bics	r2, r1
 80003b2:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR2 &= ~RCC_CFGR2_PREDIV_1;
 80003b4:	4b39      	ldr	r3, [pc, #228]	; (800049c <SystemInit+0x128>)
 80003b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003b8:	4b38      	ldr	r3, [pc, #224]	; (800049c <SystemInit+0x128>)
 80003ba:	2102      	movs	r1, #2
 80003bc:	438a      	bics	r2, r1
 80003be:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR2 &= ~RCC_CFGR2_PREDIV_0;
 80003c0:	4b36      	ldr	r3, [pc, #216]	; (800049c <SystemInit+0x128>)
 80003c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003c4:	4b35      	ldr	r3, [pc, #212]	; (800049c <SystemInit+0x128>)
 80003c6:	2101      	movs	r1, #1
 80003c8:	438a      	bics	r2, r1
 80003ca:	62da      	str	r2, [r3, #44]	; 0x2c

  /* PLLMUL set to x5 (4x5 = 20MHz) */
  RCC->CFGR &= ~RCC_CFGR_PLLMUL_3;
 80003cc:	4b33      	ldr	r3, [pc, #204]	; (800049c <SystemInit+0x128>)
 80003ce:	685a      	ldr	r2, [r3, #4]
 80003d0:	4b32      	ldr	r3, [pc, #200]	; (800049c <SystemInit+0x128>)
 80003d2:	4934      	ldr	r1, [pc, #208]	; (80004a4 <SystemInit+0x130>)
 80003d4:	400a      	ands	r2, r1
 80003d6:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_PLLMUL_2;
 80003d8:	4b30      	ldr	r3, [pc, #192]	; (800049c <SystemInit+0x128>)
 80003da:	685a      	ldr	r2, [r3, #4]
 80003dc:	4b2f      	ldr	r3, [pc, #188]	; (800049c <SystemInit+0x128>)
 80003de:	4932      	ldr	r1, [pc, #200]	; (80004a8 <SystemInit+0x134>)
 80003e0:	400a      	ands	r2, r1
 80003e2:	605a      	str	r2, [r3, #4]
  RCC->CFGR |=  RCC_CFGR_PLLMUL_1;
 80003e4:	4b2d      	ldr	r3, [pc, #180]	; (800049c <SystemInit+0x128>)
 80003e6:	685a      	ldr	r2, [r3, #4]
 80003e8:	4b2c      	ldr	r3, [pc, #176]	; (800049c <SystemInit+0x128>)
 80003ea:	2180      	movs	r1, #128	; 0x80
 80003ec:	0309      	lsls	r1, r1, #12
 80003ee:	430a      	orrs	r2, r1
 80003f0:	605a      	str	r2, [r3, #4]
  RCC->CFGR |=  RCC_CFGR_PLLMUL_0;
 80003f2:	4b2a      	ldr	r3, [pc, #168]	; (800049c <SystemInit+0x128>)
 80003f4:	685a      	ldr	r2, [r3, #4]
 80003f6:	4b29      	ldr	r3, [pc, #164]	; (800049c <SystemInit+0x128>)
 80003f8:	2180      	movs	r1, #128	; 0x80
 80003fa:	02c9      	lsls	r1, r1, #11
 80003fc:	430a      	orrs	r2, r1
 80003fe:	605a      	str	r2, [r3, #4]

  /* Turn on PLL */
  RCC->CR |= RCC_CR_PLLON;
 8000400:	4b26      	ldr	r3, [pc, #152]	; (800049c <SystemInit+0x128>)
 8000402:	681a      	ldr	r2, [r3, #0]
 8000404:	4b25      	ldr	r3, [pc, #148]	; (800049c <SystemInit+0x128>)
 8000406:	2180      	movs	r1, #128	; 0x80
 8000408:	0449      	lsls	r1, r1, #17
 800040a:	430a      	orrs	r2, r1
 800040c:	601a      	str	r2, [r3, #0]

  /* Wait for PLL to be ready */
  while ( ( RCC->CR & RCC_CR_PLLRDY ) == 0 )
 800040e:	46c0      	nop			; (mov r8, r8)
 8000410:	4b22      	ldr	r3, [pc, #136]	; (800049c <SystemInit+0x128>)
 8000412:	681a      	ldr	r2, [r3, #0]
 8000414:	2380      	movs	r3, #128	; 0x80
 8000416:	049b      	lsls	r3, r3, #18
 8000418:	4013      	ands	r3, r2
 800041a:	d0f9      	beq.n	8000410 <SystemInit+0x9c>
  {
    /* Do nothing */
  }

  /* Select PLL as system clock */
  RCC->CFGR |=  RCC_CFGR_SW_1;
 800041c:	4b1f      	ldr	r3, [pc, #124]	; (800049c <SystemInit+0x128>)
 800041e:	685a      	ldr	r2, [r3, #4]
 8000420:	4b1e      	ldr	r3, [pc, #120]	; (800049c <SystemInit+0x128>)
 8000422:	2102      	movs	r1, #2
 8000424:	430a      	orrs	r2, r1
 8000426:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_SW_0;
 8000428:	4b1c      	ldr	r3, [pc, #112]	; (800049c <SystemInit+0x128>)
 800042a:	685a      	ldr	r2, [r3, #4]
 800042c:	4b1b      	ldr	r3, [pc, #108]	; (800049c <SystemInit+0x128>)
 800042e:	2101      	movs	r1, #1
 8000430:	438a      	bics	r2, r1
 8000432:	605a      	str	r2, [r3, #4]

  /* Wait for PLL to be selected as system clock */
  while ( ( RCC->CFGR & RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL )
 8000434:	46c0      	nop			; (mov r8, r8)
 8000436:	4b19      	ldr	r3, [pc, #100]	; (800049c <SystemInit+0x128>)
 8000438:	685b      	ldr	r3, [r3, #4]
 800043a:	220c      	movs	r2, #12
 800043c:	4013      	ands	r3, r2
 800043e:	2b08      	cmp	r3, #8
 8000440:	d1f9      	bne.n	8000436 <SystemInit+0xc2>
  {
    /* do nothing */
  }

  /* HCLK prescaler, system clock not divided (20MHz) */
  RCC->CFGR &= ~RCC_CFGR_HPRE_3;
 8000442:	4b16      	ldr	r3, [pc, #88]	; (800049c <SystemInit+0x128>)
 8000444:	685a      	ldr	r2, [r3, #4]
 8000446:	4b15      	ldr	r3, [pc, #84]	; (800049c <SystemInit+0x128>)
 8000448:	2180      	movs	r1, #128	; 0x80
 800044a:	438a      	bics	r2, r1
 800044c:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_HPRE_2;
 800044e:	4b13      	ldr	r3, [pc, #76]	; (800049c <SystemInit+0x128>)
 8000450:	685a      	ldr	r2, [r3, #4]
 8000452:	4b12      	ldr	r3, [pc, #72]	; (800049c <SystemInit+0x128>)
 8000454:	2140      	movs	r1, #64	; 0x40
 8000456:	438a      	bics	r2, r1
 8000458:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_HPRE_1;
 800045a:	4b10      	ldr	r3, [pc, #64]	; (800049c <SystemInit+0x128>)
 800045c:	685a      	ldr	r2, [r3, #4]
 800045e:	4b0f      	ldr	r3, [pc, #60]	; (800049c <SystemInit+0x128>)
 8000460:	2120      	movs	r1, #32
 8000462:	438a      	bics	r2, r1
 8000464:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_HPRE_0;
 8000466:	4b0d      	ldr	r3, [pc, #52]	; (800049c <SystemInit+0x128>)
 8000468:	685a      	ldr	r2, [r3, #4]
 800046a:	4b0c      	ldr	r3, [pc, #48]	; (800049c <SystemInit+0x128>)
 800046c:	2110      	movs	r1, #16
 800046e:	438a      	bics	r2, r1
 8000470:	605a      	str	r2, [r3, #4]

  /* PCLK prescaler, HCLK not divided (20MHz)
     NOTE: this will be the frequency used to feed the different TIMx */
  RCC->CFGR &= ~RCC_CFGR_PPRE_2;
 8000472:	4b0a      	ldr	r3, [pc, #40]	; (800049c <SystemInit+0x128>)
 8000474:	685a      	ldr	r2, [r3, #4]
 8000476:	4b09      	ldr	r3, [pc, #36]	; (800049c <SystemInit+0x128>)
 8000478:	490c      	ldr	r1, [pc, #48]	; (80004ac <SystemInit+0x138>)
 800047a:	400a      	ands	r2, r1
 800047c:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_PPRE_1;
 800047e:	4b07      	ldr	r3, [pc, #28]	; (800049c <SystemInit+0x128>)
 8000480:	685a      	ldr	r2, [r3, #4]
 8000482:	4b06      	ldr	r3, [pc, #24]	; (800049c <SystemInit+0x128>)
 8000484:	490a      	ldr	r1, [pc, #40]	; (80004b0 <SystemInit+0x13c>)
 8000486:	400a      	ands	r2, r1
 8000488:	605a      	str	r2, [r3, #4]
  RCC->CFGR &= ~RCC_CFGR_PPRE_0;
 800048a:	4b04      	ldr	r3, [pc, #16]	; (800049c <SystemInit+0x128>)
 800048c:	685a      	ldr	r2, [r3, #4]
 800048e:	4b03      	ldr	r3, [pc, #12]	; (800049c <SystemInit+0x128>)
 8000490:	4908      	ldr	r1, [pc, #32]	; (80004b4 <SystemInit+0x140>)
 8000492:	400a      	ands	r2, r1
 8000494:	605a      	str	r2, [r3, #4]

  /* NOTE: after this point the value of the variable SystemCoreClock will be read as
           40000000 instead of 20000000. This is due to fact ST did not take into account 
           HSI/2 can be the source of PLL (they make use of HSI for the computation of
           SystemCoreClock instead) */
}
 8000496:	46c0      	nop			; (mov r8, r8)
 8000498:	46bd      	mov	sp, r7
 800049a:	bd80      	pop	{r7, pc}
 800049c:	40021000 	.word	0x40021000
 80004a0:	fffe7fff 	.word	0xfffe7fff
 80004a4:	ffdfffff 	.word	0xffdfffff
 80004a8:	ffefffff 	.word	0xffefffff
 80004ac:	fffffbff 	.word	0xfffffbff
 80004b0:	fffffdff 	.word	0xfffffdff
 80004b4:	fffffeff 	.word	0xfffffeff

080004b8 <main>:
int16_t x0g, y0g, z0g;             /* Initial axes DATA values used in manual calibration */
int16_t xmeas, ymeas, zmeas;       /* Axes DATA values read from the ADXL345 whenever INT2 is triggered */
float *scaled_axes;                /* Axes scaled DATA values according to the selected format and g range */

int main( void )
{  
 80004b8:	b580      	push	{r7, lr}
 80004ba:	b086      	sub	sp, #24
 80004bc:	af00      	add	r7, sp, #0
   uint8_t  state = IDLE;          /* Current state */
 80004be:	2313      	movs	r3, #19
 80004c0:	18fb      	adds	r3, r7, r3
 80004c2:	2200      	movs	r2, #0
 80004c4:	701a      	strb	r2, [r3, #0]
   uint8_t  activityaxis;          /* Responsible axis for activity event */
   uint8_t  entries;               /* Data values stored in FIFO */
   uint8_t  interrupts;            /* Stores initial interrupts to be enabled */

   /* Initialize Systick (timebase for the state machine) */
   SysTick_Init();
 80004c6:	f001 f97b 	bl	80017c0 <SysTick_Init>

   /* Wait 2 secs */
   //Systick_Delay_Ms( 2000U );

   /* Configure GPIO input interrupts for handling ADXL345 INT interrupt pins */
   GPIO_Interrupt_Init();
 80004ca:	f000 fc09 	bl	8000ce0 <GPIO_Interrupt_Init>

   /**************************** LCD module initialization ****************************/
   LCD_Handler.lcdaddress        = LCD_ADDRESS;
 80004ce:	4b88      	ldr	r3, [pc, #544]	; (80006f0 <main+0x238>)
 80004d0:	2227      	movs	r2, #39	; 0x27
 80004d2:	701a      	strb	r2, [r3, #0]
   LCD_Handler.backlight         = BACKLIGHT_ENABLED;
 80004d4:	4b86      	ldr	r3, [pc, #536]	; (80006f0 <main+0x238>)
 80004d6:	2208      	movs	r2, #8
 80004d8:	705a      	strb	r2, [r3, #1]
   LCD_Handler.datalenght        = INTERFACE_DATA_4_BIT;
 80004da:	4b85      	ldr	r3, [pc, #532]	; (80006f0 <main+0x238>)
 80004dc:	2200      	movs	r2, #0
 80004de:	729a      	strb	r2, [r3, #10]
   LCD_Handler.displayline       = DISPLAY_2_LINES;
 80004e0:	4b83      	ldr	r3, [pc, #524]	; (80006f0 <main+0x238>)
 80004e2:	2208      	movs	r2, #8
 80004e4:	725a      	strb	r2, [r3, #9]
   LCD_Handler.font              = DISPLAY_FONT_TYPE_5x8;
 80004e6:	4b82      	ldr	r3, [pc, #520]	; (80006f0 <main+0x238>)
 80004e8:	2200      	movs	r2, #0
 80004ea:	721a      	strb	r2, [r3, #8]
   LCD_Handler.display           = DISPLAY_ON;
 80004ec:	4b80      	ldr	r3, [pc, #512]	; (80006f0 <main+0x238>)
 80004ee:	2204      	movs	r2, #4
 80004f0:	719a      	strb	r2, [r3, #6]
   LCD_Handler.cursor            = CURSOR_OFF;
 80004f2:	4b7f      	ldr	r3, [pc, #508]	; (80006f0 <main+0x238>)
 80004f4:	2200      	movs	r2, #0
 80004f6:	715a      	strb	r2, [r3, #5]
   LCD_Handler.blink             = CURSOR_BLINK_ON;
 80004f8:	4b7d      	ldr	r3, [pc, #500]	; (80006f0 <main+0x238>)
 80004fa:	2201      	movs	r2, #1
 80004fc:	711a      	strb	r2, [r3, #4]
   LCD_Handler.incrementddram    = ID_DDRAM_ADDRESS_RIGHT;
 80004fe:	4b7c      	ldr	r3, [pc, #496]	; (80006f0 <main+0x238>)
 8000500:	2202      	movs	r2, #2
 8000502:	70da      	strb	r2, [r3, #3]
   LCD_Handler.shiftdisplay      = SHIFT_DISPLAY_OFF;
 8000504:	4b7a      	ldr	r3, [pc, #488]	; (80006f0 <main+0x238>)
 8000506:	2200      	movs	r2, #0
 8000508:	709a      	strb	r2, [r3, #2]
   LCD_Init( &LCD_Handler );
 800050a:	4b79      	ldr	r3, [pc, #484]	; (80006f0 <main+0x238>)
 800050c:	0018      	movs	r0, r3
 800050e:	f000 ff67 	bl	80013e0 <LCD_Init>

   /************************ ADXL345 accelerometer initialization **********************/
   ACCEL_Handler.dataformat      = SELF_TEST_DISABLED | SPI_4WIRE_MODE | INT_INVERT_ACTIVE_HIGH | FULL_RES_10BIT_MODE | JUSTIFY_RIGHT | RANGE_2G;
 8000512:	4b78      	ldr	r3, [pc, #480]	; (80006f4 <main+0x23c>)
 8000514:	2200      	movs	r2, #0
 8000516:	74da      	strb	r2, [r3, #19]
   ACCEL_Handler.powerctl        = LINK_INACT_ACT_CONCURRENT | AUTO_SLEEP_DISABLED | MEASURE_ENABLED | SLEEP_DISABLED | WAKEUP_8HZ;
 8000518:	4b76      	ldr	r3, [pc, #472]	; (80006f4 <main+0x23c>)
 800051a:	2208      	movs	r2, #8
 800051c:	741a      	strb	r2, [r3, #16]
   ACCEL_Handler.bwrate          = LOW_POWER_DISABLED | RATE_6_25_HZ; /* Output data rate = 1/6.25Hz = 160ms */
 800051e:	4b75      	ldr	r3, [pc, #468]	; (80006f4 <main+0x23c>)
 8000520:	2206      	movs	r2, #6
 8000522:	73da      	strb	r2, [r3, #15]
   ACCEL_Handler.fifoctl         = FIFO_BYPASS_MODE;        /* No samples stored in FIFO */
 8000524:	4b73      	ldr	r3, [pc, #460]	; (80006f4 <main+0x23c>)
 8000526:	2200      	movs	r2, #0
 8000528:	751a      	strb	r2, [r3, #20]
   ACCEL_Handler.ofsx            = 0x00U;                   /* No offset on X axis (during initialization) */
 800052a:	4b72      	ldr	r3, [pc, #456]	; (80006f4 <main+0x23c>)
 800052c:	2200      	movs	r2, #0
 800052e:	709a      	strb	r2, [r3, #2]
   ACCEL_Handler.ofsy            = 0x00U;                   /* No offset on Y axis (during initialization) */
 8000530:	4b70      	ldr	r3, [pc, #448]	; (80006f4 <main+0x23c>)
 8000532:	2200      	movs	r2, #0
 8000534:	70da      	strb	r2, [r3, #3]
   ACCEL_Handler.ofsz            = 0x00U;                   /* No offset on Z axis (during initialization) */
 8000536:	4b6f      	ldr	r3, [pc, #444]	; (80006f4 <main+0x23c>)
 8000538:	2200      	movs	r2, #0
 800053a:	711a      	strb	r2, [r3, #4]
   /* ADXL345 DATA_READY interrupt (triggered every 160ms and corresponds to the output data rate set in ACCEL_Handler.bwrate) */
   interrupts                    = DATA_READY_INT_ENABLED;  /* Initial interrupts to be enabled, used to evaluate which interrupt is triggered.
 800053c:	1dfb      	adds	r3, r7, #7
 800053e:	2280      	movs	r2, #128	; 0x80
 8000540:	701a      	strb	r2, [r3, #0]
                                                               (INT_SOURCE does not work for this purpose and intenable structure member is 
                                                               updated automatically by the driver, therefore when interrupts are disabled
                                                               intenable is read as 0 and no interrupt would be correctly handled) */
   ACCEL_Handler.intenable       = interrupts;              /* DATA_READY interrupt enabled */
 8000542:	1dfb      	adds	r3, r7, #7
 8000544:	781a      	ldrb	r2, [r3, #0]
 8000546:	4b6b      	ldr	r3, [pc, #428]	; (80006f4 <main+0x23c>)
 8000548:	745a      	strb	r2, [r3, #17]
   ACCEL_Handler.intmap          = DATA_READY_INT_MAP_INT1; /* DATA_READY interrupt output mapped to ADXL345 INT1 pin */
 800054a:	4b6a      	ldr	r3, [pc, #424]	; (80006f4 <main+0x23c>)
 800054c:	2200      	movs	r2, #0
 800054e:	749a      	strb	r2, [r3, #18]
      #undef MANUAL_CALIBRATION /* NOTE: for the sake of this program when OVERRUN interrupt is enabled, manual calibration must be avoided
                                         since this yields to the values read for X, Y and Z axes to be incremented/decremented endlessly
                                         (in the MANUAL_OFFSET state) due to no values are read when the DATA_READ interrupt is triggered
                                         (DATA_READY does not read the DATA registers despite being enabled in this case. Refer to interrupts.c) */
   #endif
   ADXL345_Init( &ACCEL_Handler );
 8000550:	4b68      	ldr	r3, [pc, #416]	; (80006f4 <main+0x23c>)
 8000552:	0018      	movs	r0, r3
 8000554:	f001 fbd5 	bl	8001d02 <ADXL345_Init>
      ADXL345_Write( OFSY_REG, 0x00U );
      ADXL345_Write( OFSZ_REG, 0x00U );
   /* If manual calibration is enabled */
   #elif defined (MANUAL_CALIBRATION)
      /* Get the initial values of the 3 axes (needed for manual calibration) */
      ADXL345_API_Manual_OffsetCal( &ACCEL_Handler, &x0g, &y0g, &z0g );
 8000558:	4b67      	ldr	r3, [pc, #412]	; (80006f8 <main+0x240>)
 800055a:	4a68      	ldr	r2, [pc, #416]	; (80006fc <main+0x244>)
 800055c:	4968      	ldr	r1, [pc, #416]	; (8000700 <main+0x248>)
 800055e:	4865      	ldr	r0, [pc, #404]	; (80006f4 <main+0x23c>)
 8000560:	f001 fca5 	bl	8001eae <ADXL345_API_Manual_OffsetCal>
      - Bare in mind that using this function reconfigures some of the ADXL345 registers. See the function for more details
   int16_t xst, yst, zst; self test values in LSBs returned by the SELF_TEST function
   ADXL345_API_Self_Test( &ACCEL_Handler, &xst, &yst, &zst ); */

   /* Initialize state machine timer */
   stateClock = Get_SysTick();
 8000564:	f001 f954 	bl	8001810 <Get_SysTick>
 8000568:	0003      	movs	r3, r0
 800056a:	617b      	str	r3, [r7, #20]

   while( 1 )
   {  
      /* If 40ms have passed */
      if ( ( Get_SysTick() - stateClock ) >= 40U )
 800056c:	f001 f950 	bl	8001810 <Get_SysTick>
 8000570:	0002      	movs	r2, r0
 8000572:	697b      	ldr	r3, [r7, #20]
 8000574:	1ad3      	subs	r3, r2, r3
 8000576:	2b27      	cmp	r3, #39	; 0x27
 8000578:	d9f8      	bls.n	800056c <main+0xb4>
      {
         /* Update state machine clock */
         stateClock = Get_SysTick();
 800057a:	f001 f949 	bl	8001810 <Get_SysTick>
 800057e:	0003      	movs	r3, r0
 8000580:	617b      	str	r3, [r7, #20]

         switch( state )
 8000582:	2313      	movs	r3, #19
 8000584:	18fb      	adds	r3, r7, r3
 8000586:	781b      	ldrb	r3, [r3, #0]
 8000588:	2b14      	cmp	r3, #20
 800058a:	d900      	bls.n	800058e <main+0xd6>
 800058c:	e0a9      	b.n	80006e2 <main+0x22a>
 800058e:	009a      	lsls	r2, r3, #2
 8000590:	4b5c      	ldr	r3, [pc, #368]	; (8000704 <main+0x24c>)
 8000592:	18d3      	adds	r3, r2, r3
 8000594:	681b      	ldr	r3, [r3, #0]
 8000596:	469f      	mov	pc, r3
         {
            case IDLE:
               idle( &state );
 8000598:	2313      	movs	r3, #19
 800059a:	18fb      	adds	r3, r7, r3
 800059c:	0018      	movs	r0, r3
 800059e:	f000 f8b3 	bl	8000708 <idle>
               break;
 80005a2:	e0a3      	b.n	80006ec <main+0x234>

            case MANUAL_OFFSET:
               manual_offset( &state );
 80005a4:	2313      	movs	r3, #19
 80005a6:	18fb      	adds	r3, r7, r3
 80005a8:	0018      	movs	r0, r3
 80005aa:	f000 f8e1 	bl	8000770 <manual_offset>
               break;
 80005ae:	e09d      	b.n	80006ec <main+0x234>

            case SCALE_AXES:
               scale_axes( &state );
 80005b0:	2313      	movs	r3, #19
 80005b2:	18fb      	adds	r3, r7, r3
 80005b4:	0018      	movs	r0, r3
 80005b6:	f000 f919 	bl	80007ec <scale_axes>
               break;
 80005ba:	e097      	b.n	80006ec <main+0x234>

            case PRINT_AXES:
               print_axes( &state );
 80005bc:	2313      	movs	r3, #19
 80005be:	18fb      	adds	r3, r7, r3
 80005c0:	0018      	movs	r0, r3
 80005c2:	f000 f937 	bl	8000834 <print_axes>
               break;
 80005c6:	e091      	b.n	80006ec <main+0x234>

            case PRINT_SINGLE_TAP:
               print_single_tap( &state, &int2Clock, &tapaxis );
 80005c8:	230a      	movs	r3, #10
 80005ca:	18fa      	adds	r2, r7, r3
 80005cc:	230c      	movs	r3, #12
 80005ce:	18f9      	adds	r1, r7, r3
 80005d0:	2313      	movs	r3, #19
 80005d2:	18fb      	adds	r3, r7, r3
 80005d4:	0018      	movs	r0, r3
 80005d6:	f000 f94b 	bl	8000870 <print_single_tap>
               break;
 80005da:	e087      	b.n	80006ec <main+0x234>

            case PRINT_DOUBLE_TAP:
               print_double_tap( &state, &int2Clock, &tapaxis );
 80005dc:	230a      	movs	r3, #10
 80005de:	18fa      	adds	r2, r7, r3
 80005e0:	230c      	movs	r3, #12
 80005e2:	18f9      	adds	r1, r7, r3
 80005e4:	2313      	movs	r3, #19
 80005e6:	18fb      	adds	r3, r7, r3
 80005e8:	0018      	movs	r0, r3
 80005ea:	f000 f96b 	bl	80008c4 <print_double_tap>
               break;
 80005ee:	e07d      	b.n	80006ec <main+0x234>

            case PRINT_ACTIVITY:
               print_activity( &state, &int2Clock, &activityaxis );
 80005f0:	2309      	movs	r3, #9
 80005f2:	18fa      	adds	r2, r7, r3
 80005f4:	230c      	movs	r3, #12
 80005f6:	18f9      	adds	r1, r7, r3
 80005f8:	2313      	movs	r3, #19
 80005fa:	18fb      	adds	r3, r7, r3
 80005fc:	0018      	movs	r0, r3
 80005fe:	f000 f98b 	bl	8000918 <print_activity>
               break;
 8000602:	e073      	b.n	80006ec <main+0x234>

            case PRINT_INACTIVITY:
               print_inactivity( &state, &int2Clock );
 8000604:	230c      	movs	r3, #12
 8000606:	18fa      	adds	r2, r7, r3
 8000608:	2313      	movs	r3, #19
 800060a:	18fb      	adds	r3, r7, r3
 800060c:	0011      	movs	r1, r2
 800060e:	0018      	movs	r0, r3
 8000610:	f000 f9ac 	bl	800096c <print_inactivity>
               break;
 8000614:	e06a      	b.n	80006ec <main+0x234>

            case PRINT_FREE_FALL:
               print_free_fall( &state, &int2Clock );
 8000616:	230c      	movs	r3, #12
 8000618:	18fa      	adds	r2, r7, r3
 800061a:	2313      	movs	r3, #19
 800061c:	18fb      	adds	r3, r7, r3
 800061e:	0011      	movs	r1, r2
 8000620:	0018      	movs	r0, r3
 8000622:	f000 f9cb 	bl	80009bc <print_free_fall>
               break;
 8000626:	e061      	b.n	80006ec <main+0x234>

            case PRINT_WATERMARK:
               print_watermark( &state, &entries );
 8000628:	2308      	movs	r3, #8
 800062a:	18fa      	adds	r2, r7, r3
 800062c:	2313      	movs	r3, #19
 800062e:	18fb      	adds	r3, r7, r3
 8000630:	0011      	movs	r1, r2
 8000632:	0018      	movs	r0, r3
 8000634:	f000 fa00 	bl	8000a38 <print_watermark>
               break;
 8000638:	e058      	b.n	80006ec <main+0x234>

            case PRINT_OVERRUN:
               print_overrun( &state );
 800063a:	2313      	movs	r3, #19
 800063c:	18fb      	adds	r3, r7, r3
 800063e:	0018      	movs	r0, r3
 8000640:	f000 f9e4 	bl	8000a0c <print_overrun>
               break;
 8000644:	e052      	b.n	80006ec <main+0x234>

            case DISABLE_INTERRUPTS:
               disable_interrupts( &state );
 8000646:	2313      	movs	r3, #19
 8000648:	18fb      	adds	r3, r7, r3
 800064a:	0018      	movs	r0, r3
 800064c:	f000 fa10 	bl	8000a70 <disable_interrupts>
               break;
 8000650:	e04c      	b.n	80006ec <main+0x234>

            case ENABLE_INTERRUPTS:
               enable_interrupts( &state, &interrupts );
 8000652:	1dfa      	adds	r2, r7, #7
 8000654:	2313      	movs	r3, #19
 8000656:	18fb      	adds	r3, r7, r3
 8000658:	0011      	movs	r1, r2
 800065a:	0018      	movs	r0, r3
 800065c:	f000 fa28 	bl	8000ab0 <enable_interrupts>
               break;
 8000660:	e044      	b.n	80006ec <main+0x234>

            case CLEAR_INT2_FLAGS:
               clear_int2_flags( &state, &int2Clock );
 8000662:	230c      	movs	r3, #12
 8000664:	18fa      	adds	r2, r7, r3
 8000666:	2313      	movs	r3, #19
 8000668:	18fb      	adds	r3, r7, r3
 800066a:	0011      	movs	r1, r2
 800066c:	0018      	movs	r0, r3
 800066e:	f000 fa3d 	bl	8000aec <clear_int2_flags>
               break;
 8000672:	e03b      	b.n	80006ec <main+0x234>

            case EVALUATE_INT2:
               evaluate_int2( &state, &interrupts, &intsource );
 8000674:	230b      	movs	r3, #11
 8000676:	18fa      	adds	r2, r7, r3
 8000678:	1df9      	adds	r1, r7, #7
 800067a:	2313      	movs	r3, #19
 800067c:	18fb      	adds	r3, r7, r3
 800067e:	0018      	movs	r0, r3
 8000680:	f000 fa5a 	bl	8000b38 <evaluate_int2>
               break;
 8000684:	e032      	b.n	80006ec <main+0x234>

            case GET_TAP_AXIS:
               get_tap_axis( &state, &tapaxis, &intsource );
 8000686:	230b      	movs	r3, #11
 8000688:	18fa      	adds	r2, r7, r3
 800068a:	230a      	movs	r3, #10
 800068c:	18f9      	adds	r1, r7, r3
 800068e:	2313      	movs	r3, #19
 8000690:	18fb      	adds	r3, r7, r3
 8000692:	0018      	movs	r0, r3
 8000694:	f000 fa8e 	bl	8000bb4 <get_tap_axis>
               break;
 8000698:	e028      	b.n	80006ec <main+0x234>

            case GET_ACTIVITY_AXIS:
               get_activity_axis( &state, &activityaxis );
 800069a:	2309      	movs	r3, #9
 800069c:	18fa      	adds	r2, r7, r3
 800069e:	2313      	movs	r3, #19
 80006a0:	18fb      	adds	r3, r7, r3
 80006a2:	0011      	movs	r1, r2
 80006a4:	0018      	movs	r0, r3
 80006a6:	f000 faa5 	bl	8000bf4 <get_activity_axis>
               break;
 80006aa:	e01f      	b.n	80006ec <main+0x234>

            case READ_FIFO_ENTRIES:
               read_fifo_entries( &state, &entries );
 80006ac:	2308      	movs	r3, #8
 80006ae:	18fa      	adds	r2, r7, r3
 80006b0:	2313      	movs	r3, #19
 80006b2:	18fb      	adds	r3, r7, r3
 80006b4:	0011      	movs	r1, r2
 80006b6:	0018      	movs	r0, r3
 80006b8:	f000 fab2 	bl	8000c20 <read_fifo_entries>
               break;
 80006bc:	e016      	b.n	80006ec <main+0x234>

            case READ_INT2_PIN:
               read_int2_pin( &state );
 80006be:	2313      	movs	r3, #19
 80006c0:	18fb      	adds	r3, r7, r3
 80006c2:	0018      	movs	r0, r3
 80006c4:	f000 fad0 	bl	8000c68 <read_int2_pin>
               break;
 80006c8:	e010      	b.n	80006ec <main+0x234>

            case SET_STANDBY_MODE:
               set_standby_mode( &state );
 80006ca:	2313      	movs	r3, #19
 80006cc:	18fb      	adds	r3, r7, r3
 80006ce:	0018      	movs	r0, r3
 80006d0:	f000 fae2 	bl	8000c98 <set_standby_mode>
               break;
 80006d4:	e00a      	b.n	80006ec <main+0x234>

            case SET_MEASUREMENT_MODE:
               set_measurement_mode( &state );
 80006d6:	2313      	movs	r3, #19
 80006d8:	18fb      	adds	r3, r7, r3
 80006da:	0018      	movs	r0, r3
 80006dc:	f000 faee 	bl	8000cbc <set_measurement_mode>
               break;
 80006e0:	e004      	b.n	80006ec <main+0x234>

            default:
               state = IDLE;
 80006e2:	2313      	movs	r3, #19
 80006e4:	18fb      	adds	r3, r7, r3
 80006e6:	2200      	movs	r2, #0
 80006e8:	701a      	strb	r2, [r3, #0]
               break;
 80006ea:	46c0      	nop			; (mov r8, r8)
      if ( ( Get_SysTick() - stateClock ) >= 40U )
 80006ec:	e73e      	b.n	800056c <main+0xb4>
 80006ee:	46c0      	nop			; (mov r8, r8)
 80006f0:	2000001c 	.word	0x2000001c
 80006f4:	20000028 	.word	0x20000028
 80006f8:	20000042 	.word	0x20000042
 80006fc:	20000040 	.word	0x20000040
 8000700:	2000003e 	.word	0x2000003e
 8000704:	08003854 	.word	0x08003854

08000708 <idle>:

   return 0U;
}

void idle( uint8_t *curr_state )
{
 8000708:	b580      	push	{r7, lr}
 800070a:	b082      	sub	sp, #8
 800070c:	af00      	add	r7, sp, #0
 800070e:	6078      	str	r0, [r7, #4]
   /* If INT2 was triggered on the ADXL345 (GPIOC1 input) and OVERRUN interrupt is disabled */
   if ( ( int2Flag == 1U ) && ( ( ACCEL_Handler.intenable & OVERRUN_INT_ENABLED ) != OVERRUN_INT_ENABLED ) )
 8000710:	4b14      	ldr	r3, [pc, #80]	; (8000764 <idle+0x5c>)
 8000712:	781b      	ldrb	r3, [r3, #0]
 8000714:	2b01      	cmp	r3, #1
 8000716:	d109      	bne.n	800072c <idle+0x24>
 8000718:	4b13      	ldr	r3, [pc, #76]	; (8000768 <idle+0x60>)
 800071a:	7c5b      	ldrb	r3, [r3, #17]
 800071c:	001a      	movs	r2, r3
 800071e:	2301      	movs	r3, #1
 8000720:	4013      	ands	r3, r2
 8000722:	d103      	bne.n	800072c <idle+0x24>
   {
      *curr_state = DISABLE_INTERRUPTS;
 8000724:	687b      	ldr	r3, [r7, #4]
 8000726:	220b      	movs	r2, #11
 8000728:	701a      	strb	r2, [r3, #0]
 800072a:	e016      	b.n	800075a <idle+0x52>
   }
   /* If INT2 was triggered on the ADXL345 (GPIOC1 input) and OVERRUN interrupt is enabled */
   else if ( ( int2Flag == 1U ) && ( ( ACCEL_Handler.intenable & OVERRUN_INT_ENABLED ) == OVERRUN_INT_ENABLED ) )
 800072c:	4b0d      	ldr	r3, [pc, #52]	; (8000764 <idle+0x5c>)
 800072e:	781b      	ldrb	r3, [r3, #0]
 8000730:	2b01      	cmp	r3, #1
 8000732:	d10e      	bne.n	8000752 <idle+0x4a>
 8000734:	4b0c      	ldr	r3, [pc, #48]	; (8000768 <idle+0x60>)
 8000736:	7c5b      	ldrb	r3, [r3, #17]
 8000738:	001a      	movs	r2, r3
 800073a:	2301      	movs	r3, #1
 800073c:	4013      	ands	r3, r2
 800073e:	d008      	beq.n	8000752 <idle+0x4a>
   {
      /* Clear screen */
      LCD_Send_Instruction( &LCD_Handler, CLEAR_DISPLAY_REG );
 8000740:	4b0a      	ldr	r3, [pc, #40]	; (800076c <idle+0x64>)
 8000742:	2101      	movs	r1, #1
 8000744:	0018      	movs	r0, r3
 8000746:	f000 feb1 	bl	80014ac <LCD_Send_Instruction>

      /* OVERRUN interrupt is handled differently in this program to any other interrupt, reason is due to the
         ADXL345 interrupts will not be disabled (INT1 and INT2 pins will not be forced to LOW) in order to know
         when DATA is available on the DATA registers (INT1) and when OVERRUN interrupt is triggered (INT2) */
      *curr_state = PRINT_OVERRUN;
 800074a:	687b      	ldr	r3, [r7, #4]
 800074c:	220a      	movs	r2, #10
 800074e:	701a      	strb	r2, [r3, #0]
 8000750:	e003      	b.n	800075a <idle+0x52>
   /* If INT2 was not triggered */
   else
   {
      #if defined (MANUAL_CALIBRATION)
         /* Offset for ADXL345 DATA registers must be applied manually */
         *curr_state = MANUAL_OFFSET;
 8000752:	687b      	ldr	r3, [r7, #4]
 8000754:	2201      	movs	r2, #1
 8000756:	701a      	strb	r2, [r3, #0]
      #else
         /* Offset for ADXL345 DATA registers is applied automatically (no extra action required) */
         *curr_state = SCALE_AXES;
      #endif
   }
}
 8000758:	46c0      	nop			; (mov r8, r8)
 800075a:	46c0      	nop			; (mov r8, r8)
 800075c:	46bd      	mov	sp, r7
 800075e:	b002      	add	sp, #8
 8000760:	bd80      	pop	{r7, pc}
 8000762:	46c0      	nop			; (mov r8, r8)
 8000764:	2000003d 	.word	0x2000003d
 8000768:	20000028 	.word	0x20000028
 800076c:	2000001c 	.word	0x2000001c

08000770 <manual_offset>:

void manual_offset( uint8_t *curr_state )
{
 8000770:	b580      	push	{r7, lr}
 8000772:	b082      	sub	sp, #8
 8000774:	af00      	add	r7, sp, #0
 8000776:	6078      	str	r0, [r7, #4]
   /* Apply offset to the data read (xmeas, ymeas and zmeas are the raw data values
      obtained from the ADXL345 whenever the DATA_READY interrupt is triggered on GPIOC0) */
   xmeas -= x0g;
 8000778:	4b16      	ldr	r3, [pc, #88]	; (80007d4 <manual_offset+0x64>)
 800077a:	2200      	movs	r2, #0
 800077c:	5e9b      	ldrsh	r3, [r3, r2]
 800077e:	b29a      	uxth	r2, r3
 8000780:	4b15      	ldr	r3, [pc, #84]	; (80007d8 <manual_offset+0x68>)
 8000782:	2100      	movs	r1, #0
 8000784:	5e5b      	ldrsh	r3, [r3, r1]
 8000786:	b29b      	uxth	r3, r3
 8000788:	1ad3      	subs	r3, r2, r3
 800078a:	b29b      	uxth	r3, r3
 800078c:	b21a      	sxth	r2, r3
 800078e:	4b11      	ldr	r3, [pc, #68]	; (80007d4 <manual_offset+0x64>)
 8000790:	801a      	strh	r2, [r3, #0]
   ymeas -= y0g;
 8000792:	4b12      	ldr	r3, [pc, #72]	; (80007dc <manual_offset+0x6c>)
 8000794:	2200      	movs	r2, #0
 8000796:	5e9b      	ldrsh	r3, [r3, r2]
 8000798:	b29a      	uxth	r2, r3
 800079a:	4b11      	ldr	r3, [pc, #68]	; (80007e0 <manual_offset+0x70>)
 800079c:	2100      	movs	r1, #0
 800079e:	5e5b      	ldrsh	r3, [r3, r1]
 80007a0:	b29b      	uxth	r3, r3
 80007a2:	1ad3      	subs	r3, r2, r3
 80007a4:	b29b      	uxth	r3, r3
 80007a6:	b21a      	sxth	r2, r3
 80007a8:	4b0c      	ldr	r3, [pc, #48]	; (80007dc <manual_offset+0x6c>)
 80007aa:	801a      	strh	r2, [r3, #0]
   zmeas -= z0g;
 80007ac:	4b0d      	ldr	r3, [pc, #52]	; (80007e4 <manual_offset+0x74>)
 80007ae:	2200      	movs	r2, #0
 80007b0:	5e9b      	ldrsh	r3, [r3, r2]
 80007b2:	b29a      	uxth	r2, r3
 80007b4:	4b0c      	ldr	r3, [pc, #48]	; (80007e8 <manual_offset+0x78>)
 80007b6:	2100      	movs	r1, #0
 80007b8:	5e5b      	ldrsh	r3, [r3, r1]
 80007ba:	b29b      	uxth	r3, r3
 80007bc:	1ad3      	subs	r3, r2, r3
 80007be:	b29b      	uxth	r3, r3
 80007c0:	b21a      	sxth	r2, r3
 80007c2:	4b08      	ldr	r3, [pc, #32]	; (80007e4 <manual_offset+0x74>)
 80007c4:	801a      	strh	r2, [r3, #0]

   *curr_state = SCALE_AXES;
 80007c6:	687b      	ldr	r3, [r7, #4]
 80007c8:	2202      	movs	r2, #2
 80007ca:	701a      	strb	r2, [r3, #0]
}
 80007cc:	46c0      	nop			; (mov r8, r8)
 80007ce:	46bd      	mov	sp, r7
 80007d0:	b002      	add	sp, #8
 80007d2:	bd80      	pop	{r7, pc}
 80007d4:	20000044 	.word	0x20000044
 80007d8:	2000003e 	.word	0x2000003e
 80007dc:	20000046 	.word	0x20000046
 80007e0:	20000040 	.word	0x20000040
 80007e4:	20000048 	.word	0x20000048
 80007e8:	20000042 	.word	0x20000042

080007ec <scale_axes>:

void scale_axes( uint8_t *curr_state )
{
 80007ec:	b580      	push	{r7, lr}
 80007ee:	b082      	sub	sp, #8
 80007f0:	af00      	add	r7, sp, #0
 80007f2:	6078      	str	r0, [r7, #4]
   /* Scale data according to the selected g range (at this point an offset has been
      already applied on xmeas, ymeas and zmeas either manually or automatically) */
   scaled_axes = ADXL345_API_Scale_Axes( &ACCEL_Handler, xmeas, ymeas, zmeas );
 80007f4:	4b0a      	ldr	r3, [pc, #40]	; (8000820 <scale_axes+0x34>)
 80007f6:	2100      	movs	r1, #0
 80007f8:	5e59      	ldrsh	r1, [r3, r1]
 80007fa:	4b0a      	ldr	r3, [pc, #40]	; (8000824 <scale_axes+0x38>)
 80007fc:	2200      	movs	r2, #0
 80007fe:	5e9a      	ldrsh	r2, [r3, r2]
 8000800:	4b09      	ldr	r3, [pc, #36]	; (8000828 <scale_axes+0x3c>)
 8000802:	2000      	movs	r0, #0
 8000804:	5e1b      	ldrsh	r3, [r3, r0]
 8000806:	4809      	ldr	r0, [pc, #36]	; (800082c <scale_axes+0x40>)
 8000808:	f001 fca2 	bl	8002150 <ADXL345_API_Scale_Axes>
 800080c:	0002      	movs	r2, r0
 800080e:	4b08      	ldr	r3, [pc, #32]	; (8000830 <scale_axes+0x44>)
 8000810:	601a      	str	r2, [r3, #0]

   *curr_state = PRINT_AXES;
 8000812:	687b      	ldr	r3, [r7, #4]
 8000814:	2203      	movs	r2, #3
 8000816:	701a      	strb	r2, [r3, #0]
}
 8000818:	46c0      	nop			; (mov r8, r8)
 800081a:	46bd      	mov	sp, r7
 800081c:	b002      	add	sp, #8
 800081e:	bd80      	pop	{r7, pc}
 8000820:	20000044 	.word	0x20000044
 8000824:	20000046 	.word	0x20000046
 8000828:	20000048 	.word	0x20000048
 800082c:	20000028 	.word	0x20000028
 8000830:	2000004c 	.word	0x2000004c

08000834 <print_axes>:

void print_axes( uint8_t *curr_state )
{
 8000834:	b580      	push	{r7, lr}
 8000836:	b082      	sub	sp, #8
 8000838:	af00      	add	r7, sp, #0
 800083a:	6078      	str	r0, [r7, #4]
   /* Print read acceleration (one sample is obtained whenever INT1 is triggered) */
   lcd_print_all_axes_info( &LCD_Handler, scaled_axes[ 0 ], scaled_axes[ 1 ], scaled_axes[ 2 ] );
 800083c:	4b0a      	ldr	r3, [pc, #40]	; (8000868 <print_axes+0x34>)
 800083e:	681b      	ldr	r3, [r3, #0]
 8000840:	6819      	ldr	r1, [r3, #0]
 8000842:	4b09      	ldr	r3, [pc, #36]	; (8000868 <print_axes+0x34>)
 8000844:	681b      	ldr	r3, [r3, #0]
 8000846:	3304      	adds	r3, #4
 8000848:	681a      	ldr	r2, [r3, #0]
 800084a:	4b07      	ldr	r3, [pc, #28]	; (8000868 <print_axes+0x34>)
 800084c:	681b      	ldr	r3, [r3, #0]
 800084e:	3308      	adds	r3, #8
 8000850:	681b      	ldr	r3, [r3, #0]
 8000852:	4806      	ldr	r0, [pc, #24]	; (800086c <print_axes+0x38>)
 8000854:	f001 ffbe 	bl	80027d4 <lcd_print_all_axes_info>

   *curr_state = IDLE;
 8000858:	687b      	ldr	r3, [r7, #4]
 800085a:	2200      	movs	r2, #0
 800085c:	701a      	strb	r2, [r3, #0]
}
 800085e:	46c0      	nop			; (mov r8, r8)
 8000860:	46bd      	mov	sp, r7
 8000862:	b002      	add	sp, #8
 8000864:	bd80      	pop	{r7, pc}
 8000866:	46c0      	nop			; (mov r8, r8)
 8000868:	2000004c 	.word	0x2000004c
 800086c:	2000001c 	.word	0x2000001c

08000870 <print_single_tap>:

void print_single_tap( uint8_t *curr_state, uint32_t *int2_clk, uint8_t *tap_axis )
{
 8000870:	b590      	push	{r4, r7, lr}
 8000872:	b085      	sub	sp, #20
 8000874:	af00      	add	r7, sp, #0
 8000876:	60f8      	str	r0, [r7, #12]
 8000878:	60b9      	str	r1, [r7, #8]
 800087a:	607a      	str	r2, [r7, #4]
   lcd_print_single_tap( &LCD_Handler, &ACCEL_Handler, *tap_axis, ACCEL_Handler.threshtap * 0.0625F );
 800087c:	687b      	ldr	r3, [r7, #4]
 800087e:	781c      	ldrb	r4, [r3, #0]
 8000880:	4b0e      	ldr	r3, [pc, #56]	; (80008bc <print_single_tap+0x4c>)
 8000882:	785b      	ldrb	r3, [r3, #1]
 8000884:	0018      	movs	r0, r3
 8000886:	f002 ff23 	bl	80036d0 <__aeabi_i2f>
 800088a:	1c03      	adds	r3, r0, #0
 800088c:	21f6      	movs	r1, #246	; 0xf6
 800088e:	0589      	lsls	r1, r1, #22
 8000890:	1c18      	adds	r0, r3, #0
 8000892:	f002 fc2d 	bl	80030f0 <__aeabi_fmul>
 8000896:	1c03      	adds	r3, r0, #0
 8000898:	4908      	ldr	r1, [pc, #32]	; (80008bc <print_single_tap+0x4c>)
 800089a:	4809      	ldr	r0, [pc, #36]	; (80008c0 <print_single_tap+0x50>)
 800089c:	0022      	movs	r2, r4
 800089e:	f001 ffdb 	bl	8002858 <lcd_print_single_tap>

   /* Start timer to stop printing the INT2 event on the LCD */
   *int2_clk = Get_SysTick();
 80008a2:	f000 ffb5 	bl	8001810 <Get_SysTick>
 80008a6:	0002      	movs	r2, r0
 80008a8:	68bb      	ldr	r3, [r7, #8]
 80008aa:	601a      	str	r2, [r3, #0]

   *curr_state = CLEAR_INT2_FLAGS;
 80008ac:	68fb      	ldr	r3, [r7, #12]
 80008ae:	220d      	movs	r2, #13
 80008b0:	701a      	strb	r2, [r3, #0]
}
 80008b2:	46c0      	nop			; (mov r8, r8)
 80008b4:	46bd      	mov	sp, r7
 80008b6:	b005      	add	sp, #20
 80008b8:	bd90      	pop	{r4, r7, pc}
 80008ba:	46c0      	nop			; (mov r8, r8)
 80008bc:	20000028 	.word	0x20000028
 80008c0:	2000001c 	.word	0x2000001c

080008c4 <print_double_tap>:

void print_double_tap( uint8_t *curr_state, uint32_t *int2_clk, uint8_t *tap_axis )
{
 80008c4:	b590      	push	{r4, r7, lr}
 80008c6:	b085      	sub	sp, #20
 80008c8:	af00      	add	r7, sp, #0
 80008ca:	60f8      	str	r0, [r7, #12]
 80008cc:	60b9      	str	r1, [r7, #8]
 80008ce:	607a      	str	r2, [r7, #4]
   lcd_print_double_tap( &LCD_Handler, &ACCEL_Handler, *tap_axis, ACCEL_Handler.threshtap * 0.0625F );
 80008d0:	687b      	ldr	r3, [r7, #4]
 80008d2:	781c      	ldrb	r4, [r3, #0]
 80008d4:	4b0e      	ldr	r3, [pc, #56]	; (8000910 <print_double_tap+0x4c>)
 80008d6:	785b      	ldrb	r3, [r3, #1]
 80008d8:	0018      	movs	r0, r3
 80008da:	f002 fef9 	bl	80036d0 <__aeabi_i2f>
 80008de:	1c03      	adds	r3, r0, #0
 80008e0:	21f6      	movs	r1, #246	; 0xf6
 80008e2:	0589      	lsls	r1, r1, #22
 80008e4:	1c18      	adds	r0, r3, #0
 80008e6:	f002 fc03 	bl	80030f0 <__aeabi_fmul>
 80008ea:	1c03      	adds	r3, r0, #0
 80008ec:	4908      	ldr	r1, [pc, #32]	; (8000910 <print_double_tap+0x4c>)
 80008ee:	4809      	ldr	r0, [pc, #36]	; (8000914 <print_double_tap+0x50>)
 80008f0:	0022      	movs	r2, r4
 80008f2:	f001 ffff 	bl	80028f4 <lcd_print_double_tap>

   /* Start timer to stop printing the INT2 event on the LCD */
   *int2_clk = Get_SysTick();
 80008f6:	f000 ff8b 	bl	8001810 <Get_SysTick>
 80008fa:	0002      	movs	r2, r0
 80008fc:	68bb      	ldr	r3, [r7, #8]
 80008fe:	601a      	str	r2, [r3, #0]

   *curr_state = CLEAR_INT2_FLAGS;
 8000900:	68fb      	ldr	r3, [r7, #12]
 8000902:	220d      	movs	r2, #13
 8000904:	701a      	strb	r2, [r3, #0]
}
 8000906:	46c0      	nop			; (mov r8, r8)
 8000908:	46bd      	mov	sp, r7
 800090a:	b005      	add	sp, #20
 800090c:	bd90      	pop	{r4, r7, pc}
 800090e:	46c0      	nop			; (mov r8, r8)
 8000910:	20000028 	.word	0x20000028
 8000914:	2000001c 	.word	0x2000001c

08000918 <print_activity>:

void print_activity( uint8_t *curr_state, uint32_t *int2_clk, uint8_t *activity_axis )
{
 8000918:	b590      	push	{r4, r7, lr}
 800091a:	b085      	sub	sp, #20
 800091c:	af00      	add	r7, sp, #0
 800091e:	60f8      	str	r0, [r7, #12]
 8000920:	60b9      	str	r1, [r7, #8]
 8000922:	607a      	str	r2, [r7, #4]
   lcd_print_activity( &LCD_Handler, &ACCEL_Handler, *activity_axis, ACCEL_Handler.threshact * 0.0625F );
 8000924:	687b      	ldr	r3, [r7, #4]
 8000926:	781c      	ldrb	r4, [r3, #0]
 8000928:	4b0e      	ldr	r3, [pc, #56]	; (8000964 <print_activity+0x4c>)
 800092a:	7a1b      	ldrb	r3, [r3, #8]
 800092c:	0018      	movs	r0, r3
 800092e:	f002 fecf 	bl	80036d0 <__aeabi_i2f>
 8000932:	1c03      	adds	r3, r0, #0
 8000934:	21f6      	movs	r1, #246	; 0xf6
 8000936:	0589      	lsls	r1, r1, #22
 8000938:	1c18      	adds	r0, r3, #0
 800093a:	f002 fbd9 	bl	80030f0 <__aeabi_fmul>
 800093e:	1c03      	adds	r3, r0, #0
 8000940:	4908      	ldr	r1, [pc, #32]	; (8000964 <print_activity+0x4c>)
 8000942:	4809      	ldr	r0, [pc, #36]	; (8000968 <print_activity+0x50>)
 8000944:	0022      	movs	r2, r4
 8000946:	f002 f823 	bl	8002990 <lcd_print_activity>

   /* Start timer to stop printing the INT2 event on the LCD */
   *int2_clk = Get_SysTick();
 800094a:	f000 ff61 	bl	8001810 <Get_SysTick>
 800094e:	0002      	movs	r2, r0
 8000950:	68bb      	ldr	r3, [r7, #8]
 8000952:	601a      	str	r2, [r3, #0]

   *curr_state = CLEAR_INT2_FLAGS;
 8000954:	68fb      	ldr	r3, [r7, #12]
 8000956:	220d      	movs	r2, #13
 8000958:	701a      	strb	r2, [r3, #0]
}
 800095a:	46c0      	nop			; (mov r8, r8)
 800095c:	46bd      	mov	sp, r7
 800095e:	b005      	add	sp, #20
 8000960:	bd90      	pop	{r4, r7, pc}
 8000962:	46c0      	nop			; (mov r8, r8)
 8000964:	20000028 	.word	0x20000028
 8000968:	2000001c 	.word	0x2000001c

0800096c <print_inactivity>:

void print_inactivity( uint8_t *curr_state, uint32_t *int2_clk )
{
 800096c:	b590      	push	{r4, r7, lr}
 800096e:	b083      	sub	sp, #12
 8000970:	af00      	add	r7, sp, #0
 8000972:	6078      	str	r0, [r7, #4]
 8000974:	6039      	str	r1, [r7, #0]
   lcd_print_inactivity( &LCD_Handler, &ACCEL_Handler, ACCEL_Handler.actinactctl, ACCEL_Handler.threshinact * 0.0625F );
 8000976:	4b0f      	ldr	r3, [pc, #60]	; (80009b4 <print_inactivity+0x48>)
 8000978:	7adc      	ldrb	r4, [r3, #11]
 800097a:	4b0e      	ldr	r3, [pc, #56]	; (80009b4 <print_inactivity+0x48>)
 800097c:	7a5b      	ldrb	r3, [r3, #9]
 800097e:	0018      	movs	r0, r3
 8000980:	f002 fea6 	bl	80036d0 <__aeabi_i2f>
 8000984:	1c03      	adds	r3, r0, #0
 8000986:	21f6      	movs	r1, #246	; 0xf6
 8000988:	0589      	lsls	r1, r1, #22
 800098a:	1c18      	adds	r0, r3, #0
 800098c:	f002 fbb0 	bl	80030f0 <__aeabi_fmul>
 8000990:	1c03      	adds	r3, r0, #0
 8000992:	4908      	ldr	r1, [pc, #32]	; (80009b4 <print_inactivity+0x48>)
 8000994:	4808      	ldr	r0, [pc, #32]	; (80009b8 <print_inactivity+0x4c>)
 8000996:	0022      	movs	r2, r4
 8000998:	f002 f848 	bl	8002a2c <lcd_print_inactivity>

   /* Start timer to stop printing the INT2 event on the LCD */
   *int2_clk = Get_SysTick();
 800099c:	f000 ff38 	bl	8001810 <Get_SysTick>
 80009a0:	0002      	movs	r2, r0
 80009a2:	683b      	ldr	r3, [r7, #0]
 80009a4:	601a      	str	r2, [r3, #0]

   *curr_state = CLEAR_INT2_FLAGS;
 80009a6:	687b      	ldr	r3, [r7, #4]
 80009a8:	220d      	movs	r2, #13
 80009aa:	701a      	strb	r2, [r3, #0]
}
 80009ac:	46c0      	nop			; (mov r8, r8)
 80009ae:	46bd      	mov	sp, r7
 80009b0:	b003      	add	sp, #12
 80009b2:	bd90      	pop	{r4, r7, pc}
 80009b4:	20000028 	.word	0x20000028
 80009b8:	2000001c 	.word	0x2000001c

080009bc <print_free_fall>:

void print_free_fall( uint8_t *curr_state, uint32_t *int2_clk )
{
 80009bc:	b580      	push	{r7, lr}
 80009be:	b082      	sub	sp, #8
 80009c0:	af00      	add	r7, sp, #0
 80009c2:	6078      	str	r0, [r7, #4]
 80009c4:	6039      	str	r1, [r7, #0]
   lcd_print_freefall( &LCD_Handler, &ACCEL_Handler, ACCEL_Handler.threshff * 0.0625F );
 80009c6:	4b0f      	ldr	r3, [pc, #60]	; (8000a04 <print_free_fall+0x48>)
 80009c8:	7b1b      	ldrb	r3, [r3, #12]
 80009ca:	0018      	movs	r0, r3
 80009cc:	f002 fe80 	bl	80036d0 <__aeabi_i2f>
 80009d0:	1c03      	adds	r3, r0, #0
 80009d2:	21f6      	movs	r1, #246	; 0xf6
 80009d4:	0589      	lsls	r1, r1, #22
 80009d6:	1c18      	adds	r0, r3, #0
 80009d8:	f002 fb8a 	bl	80030f0 <__aeabi_fmul>
 80009dc:	1c03      	adds	r3, r0, #0
 80009de:	1c1a      	adds	r2, r3, #0
 80009e0:	4908      	ldr	r1, [pc, #32]	; (8000a04 <print_free_fall+0x48>)
 80009e2:	4b09      	ldr	r3, [pc, #36]	; (8000a08 <print_free_fall+0x4c>)
 80009e4:	0018      	movs	r0, r3
 80009e6:	f002 f86f 	bl	8002ac8 <lcd_print_freefall>

   /* Start timer to stop printing the INT2 event on the LCD */
   *int2_clk = Get_SysTick();
 80009ea:	f000 ff11 	bl	8001810 <Get_SysTick>
 80009ee:	0002      	movs	r2, r0
 80009f0:	683b      	ldr	r3, [r7, #0]
 80009f2:	601a      	str	r2, [r3, #0]

   *curr_state = CLEAR_INT2_FLAGS;
 80009f4:	687b      	ldr	r3, [r7, #4]
 80009f6:	220d      	movs	r2, #13
 80009f8:	701a      	strb	r2, [r3, #0]
}
 80009fa:	46c0      	nop			; (mov r8, r8)
 80009fc:	46bd      	mov	sp, r7
 80009fe:	b002      	add	sp, #8
 8000a00:	bd80      	pop	{r7, pc}
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	20000028 	.word	0x20000028
 8000a08:	2000001c 	.word	0x2000001c

08000a0c <print_overrun>:

void print_overrun( uint8_t *curr_state )
{
 8000a0c:	b580      	push	{r7, lr}
 8000a0e:	b082      	sub	sp, #8
 8000a10:	af00      	add	r7, sp, #0
 8000a12:	6078      	str	r0, [r7, #4]
   lcd_print_overrun( &LCD_Handler, &ACCEL_Handler );
 8000a14:	4a06      	ldr	r2, [pc, #24]	; (8000a30 <print_overrun+0x24>)
 8000a16:	4b07      	ldr	r3, [pc, #28]	; (8000a34 <print_overrun+0x28>)
 8000a18:	0011      	movs	r1, r2
 8000a1a:	0018      	movs	r0, r3
 8000a1c:	f002 f8fa 	bl	8002c14 <lcd_print_overrun>

   *curr_state = READ_INT2_PIN;
 8000a20:	687b      	ldr	r3, [r7, #4]
 8000a22:	2212      	movs	r2, #18
 8000a24:	701a      	strb	r2, [r3, #0]
}
 8000a26:	46c0      	nop			; (mov r8, r8)
 8000a28:	46bd      	mov	sp, r7
 8000a2a:	b002      	add	sp, #8
 8000a2c:	bd80      	pop	{r7, pc}
 8000a2e:	46c0      	nop			; (mov r8, r8)
 8000a30:	20000028 	.word	0x20000028
 8000a34:	2000001c 	.word	0x2000001c

08000a38 <print_watermark>:

void print_watermark( uint8_t *curr_state, uint8_t *entries )
{
 8000a38:	b580      	push	{r7, lr}
 8000a3a:	b082      	sub	sp, #8
 8000a3c:	af00      	add	r7, sp, #0
 8000a3e:	6078      	str	r0, [r7, #4]
 8000a40:	6039      	str	r1, [r7, #0]
   lcd_print_watermark( &LCD_Handler, &ACCEL_Handler, ACCEL_Handler.fifoctl & SAMPLES_BITS_MASK, *entries );
 8000a42:	4b09      	ldr	r3, [pc, #36]	; (8000a68 <print_watermark+0x30>)
 8000a44:	7d1b      	ldrb	r3, [r3, #20]
 8000a46:	221f      	movs	r2, #31
 8000a48:	4013      	ands	r3, r2
 8000a4a:	b2da      	uxtb	r2, r3
 8000a4c:	683b      	ldr	r3, [r7, #0]
 8000a4e:	781b      	ldrb	r3, [r3, #0]
 8000a50:	4905      	ldr	r1, [pc, #20]	; (8000a68 <print_watermark+0x30>)
 8000a52:	4806      	ldr	r0, [pc, #24]	; (8000a6c <print_watermark+0x34>)
 8000a54:	f002 f86c 	bl	8002b30 <lcd_print_watermark>

   *curr_state = READ_FIFO_ENTRIES;
 8000a58:	687b      	ldr	r3, [r7, #4]
 8000a5a:	2211      	movs	r2, #17
 8000a5c:	701a      	strb	r2, [r3, #0]
}
 8000a5e:	46c0      	nop			; (mov r8, r8)
 8000a60:	46bd      	mov	sp, r7
 8000a62:	b002      	add	sp, #8
 8000a64:	bd80      	pop	{r7, pc}
 8000a66:	46c0      	nop			; (mov r8, r8)
 8000a68:	20000028 	.word	0x20000028
 8000a6c:	2000001c 	.word	0x2000001c

08000a70 <disable_interrupts>:

void disable_interrupts( uint8_t *curr_state )
{
 8000a70:	b580      	push	{r7, lr}
 8000a72:	b082      	sub	sp, #8
 8000a74:	af00      	add	r7, sp, #0
 8000a76:	6078      	str	r0, [r7, #4]
   /* Disable interrupts on the NUCLEO board
   __disable_irq(); (do not do this as it disables SysTick interrupt leading to an INFINITE LOOP) */

   /* Disable INT1 = DATA_READY (GPIOC0) and INT2 = mapped interrupt (GPIOC1) interrupts on the nucleo board 
      (NVIC interrupt 5 = EXTI0_1 interrupt) */
   NVIC->ICER[ 0 ] = NVIC_ICER_CLRENA_5;
 8000a78:	4a0a      	ldr	r2, [pc, #40]	; (8000aa4 <disable_interrupts+0x34>)
 8000a7a:	2380      	movs	r3, #128	; 0x80
 8000a7c:	2120      	movs	r1, #32
 8000a7e:	50d1      	str	r1, [r2, r3]

   /* Disable interrupts on the ADXL345 */
   ADXL345_API_Disable_Int( &ACCEL_Handler, ALL_INTERRUPTS_ENABLED );
 8000a80:	4b09      	ldr	r3, [pc, #36]	; (8000aa8 <disable_interrupts+0x38>)
 8000a82:	21ff      	movs	r1, #255	; 0xff
 8000a84:	0018      	movs	r0, r3
 8000a86:	f001 fcc4 	bl	8002412 <ADXL345_API_Disable_Int>

   /* Clear screen */
   LCD_Send_Instruction( &LCD_Handler, CLEAR_DISPLAY_REG );
 8000a8a:	4b08      	ldr	r3, [pc, #32]	; (8000aac <disable_interrupts+0x3c>)
 8000a8c:	2101      	movs	r1, #1
 8000a8e:	0018      	movs	r0, r3
 8000a90:	f000 fd0c 	bl	80014ac <LCD_Send_Instruction>

   *curr_state = EVALUATE_INT2;
 8000a94:	687b      	ldr	r3, [r7, #4]
 8000a96:	220e      	movs	r2, #14
 8000a98:	701a      	strb	r2, [r3, #0]
}
 8000a9a:	46c0      	nop			; (mov r8, r8)
 8000a9c:	46bd      	mov	sp, r7
 8000a9e:	b002      	add	sp, #8
 8000aa0:	bd80      	pop	{r7, pc}
 8000aa2:	46c0      	nop			; (mov r8, r8)
 8000aa4:	e000e100 	.word	0xe000e100
 8000aa8:	20000028 	.word	0x20000028
 8000aac:	2000001c 	.word	0x2000001c

08000ab0 <enable_interrupts>:

void enable_interrupts( uint8_t *curr_state, uint8_t *interrupts )
{
 8000ab0:	b580      	push	{r7, lr}
 8000ab2:	b082      	sub	sp, #8
 8000ab4:	af00      	add	r7, sp, #0
 8000ab6:	6078      	str	r0, [r7, #4]
 8000ab8:	6039      	str	r1, [r7, #0]
   /* Re-enable interrupts on the NUCLEO board
   __enable_irq(); */

   /* Re-enable INT1 = DATA READY (GPIOC0) and INT2 = user mapped (GPIOC1) interrupts on the nucleo board */
   NVIC->ISER[ 0 ] |= NVIC_ISER_SETENA_5;
 8000aba:	4b0a      	ldr	r3, [pc, #40]	; (8000ae4 <enable_interrupts+0x34>)
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	4b09      	ldr	r3, [pc, #36]	; (8000ae4 <enable_interrupts+0x34>)
 8000ac0:	2120      	movs	r1, #32
 8000ac2:	430a      	orrs	r2, r1
 8000ac4:	601a      	str	r2, [r3, #0]

   /* Ee-enable intial interrupts on the ADXL345 */
   ADXL345_API_Enable_Int( &ACCEL_Handler, *interrupts, ACCEL_Handler.intmap );
 8000ac6:	683b      	ldr	r3, [r7, #0]
 8000ac8:	7819      	ldrb	r1, [r3, #0]
 8000aca:	4b07      	ldr	r3, [pc, #28]	; (8000ae8 <enable_interrupts+0x38>)
 8000acc:	7c9a      	ldrb	r2, [r3, #18]
 8000ace:	4b06      	ldr	r3, [pc, #24]	; (8000ae8 <enable_interrupts+0x38>)
 8000ad0:	0018      	movs	r0, r3
 8000ad2:	f001 fc71 	bl	80023b8 <ADXL345_API_Enable_Int>

   *curr_state = IDLE;
 8000ad6:	687b      	ldr	r3, [r7, #4]
 8000ad8:	2200      	movs	r2, #0
 8000ada:	701a      	strb	r2, [r3, #0]
}
 8000adc:	46c0      	nop			; (mov r8, r8)
 8000ade:	46bd      	mov	sp, r7
 8000ae0:	b002      	add	sp, #8
 8000ae2:	bd80      	pop	{r7, pc}
 8000ae4:	e000e100 	.word	0xe000e100
 8000ae8:	20000028 	.word	0x20000028

08000aec <clear_int2_flags>:

void clear_int2_flags( uint8_t *curr_state, uint32_t *int2_clk )
{
 8000aec:	b580      	push	{r7, lr}
 8000aee:	b082      	sub	sp, #8
 8000af0:	af00      	add	r7, sp, #0
 8000af2:	6078      	str	r0, [r7, #4]
 8000af4:	6039      	str	r1, [r7, #0]
   /* If 2 seconds have passed since the INT2 event was printed on the LCD */
   if ( ( Get_SysTick() - *int2_clk ) >= 2000U )
 8000af6:	f000 fe8b 	bl	8001810 <Get_SysTick>
 8000afa:	0002      	movs	r2, r0
 8000afc:	683b      	ldr	r3, [r7, #0]
 8000afe:	681b      	ldr	r3, [r3, #0]
 8000b00:	1ad2      	subs	r2, r2, r3
 8000b02:	23fa      	movs	r3, #250	; 0xfa
 8000b04:	00db      	lsls	r3, r3, #3
 8000b06:	429a      	cmp	r2, r3
 8000b08:	d30d      	bcc.n	8000b26 <clear_int2_flags+0x3a>
   {
      /* Clear INT2 flag */
      int2Flag = 0U;
 8000b0a:	4b09      	ldr	r3, [pc, #36]	; (8000b30 <clear_int2_flags+0x44>)
 8000b0c:	2200      	movs	r2, #0
 8000b0e:	701a      	strb	r2, [r3, #0]

      /* Read INT_SOURCE to clear interrupt flags on the ADXL345 (set both INT1 and INT2 to LOW) */
      ( void ) ADXL345_Read( INT_SOURCE_REG );
 8000b10:	2030      	movs	r0, #48	; 0x30
 8000b12:	f001 f8cf 	bl	8001cb4 <ADXL345_Read>

      /* Clear screen */
      LCD_Send_Instruction( &LCD_Handler, CLEAR_DISPLAY_REG );
 8000b16:	4b07      	ldr	r3, [pc, #28]	; (8000b34 <clear_int2_flags+0x48>)
 8000b18:	2101      	movs	r1, #1
 8000b1a:	0018      	movs	r0, r3
 8000b1c:	f000 fcc6 	bl	80014ac <LCD_Send_Instruction>

      *curr_state = ENABLE_INTERRUPTS;
 8000b20:	687b      	ldr	r3, [r7, #4]
 8000b22:	220c      	movs	r2, #12
 8000b24:	701a      	strb	r2, [r3, #0]
   }
}
 8000b26:	46c0      	nop			; (mov r8, r8)
 8000b28:	46bd      	mov	sp, r7
 8000b2a:	b002      	add	sp, #8
 8000b2c:	bd80      	pop	{r7, pc}
 8000b2e:	46c0      	nop			; (mov r8, r8)
 8000b30:	2000003d 	.word	0x2000003d
 8000b34:	2000001c 	.word	0x2000001c

08000b38 <evaluate_int2>:

void evaluate_int2( uint8_t *curr_state, uint8_t *interrupts, uint8_t *int_source )
{
 8000b38:	b580      	push	{r7, lr}
 8000b3a:	b084      	sub	sp, #16
 8000b3c:	af00      	add	r7, sp, #0
 8000b3e:	60f8      	str	r0, [r7, #12]
 8000b40:	60b9      	str	r1, [r7, #8]
 8000b42:	607a      	str	r2, [r7, #4]
      regardless of the INT_ENABLE register settings" as the ADXL345 datasheet states ...
      ... therefore taking into account that only 1 interrupt is allowed to be enabled (apart from
      DATA_READY) in this program, the original value of the member intenable of the structure will be used */

   /* Get interrupt "triggered" based on previous configured value (excluding DATA_READY)*/
   *int_source = *interrupts & ~DATA_READY_INT_ENABLED;
 8000b44:	68bb      	ldr	r3, [r7, #8]
 8000b46:	781b      	ldrb	r3, [r3, #0]
 8000b48:	227f      	movs	r2, #127	; 0x7f
 8000b4a:	4013      	ands	r3, r2
 8000b4c:	b2da      	uxtb	r2, r3
 8000b4e:	687b      	ldr	r3, [r7, #4]
 8000b50:	701a      	strb	r2, [r3, #0]

   /* Act according to the interrupt triggered */
   switch ( *int_source )
 8000b52:	687b      	ldr	r3, [r7, #4]
 8000b54:	781b      	ldrb	r3, [r3, #0]
 8000b56:	2b20      	cmp	r3, #32
 8000b58:	dc08      	bgt.n	8000b6c <evaluate_int2+0x34>
 8000b5a:	2b00      	cmp	r3, #0
 8000b5c:	dd20      	ble.n	8000ba0 <evaluate_int2+0x68>
 8000b5e:	2b20      	cmp	r3, #32
 8000b60:	d81e      	bhi.n	8000ba0 <evaluate_int2+0x68>
 8000b62:	009a      	lsls	r2, r3, #2
 8000b64:	4b12      	ldr	r3, [pc, #72]	; (8000bb0 <evaluate_int2+0x78>)
 8000b66:	18d3      	adds	r3, r2, r3
 8000b68:	681b      	ldr	r3, [r3, #0]
 8000b6a:	469f      	mov	pc, r3
 8000b6c:	2b40      	cmp	r3, #64	; 0x40
 8000b6e:	d117      	bne.n	8000ba0 <evaluate_int2+0x68>
   {
      case SINGLE_TAP_INT_ENABLED:
      case DOUBLE_TAP_INT_ENABLED:
         *curr_state = GET_TAP_AXIS;
 8000b70:	68fb      	ldr	r3, [r7, #12]
 8000b72:	220f      	movs	r2, #15
 8000b74:	701a      	strb	r2, [r3, #0]
         break;
 8000b76:	e017      	b.n	8000ba8 <evaluate_int2+0x70>

      case ACTIVITY_INT_ENABLED:
         *curr_state = GET_ACTIVITY_AXIS;
 8000b78:	68fb      	ldr	r3, [r7, #12]
 8000b7a:	2210      	movs	r2, #16
 8000b7c:	701a      	strb	r2, [r3, #0]
         break;
 8000b7e:	e013      	b.n	8000ba8 <evaluate_int2+0x70>

      case INACTIVITY_INT_ENABLED:
         *curr_state = PRINT_INACTIVITY;
 8000b80:	68fb      	ldr	r3, [r7, #12]
 8000b82:	2207      	movs	r2, #7
 8000b84:	701a      	strb	r2, [r3, #0]
         break;
 8000b86:	e00f      	b.n	8000ba8 <evaluate_int2+0x70>

      case FREE_FALL_INT_ENABLED:
         *curr_state = PRINT_FREE_FALL;
 8000b88:	68fb      	ldr	r3, [r7, #12]
 8000b8a:	2208      	movs	r2, #8
 8000b8c:	701a      	strb	r2, [r3, #0]
         break;
 8000b8e:	e00b      	b.n	8000ba8 <evaluate_int2+0x70>

      case WATERMARK_INT_ENABLED:
         *curr_state =  SET_STANDBY_MODE;
 8000b90:	68fb      	ldr	r3, [r7, #12]
 8000b92:	2213      	movs	r2, #19
 8000b94:	701a      	strb	r2, [r3, #0]
         break;
 8000b96:	e007      	b.n	8000ba8 <evaluate_int2+0x70>

      case OVERRUN_INT_ENABLED:
         *curr_state = PRINT_OVERRUN;
 8000b98:	68fb      	ldr	r3, [r7, #12]
 8000b9a:	220a      	movs	r2, #10
 8000b9c:	701a      	strb	r2, [r3, #0]
         break;
 8000b9e:	e003      	b.n	8000ba8 <evaluate_int2+0x70>

      default:
         *curr_state = CLEAR_INT2_FLAGS;
 8000ba0:	68fb      	ldr	r3, [r7, #12]
 8000ba2:	220d      	movs	r2, #13
 8000ba4:	701a      	strb	r2, [r3, #0]
         break;
 8000ba6:	46c0      	nop			; (mov r8, r8)
   }
}
 8000ba8:	46c0      	nop			; (mov r8, r8)
 8000baa:	46bd      	mov	sp, r7
 8000bac:	b004      	add	sp, #16
 8000bae:	bd80      	pop	{r7, pc}
 8000bb0:	080038a8 	.word	0x080038a8

08000bb4 <get_tap_axis>:

void get_tap_axis( uint8_t *curr_state, uint8_t *tap_axis, uint8_t *int_source )
{
 8000bb4:	b580      	push	{r7, lr}
 8000bb6:	b084      	sub	sp, #16
 8000bb8:	af00      	add	r7, sp, #0
 8000bba:	60f8      	str	r0, [r7, #12]
 8000bbc:	60b9      	str	r1, [r7, #8]
 8000bbe:	607a      	str	r2, [r7, #4]
   /* Read ADXL345 to determine which axis generated the single/double tap */
   *tap_axis = ADXL345_API_Read_Tap_Source( &ACCEL_Handler );
 8000bc0:	4b0b      	ldr	r3, [pc, #44]	; (8000bf0 <get_tap_axis+0x3c>)
 8000bc2:	0018      	movs	r0, r3
 8000bc4:	f001 fc43 	bl	800244e <ADXL345_API_Read_Tap_Source>
 8000bc8:	0003      	movs	r3, r0
 8000bca:	001a      	movs	r2, r3
 8000bcc:	68bb      	ldr	r3, [r7, #8]
 8000bce:	701a      	strb	r2, [r3, #0]

   /* If single tap triggered the interrupt */
   if ( *int_source == SINGLE_TAP_INT_ENABLED )
 8000bd0:	687b      	ldr	r3, [r7, #4]
 8000bd2:	781b      	ldrb	r3, [r3, #0]
 8000bd4:	2b40      	cmp	r3, #64	; 0x40
 8000bd6:	d103      	bne.n	8000be0 <get_tap_axis+0x2c>
   {
      *curr_state = PRINT_SINGLE_TAP;
 8000bd8:	68fb      	ldr	r3, [r7, #12]
 8000bda:	2204      	movs	r2, #4
 8000bdc:	701a      	strb	r2, [r3, #0]
   /* If double tap triggered the interrupt */
   else
   {
      *curr_state = PRINT_DOUBLE_TAP;
   }
}
 8000bde:	e002      	b.n	8000be6 <get_tap_axis+0x32>
      *curr_state = PRINT_DOUBLE_TAP;
 8000be0:	68fb      	ldr	r3, [r7, #12]
 8000be2:	2205      	movs	r2, #5
 8000be4:	701a      	strb	r2, [r3, #0]
}
 8000be6:	46c0      	nop			; (mov r8, r8)
 8000be8:	46bd      	mov	sp, r7
 8000bea:	b004      	add	sp, #16
 8000bec:	bd80      	pop	{r7, pc}
 8000bee:	46c0      	nop			; (mov r8, r8)
 8000bf0:	20000028 	.word	0x20000028

08000bf4 <get_activity_axis>:

void get_activity_axis( uint8_t *curr_state, uint8_t *activity_axis )
{
 8000bf4:	b580      	push	{r7, lr}
 8000bf6:	b082      	sub	sp, #8
 8000bf8:	af00      	add	r7, sp, #0
 8000bfa:	6078      	str	r0, [r7, #4]
 8000bfc:	6039      	str	r1, [r7, #0]
   /* Read ADXL345 to determine which axis detected activity */
   *activity_axis = ADXL345_API_Read_Activity_Source( &ACCEL_Handler );
 8000bfe:	4b07      	ldr	r3, [pc, #28]	; (8000c1c <get_activity_axis+0x28>)
 8000c00:	0018      	movs	r0, r3
 8000c02:	f001 fc3c 	bl	800247e <ADXL345_API_Read_Activity_Source>
 8000c06:	0003      	movs	r3, r0
 8000c08:	001a      	movs	r2, r3
 8000c0a:	683b      	ldr	r3, [r7, #0]
 8000c0c:	701a      	strb	r2, [r3, #0]

   *curr_state = PRINT_ACTIVITY;
 8000c0e:	687b      	ldr	r3, [r7, #4]
 8000c10:	2206      	movs	r2, #6
 8000c12:	701a      	strb	r2, [r3, #0]
}
 8000c14:	46c0      	nop			; (mov r8, r8)
 8000c16:	46bd      	mov	sp, r7
 8000c18:	b002      	add	sp, #8
 8000c1a:	bd80      	pop	{r7, pc}
 8000c1c:	20000028 	.word	0x20000028

08000c20 <read_fifo_entries>:

void read_fifo_entries( uint8_t *curr_state, uint8_t *entries )
{
 8000c20:	b580      	push	{r7, lr}
 8000c22:	b082      	sub	sp, #8
 8000c24:	af00      	add	r7, sp, #0
 8000c26:	6078      	str	r0, [r7, #4]
 8000c28:	6039      	str	r1, [r7, #0]
   /* Read number of samples stored in FIFO */
   *entries = ADXL345_API_Read_FIFO_Entries( &ACCEL_Handler );
 8000c2a:	4b0e      	ldr	r3, [pc, #56]	; (8000c64 <read_fifo_entries+0x44>)
 8000c2c:	0018      	movs	r0, r3
 8000c2e:	f001 fc3e 	bl	80024ae <ADXL345_API_Read_FIFO_Entries>
 8000c32:	0003      	movs	r3, r0
 8000c34:	001a      	movs	r2, r3
 8000c36:	683b      	ldr	r3, [r7, #0]
 8000c38:	701a      	strb	r2, [r3, #0]

   /* If number of entries in FIFO is equal or greater than the number of samples configured
      in FIFO_CTL for the WATERMARK interrupt to be triggered */
   if ( *entries >= ( ACCEL_Handler.fifoctl & SAMPLES_BITS_MASK ) )
 8000c3a:	683b      	ldr	r3, [r7, #0]
 8000c3c:	781b      	ldrb	r3, [r3, #0]
 8000c3e:	001a      	movs	r2, r3
 8000c40:	4b08      	ldr	r3, [pc, #32]	; (8000c64 <read_fifo_entries+0x44>)
 8000c42:	7d1b      	ldrb	r3, [r3, #20]
 8000c44:	0019      	movs	r1, r3
 8000c46:	231f      	movs	r3, #31
 8000c48:	400b      	ands	r3, r1
 8000c4a:	429a      	cmp	r2, r3
 8000c4c:	d303      	bcc.n	8000c56 <read_fifo_entries+0x36>
   {
      *curr_state = PRINT_WATERMARK;
 8000c4e:	687b      	ldr	r3, [r7, #4]
 8000c50:	2209      	movs	r2, #9
 8000c52:	701a      	strb	r2, [r3, #0]
   /* If number of entries in FIFO is less than samples in FIFO_CTL */
   else
   {
      *curr_state = SET_MEASUREMENT_MODE;
   }
}
 8000c54:	e002      	b.n	8000c5c <read_fifo_entries+0x3c>
      *curr_state = SET_MEASUREMENT_MODE;
 8000c56:	687b      	ldr	r3, [r7, #4]
 8000c58:	2214      	movs	r2, #20
 8000c5a:	701a      	strb	r2, [r3, #0]
}
 8000c5c:	46c0      	nop			; (mov r8, r8)
 8000c5e:	46bd      	mov	sp, r7
 8000c60:	b002      	add	sp, #8
 8000c62:	bd80      	pop	{r7, pc}
 8000c64:	20000028 	.word	0x20000028

08000c68 <read_int2_pin>:

void read_int2_pin( uint8_t *curr_state )
{
 8000c68:	b580      	push	{r7, lr}
 8000c6a:	b082      	sub	sp, #8
 8000c6c:	af00      	add	r7, sp, #0
 8000c6e:	6078      	str	r0, [r7, #4]
   /* If ADXL345 INT2 pin (GPIOC1) is HIGH (= OVERRUN is still present, unread data has been replaced) */
   if ( ( GPIOC->IDR & GPIO_IDR_1 ) == GPIO_IDR_1 )
 8000c70:	4b08      	ldr	r3, [pc, #32]	; (8000c94 <read_int2_pin+0x2c>)
 8000c72:	691b      	ldr	r3, [r3, #16]
 8000c74:	2202      	movs	r2, #2
 8000c76:	4013      	ands	r3, r2
 8000c78:	2b02      	cmp	r3, #2
 8000c7a:	d103      	bne.n	8000c84 <read_int2_pin+0x1c>
   {
      *curr_state = PRINT_OVERRUN;
 8000c7c:	687b      	ldr	r3, [r7, #4]
 8000c7e:	220a      	movs	r2, #10
 8000c80:	701a      	strb	r2, [r3, #0]
   /* If ADXL345 INT2 pin (GPIOC1) is LOW (data has already been read from FIFO) */
   else 
   {
      *curr_state = CLEAR_INT2_FLAGS;
   }
}
 8000c82:	e002      	b.n	8000c8a <read_int2_pin+0x22>
      *curr_state = CLEAR_INT2_FLAGS;
 8000c84:	687b      	ldr	r3, [r7, #4]
 8000c86:	220d      	movs	r2, #13
 8000c88:	701a      	strb	r2, [r3, #0]
}
 8000c8a:	46c0      	nop			; (mov r8, r8)
 8000c8c:	46bd      	mov	sp, r7
 8000c8e:	b002      	add	sp, #8
 8000c90:	bd80      	pop	{r7, pc}
 8000c92:	46c0      	nop			; (mov r8, r8)
 8000c94:	48000800 	.word	0x48000800

08000c98 <set_standby_mode>:

void set_standby_mode( uint8_t *curr_state )
{
 8000c98:	b580      	push	{r7, lr}
 8000c9a:	b082      	sub	sp, #8
 8000c9c:	af00      	add	r7, sp, #0
 8000c9e:	6078      	str	r0, [r7, #4]
   /* Set ADXL345 to standby mode */
   ADXL345_API_Standby_Mode( &ACCEL_Handler );
 8000ca0:	4b05      	ldr	r3, [pc, #20]	; (8000cb8 <set_standby_mode+0x20>)
 8000ca2:	0018      	movs	r0, r3
 8000ca4:	f001 f8d9 	bl	8001e5a <ADXL345_API_Standby_Mode>

   *curr_state = READ_FIFO_ENTRIES;
 8000ca8:	687b      	ldr	r3, [r7, #4]
 8000caa:	2211      	movs	r2, #17
 8000cac:	701a      	strb	r2, [r3, #0]
}
 8000cae:	46c0      	nop			; (mov r8, r8)
 8000cb0:	46bd      	mov	sp, r7
 8000cb2:	b002      	add	sp, #8
 8000cb4:	bd80      	pop	{r7, pc}
 8000cb6:	46c0      	nop			; (mov r8, r8)
 8000cb8:	20000028 	.word	0x20000028

08000cbc <set_measurement_mode>:

void set_measurement_mode( uint8_t *curr_state )
{
 8000cbc:	b580      	push	{r7, lr}
 8000cbe:	b082      	sub	sp, #8
 8000cc0:	af00      	add	r7, sp, #0
 8000cc2:	6078      	str	r0, [r7, #4]
   /* Set ADXL345 to measurement mode */
   ADXL345_API_Measurement_Mode( &ACCEL_Handler );
 8000cc4:	4b05      	ldr	r3, [pc, #20]	; (8000cdc <set_measurement_mode+0x20>)
 8000cc6:	0018      	movs	r0, r3
 8000cc8:	f001 f8dc 	bl	8001e84 <ADXL345_API_Measurement_Mode>

   *curr_state = CLEAR_INT2_FLAGS;
 8000ccc:	687b      	ldr	r3, [r7, #4]
 8000cce:	220d      	movs	r2, #13
 8000cd0:	701a      	strb	r2, [r3, #0]
}
 8000cd2:	46c0      	nop			; (mov r8, r8)
 8000cd4:	46bd      	mov	sp, r7
 8000cd6:	b002      	add	sp, #8
 8000cd8:	bd80      	pop	{r7, pc}
 8000cda:	46c0      	nop			; (mov r8, r8)
 8000cdc:	20000028 	.word	0x20000028

08000ce0 <GPIO_Interrupt_Init>:
#include "gpio.h"

void GPIO_Interrupt_Init( void )
{   
 8000ce0:	b580      	push	{r7, lr}
 8000ce2:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ce4:	b672      	cpsid	i
}
 8000ce6:	46c0      	nop			; (mov r8, r8)
    /* Disable global interrupts */
    __disable_irq();

    /* Initialize and configure GPIOC peripheral */
    GPIOC_Init();
 8000ce8:	f000 f806 	bl	8000cf8 <GPIOC_Init>
  __ASM volatile ("cpsie i" : : : "memory");
 8000cec:	b662      	cpsie	i
}
 8000cee:	46c0      	nop			; (mov r8, r8)

    /* Enable global interrupts */
    __enable_irq();
}
 8000cf0:	46c0      	nop			; (mov r8, r8)
 8000cf2:	46bd      	mov	sp, r7
 8000cf4:	bd80      	pop	{r7, pc}
	...

08000cf8 <GPIOC_Init>:

void GPIOC_Init( void )
{
 8000cf8:	b580      	push	{r7, lr}
 8000cfa:	af00      	add	r7, sp, #0
    /* Enable GPIOC clock access */
    GPIOC_CLK_ENBL();
 8000cfc:	4b2a      	ldr	r3, [pc, #168]	; (8000da8 <GPIOC_Init+0xb0>)
 8000cfe:	695a      	ldr	r2, [r3, #20]
 8000d00:	4b29      	ldr	r3, [pc, #164]	; (8000da8 <GPIOC_Init+0xb0>)
 8000d02:	2180      	movs	r1, #128	; 0x80
 8000d04:	0309      	lsls	r1, r1, #12
 8000d06:	430a      	orrs	r2, r1
 8000d08:	615a      	str	r2, [r3, #20]

    /* GPIOC0 (INT1 of ADXL345) as input */
    GPIOC->MODER &= ~GPIO_MODER_MODER0_1;
 8000d0a:	4b28      	ldr	r3, [pc, #160]	; (8000dac <GPIOC_Init+0xb4>)
 8000d0c:	681a      	ldr	r2, [r3, #0]
 8000d0e:	4b27      	ldr	r3, [pc, #156]	; (8000dac <GPIOC_Init+0xb4>)
 8000d10:	2102      	movs	r1, #2
 8000d12:	438a      	bics	r2, r1
 8000d14:	601a      	str	r2, [r3, #0]
    GPIOC->MODER &= ~GPIO_MODER_MODER0_0;
 8000d16:	4b25      	ldr	r3, [pc, #148]	; (8000dac <GPIOC_Init+0xb4>)
 8000d18:	681a      	ldr	r2, [r3, #0]
 8000d1a:	4b24      	ldr	r3, [pc, #144]	; (8000dac <GPIOC_Init+0xb4>)
 8000d1c:	2101      	movs	r1, #1
 8000d1e:	438a      	bics	r2, r1
 8000d20:	601a      	str	r2, [r3, #0]

    /* GPIOC0 (INT1) with pull-down resistor */
    GPIOC->PUPDR |=  GPIO_PUPDR_PUPDR0_1;
 8000d22:	4b22      	ldr	r3, [pc, #136]	; (8000dac <GPIOC_Init+0xb4>)
 8000d24:	68da      	ldr	r2, [r3, #12]
 8000d26:	4b21      	ldr	r3, [pc, #132]	; (8000dac <GPIOC_Init+0xb4>)
 8000d28:	2102      	movs	r1, #2
 8000d2a:	430a      	orrs	r2, r1
 8000d2c:	60da      	str	r2, [r3, #12]
    GPIOC->PUPDR &= ~GPIO_PUPDR_PUPDR0_0;
 8000d2e:	4b1f      	ldr	r3, [pc, #124]	; (8000dac <GPIOC_Init+0xb4>)
 8000d30:	68da      	ldr	r2, [r3, #12]
 8000d32:	4b1e      	ldr	r3, [pc, #120]	; (8000dac <GPIOC_Init+0xb4>)
 8000d34:	2101      	movs	r1, #1
 8000d36:	438a      	bics	r2, r1
 8000d38:	60da      	str	r2, [r3, #12]

    /* GPIOC1 (INT2 of ADXL345) as input */
    GPIOC->MODER &= ~GPIO_MODER_MODER1_1;
 8000d3a:	4b1c      	ldr	r3, [pc, #112]	; (8000dac <GPIOC_Init+0xb4>)
 8000d3c:	681a      	ldr	r2, [r3, #0]
 8000d3e:	4b1b      	ldr	r3, [pc, #108]	; (8000dac <GPIOC_Init+0xb4>)
 8000d40:	2108      	movs	r1, #8
 8000d42:	438a      	bics	r2, r1
 8000d44:	601a      	str	r2, [r3, #0]
    GPIOC->MODER &= ~GPIO_MODER_MODER1_0;
 8000d46:	4b19      	ldr	r3, [pc, #100]	; (8000dac <GPIOC_Init+0xb4>)
 8000d48:	681a      	ldr	r2, [r3, #0]
 8000d4a:	4b18      	ldr	r3, [pc, #96]	; (8000dac <GPIOC_Init+0xb4>)
 8000d4c:	2104      	movs	r1, #4
 8000d4e:	438a      	bics	r2, r1
 8000d50:	601a      	str	r2, [r3, #0]

    /* GPIOC1 (INT2) with pull-down resistor */
    GPIOC->PUPDR |=  GPIO_PUPDR_PUPDR1_1;
 8000d52:	4b16      	ldr	r3, [pc, #88]	; (8000dac <GPIOC_Init+0xb4>)
 8000d54:	68da      	ldr	r2, [r3, #12]
 8000d56:	4b15      	ldr	r3, [pc, #84]	; (8000dac <GPIOC_Init+0xb4>)
 8000d58:	2108      	movs	r1, #8
 8000d5a:	430a      	orrs	r2, r1
 8000d5c:	60da      	str	r2, [r3, #12]
    GPIOC->PUPDR &= ~GPIO_PUPDR_PUPDR1_0;
 8000d5e:	4b13      	ldr	r3, [pc, #76]	; (8000dac <GPIOC_Init+0xb4>)
 8000d60:	68da      	ldr	r2, [r3, #12]
 8000d62:	4b12      	ldr	r3, [pc, #72]	; (8000dac <GPIOC_Init+0xb4>)
 8000d64:	2104      	movs	r1, #4
 8000d66:	438a      	bics	r2, r1
 8000d68:	60da      	str	r2, [r3, #12]

    /* Configure GPIOC0 (INT1) and GPIOC1 (INT2) as
       interrupts on the rising edge */
    GPIOC_EXTI0_1_Init();
 8000d6a:	f000 f825 	bl	8000db8 <GPIOC_EXTI0_1_Init>

    /* GPIOC13 (board button) as input */
    GPIOC->MODER &= ~GPIO_MODER_MODER13_1;
 8000d6e:	4b0f      	ldr	r3, [pc, #60]	; (8000dac <GPIOC_Init+0xb4>)
 8000d70:	681a      	ldr	r2, [r3, #0]
 8000d72:	4b0e      	ldr	r3, [pc, #56]	; (8000dac <GPIOC_Init+0xb4>)
 8000d74:	490e      	ldr	r1, [pc, #56]	; (8000db0 <GPIOC_Init+0xb8>)
 8000d76:	400a      	ands	r2, r1
 8000d78:	601a      	str	r2, [r3, #0]
    GPIOC->MODER &= ~GPIO_MODER_MODER13_0;
 8000d7a:	4b0c      	ldr	r3, [pc, #48]	; (8000dac <GPIOC_Init+0xb4>)
 8000d7c:	681a      	ldr	r2, [r3, #0]
 8000d7e:	4b0b      	ldr	r3, [pc, #44]	; (8000dac <GPIOC_Init+0xb4>)
 8000d80:	490c      	ldr	r1, [pc, #48]	; (8000db4 <GPIOC_Init+0xbc>)
 8000d82:	400a      	ands	r2, r1
 8000d84:	601a      	str	r2, [r3, #0]

    /* GPIOC13 without pull-up/pull-down (it already uses a pull-up resistor) */
    GPIOC->PUPDR &= ~GPIO_PUPDR_PUPDR13_1;
 8000d86:	4b09      	ldr	r3, [pc, #36]	; (8000dac <GPIOC_Init+0xb4>)
 8000d88:	68da      	ldr	r2, [r3, #12]
 8000d8a:	4b08      	ldr	r3, [pc, #32]	; (8000dac <GPIOC_Init+0xb4>)
 8000d8c:	4908      	ldr	r1, [pc, #32]	; (8000db0 <GPIOC_Init+0xb8>)
 8000d8e:	400a      	ands	r2, r1
 8000d90:	60da      	str	r2, [r3, #12]
    GPIOC->PUPDR &= ~GPIO_PUPDR_PUPDR13_0;
 8000d92:	4b06      	ldr	r3, [pc, #24]	; (8000dac <GPIOC_Init+0xb4>)
 8000d94:	68da      	ldr	r2, [r3, #12]
 8000d96:	4b05      	ldr	r3, [pc, #20]	; (8000dac <GPIOC_Init+0xb4>)
 8000d98:	4906      	ldr	r1, [pc, #24]	; (8000db4 <GPIOC_Init+0xbc>)
 8000d9a:	400a      	ands	r2, r1
 8000d9c:	60da      	str	r2, [r3, #12]

    /* Configure GPIOC13 (Board button) as interrupt on the falling edge  */
    GPIOC_EXTI13_Init();
 8000d9e:	f000 f86d 	bl	8000e7c <GPIOC_EXTI13_Init>
}
 8000da2:	46c0      	nop			; (mov r8, r8)
 8000da4:	46bd      	mov	sp, r7
 8000da6:	bd80      	pop	{r7, pc}
 8000da8:	40021000 	.word	0x40021000
 8000dac:	48000800 	.word	0x48000800
 8000db0:	f7ffffff 	.word	0xf7ffffff
 8000db4:	fbffffff 	.word	0xfbffffff

08000db8 <GPIOC_EXTI0_1_Init>:

void GPIOC_EXTI0_1_Init( void )
{
 8000db8:	b580      	push	{r7, lr}
 8000dba:	af00      	add	r7, sp, #0
    /* Enable SYSCFG clock access */
    SYSCFG_CLK_ENBL();
 8000dbc:	4b29      	ldr	r3, [pc, #164]	; (8000e64 <GPIOC_EXTI0_1_Init+0xac>)
 8000dbe:	699a      	ldr	r2, [r3, #24]
 8000dc0:	4b28      	ldr	r3, [pc, #160]	; (8000e64 <GPIOC_EXTI0_1_Init+0xac>)
 8000dc2:	2101      	movs	r1, #1
 8000dc4:	430a      	orrs	r2, r1
 8000dc6:	619a      	str	r2, [r3, #24]
    
    /* Map GPIOC0 (INT1 of ADXL345) to EXTI0 line for interrupt */
    SYSCFG->EXTICR[ 0 ] |= SYSCFG_EXTICR1_EXTI0_PC;
 8000dc8:	4b27      	ldr	r3, [pc, #156]	; (8000e68 <GPIOC_EXTI0_1_Init+0xb0>)
 8000dca:	689a      	ldr	r2, [r3, #8]
 8000dcc:	4b26      	ldr	r3, [pc, #152]	; (8000e68 <GPIOC_EXTI0_1_Init+0xb0>)
 8000dce:	2102      	movs	r1, #2
 8000dd0:	430a      	orrs	r2, r1
 8000dd2:	609a      	str	r2, [r3, #8]

    /* Unmask/enable interrupt on EXTI line 0 (GPIOC0) */
    EXTI->IMR |= EXTI_IMR_IM0;
 8000dd4:	4b25      	ldr	r3, [pc, #148]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000dd6:	681a      	ldr	r2, [r3, #0]
 8000dd8:	4b24      	ldr	r3, [pc, #144]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000dda:	2101      	movs	r1, #1
 8000ddc:	430a      	orrs	r2, r1
 8000dde:	601a      	str	r2, [r3, #0]

    /* EXTI0 (GPIOC0) interrupt triggered on the rising edge */
    EXTI->RTSR |= EXTI_RTSR_RT0;
 8000de0:	4b22      	ldr	r3, [pc, #136]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000de2:	689a      	ldr	r2, [r3, #8]
 8000de4:	4b21      	ldr	r3, [pc, #132]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000de6:	2101      	movs	r1, #1
 8000de8:	430a      	orrs	r2, r1
 8000dea:	609a      	str	r2, [r3, #8]

    /* EXTI0 (GPIOC0) interrupt falling trigger disabled */
    EXTI->FTSR &= ~EXTI_FTSR_FT0;
 8000dec:	4b1f      	ldr	r3, [pc, #124]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000dee:	68da      	ldr	r2, [r3, #12]
 8000df0:	4b1e      	ldr	r3, [pc, #120]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000df2:	2101      	movs	r1, #1
 8000df4:	438a      	bics	r2, r1
 8000df6:	60da      	str	r2, [r3, #12]

    /* Map GPIOC1 (INT2 of ADXL345) to EXTI1 line for interrupt */
    SYSCFG->EXTICR[ 0 ] |= SYSCFG_EXTICR1_EXTI1_PC;
 8000df8:	4b1b      	ldr	r3, [pc, #108]	; (8000e68 <GPIOC_EXTI0_1_Init+0xb0>)
 8000dfa:	689a      	ldr	r2, [r3, #8]
 8000dfc:	4b1a      	ldr	r3, [pc, #104]	; (8000e68 <GPIOC_EXTI0_1_Init+0xb0>)
 8000dfe:	2120      	movs	r1, #32
 8000e00:	430a      	orrs	r2, r1
 8000e02:	609a      	str	r2, [r3, #8]

    /* Unmask/enable interrupt on line 1 (GPIOC1) */
    EXTI->IMR |= EXTI_IMR_IM1;
 8000e04:	4b19      	ldr	r3, [pc, #100]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e06:	681a      	ldr	r2, [r3, #0]
 8000e08:	4b18      	ldr	r3, [pc, #96]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e0a:	2102      	movs	r1, #2
 8000e0c:	430a      	orrs	r2, r1
 8000e0e:	601a      	str	r2, [r3, #0]

    /* EXTI1 (GPIOC1) interrupt triggered on the rising edge */
    EXTI->RTSR |= EXTI_RTSR_RT1;
 8000e10:	4b16      	ldr	r3, [pc, #88]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e12:	689a      	ldr	r2, [r3, #8]
 8000e14:	4b15      	ldr	r3, [pc, #84]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e16:	2102      	movs	r1, #2
 8000e18:	430a      	orrs	r2, r1
 8000e1a:	609a      	str	r2, [r3, #8]

    /* EXTI1 (GPIOC1) interrupt falling trigger disabled */
    EXTI->FTSR &= ~EXTI_FTSR_FT1;
 8000e1c:	4b13      	ldr	r3, [pc, #76]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e1e:	68da      	ldr	r2, [r3, #12]
 8000e20:	4b12      	ldr	r3, [pc, #72]	; (8000e6c <GPIOC_EXTI0_1_Init+0xb4>)
 8000e22:	2102      	movs	r1, #2
 8000e24:	438a      	bics	r2, r1
 8000e26:	60da      	str	r2, [r3, #12]

    /* Enable interrupt 5 (EXTI0_1) of the NVIC */
    NVIC->ISER[ 0 ] |= NVIC_ISER_SETENA_5;
 8000e28:	4b11      	ldr	r3, [pc, #68]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e2a:	681a      	ldr	r2, [r3, #0]
 8000e2c:	4b10      	ldr	r3, [pc, #64]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e2e:	2120      	movs	r1, #32
 8000e30:	430a      	orrs	r2, r1
 8000e32:	601a      	str	r2, [r3, #0]

    /* Set interrupt EXTI0_1 (N=5) priority to zero (highest priority).
       IPRx. With x = N / 4 = 5 / 4, then x = 1. Therefore IPRx = IPR1.
       Byte offset = N MOD 4 = 5 MOD 4, therefore Byte offset = 1.
       NOTE: processor implements only bits 7 and 6 of each field. */
    NVIC->IP[ 1 ] &= ~NVIC_IPR1_PRI5_7;
 8000e34:	4a0e      	ldr	r2, [pc, #56]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e36:	23c1      	movs	r3, #193	; 0xc1
 8000e38:	009b      	lsls	r3, r3, #2
 8000e3a:	58d3      	ldr	r3, [r2, r3]
 8000e3c:	490c      	ldr	r1, [pc, #48]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e3e:	4a0d      	ldr	r2, [pc, #52]	; (8000e74 <GPIOC_EXTI0_1_Init+0xbc>)
 8000e40:	401a      	ands	r2, r3
 8000e42:	23c1      	movs	r3, #193	; 0xc1
 8000e44:	009b      	lsls	r3, r3, #2
 8000e46:	50ca      	str	r2, [r1, r3]
    NVIC->IP[ 1 ] &= ~NVIC_IPR1_PRI5_6;
 8000e48:	4a09      	ldr	r2, [pc, #36]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e4a:	23c1      	movs	r3, #193	; 0xc1
 8000e4c:	009b      	lsls	r3, r3, #2
 8000e4e:	58d3      	ldr	r3, [r2, r3]
 8000e50:	4907      	ldr	r1, [pc, #28]	; (8000e70 <GPIOC_EXTI0_1_Init+0xb8>)
 8000e52:	4a09      	ldr	r2, [pc, #36]	; (8000e78 <GPIOC_EXTI0_1_Init+0xc0>)
 8000e54:	401a      	ands	r2, r3
 8000e56:	23c1      	movs	r3, #193	; 0xc1
 8000e58:	009b      	lsls	r3, r3, #2
 8000e5a:	50ca      	str	r2, [r1, r3]
}
 8000e5c:	46c0      	nop			; (mov r8, r8)
 8000e5e:	46bd      	mov	sp, r7
 8000e60:	bd80      	pop	{r7, pc}
 8000e62:	46c0      	nop			; (mov r8, r8)
 8000e64:	40021000 	.word	0x40021000
 8000e68:	40010000 	.word	0x40010000
 8000e6c:	40010400 	.word	0x40010400
 8000e70:	e000e100 	.word	0xe000e100
 8000e74:	ffff7fff 	.word	0xffff7fff
 8000e78:	ffffbfff 	.word	0xffffbfff

08000e7c <GPIOC_EXTI13_Init>:

void GPIOC_EXTI13_Init( void )
{
 8000e7c:	b580      	push	{r7, lr}
 8000e7e:	af00      	add	r7, sp, #0
    /* Enable SYSCFG clock access */
    SYSCFG_CLK_ENBL();
 8000e80:	4b1e      	ldr	r3, [pc, #120]	; (8000efc <GPIOC_EXTI13_Init+0x80>)
 8000e82:	699a      	ldr	r2, [r3, #24]
 8000e84:	4b1d      	ldr	r3, [pc, #116]	; (8000efc <GPIOC_EXTI13_Init+0x80>)
 8000e86:	2101      	movs	r1, #1
 8000e88:	430a      	orrs	r2, r1
 8000e8a:	619a      	str	r2, [r3, #24]

    /* Map GPIOC13 (board button) to the EXTI13 line */
    SYSCFG->EXTICR[ 3 ] |= SYSCFG_EXTICR4_EXTI13_PC;
 8000e8c:	4b1c      	ldr	r3, [pc, #112]	; (8000f00 <GPIOC_EXTI13_Init+0x84>)
 8000e8e:	695a      	ldr	r2, [r3, #20]
 8000e90:	4b1b      	ldr	r3, [pc, #108]	; (8000f00 <GPIOC_EXTI13_Init+0x84>)
 8000e92:	2120      	movs	r1, #32
 8000e94:	430a      	orrs	r2, r1
 8000e96:	615a      	str	r2, [r3, #20]

    /* Unmask/enable interrupt on EXTI line 13 (GPIOC13) */
    EXTI->IMR |= EXTI_IMR_IM13;
 8000e98:	4b1a      	ldr	r3, [pc, #104]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000e9a:	681a      	ldr	r2, [r3, #0]
 8000e9c:	4b19      	ldr	r3, [pc, #100]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000e9e:	2180      	movs	r1, #128	; 0x80
 8000ea0:	0189      	lsls	r1, r1, #6
 8000ea2:	430a      	orrs	r2, r1
 8000ea4:	601a      	str	r2, [r3, #0]

    /* EXTI13 (GPIOC13) interrupt triggered on the falling edge
       NOTE: board button uses a pull-up resistor, its state when pressed is LOW */
    EXTI->FTSR |= EXTI_FTSR_FT13;
 8000ea6:	4b17      	ldr	r3, [pc, #92]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000ea8:	68da      	ldr	r2, [r3, #12]
 8000eaa:	4b16      	ldr	r3, [pc, #88]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000eac:	2180      	movs	r1, #128	; 0x80
 8000eae:	0189      	lsls	r1, r1, #6
 8000eb0:	430a      	orrs	r2, r1
 8000eb2:	60da      	str	r2, [r3, #12]

    /* EXTI13 (GPIOC13) interrupt rising trigger disabled */
    EXTI->RTSR &= ~EXTI_RTSR_RT13;
 8000eb4:	4b13      	ldr	r3, [pc, #76]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000eb6:	689a      	ldr	r2, [r3, #8]
 8000eb8:	4b12      	ldr	r3, [pc, #72]	; (8000f04 <GPIOC_EXTI13_Init+0x88>)
 8000eba:	4913      	ldr	r1, [pc, #76]	; (8000f08 <GPIOC_EXTI13_Init+0x8c>)
 8000ebc:	400a      	ands	r2, r1
 8000ebe:	609a      	str	r2, [r3, #8]

    /* Enable interrupt 7 (EXTI4_15) of the NVIC */
    NVIC->ISER[ 0 ] |= NVIC_ISER_SETENA_7;
 8000ec0:	4b12      	ldr	r3, [pc, #72]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000ec2:	681a      	ldr	r2, [r3, #0]
 8000ec4:	4b11      	ldr	r3, [pc, #68]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000ec6:	2180      	movs	r1, #128	; 0x80
 8000ec8:	430a      	orrs	r2, r1
 8000eca:	601a      	str	r2, [r3, #0]

    /* Set interrupt EXTI4_15 (N=7) priority to 64 (second highest).
       IPRx. With x = N / 4 = 7 / 4, then x = 1. Therefore IPRx = IPR1.
       Byte offset = N MOD 4 = 7 MOD 4, therefore Byte offset = 3.
       NOTE: processor implements only bits 7 and 6 of each field. */
    NVIC->IP[ 1 ] &= ~NVIC_IPR1_PRI7_7;
 8000ecc:	4a0f      	ldr	r2, [pc, #60]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000ece:	23c1      	movs	r3, #193	; 0xc1
 8000ed0:	009b      	lsls	r3, r3, #2
 8000ed2:	58d3      	ldr	r3, [r2, r3]
 8000ed4:	490d      	ldr	r1, [pc, #52]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000ed6:	005b      	lsls	r3, r3, #1
 8000ed8:	085a      	lsrs	r2, r3, #1
 8000eda:	23c1      	movs	r3, #193	; 0xc1
 8000edc:	009b      	lsls	r3, r3, #2
 8000ede:	50ca      	str	r2, [r1, r3]
    NVIC->IP[ 1 ] |=  NVIC_IPR1_PRI7_6;
 8000ee0:	4a0a      	ldr	r2, [pc, #40]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000ee2:	23c1      	movs	r3, #193	; 0xc1
 8000ee4:	009b      	lsls	r3, r3, #2
 8000ee6:	58d3      	ldr	r3, [r2, r3]
 8000ee8:	4908      	ldr	r1, [pc, #32]	; (8000f0c <GPIOC_EXTI13_Init+0x90>)
 8000eea:	2280      	movs	r2, #128	; 0x80
 8000eec:	05d2      	lsls	r2, r2, #23
 8000eee:	431a      	orrs	r2, r3
 8000ef0:	23c1      	movs	r3, #193	; 0xc1
 8000ef2:	009b      	lsls	r3, r3, #2
 8000ef4:	50ca      	str	r2, [r1, r3]
}
 8000ef6:	46c0      	nop			; (mov r8, r8)
 8000ef8:	46bd      	mov	sp, r7
 8000efa:	bd80      	pop	{r7, pc}
 8000efc:	40021000 	.word	0x40021000
 8000f00:	40010000 	.word	0x40010000
 8000f04:	40010400 	.word	0x40010400
 8000f08:	ffffdfff 	.word	0xffffdfff
 8000f0c:	e000e100 	.word	0xe000e100

08000f10 <SysTick_Handler>:

/* Global variables from systick.c */
extern uint32_t tick;

void SysTick_Handler( void )
{
 8000f10:	b580      	push	{r7, lr}
 8000f12:	af00      	add	r7, sp, #0
   /* Execute SysTick callback */
   SysTick_Callback();
 8000f14:	f000 f842 	bl	8000f9c <SysTick_Callback>
}
 8000f18:	46c0      	nop			; (mov r8, r8)
 8000f1a:	46bd      	mov	sp, r7
 8000f1c:	bd80      	pop	{r7, pc}
	...

08000f20 <EXTI0_1_IRQHandler>:

void EXTI0_1_IRQHandler( void )
{  
 8000f20:	b580      	push	{r7, lr}
 8000f22:	af00      	add	r7, sp, #0
   /* If pending request is on EXTI1 (= GPIOC1 = INT2 of ADXL345) */
   if ( ( EXTI->PR & EXTI_PR_PIF1 ) == EXTI_PR_PIF1 )
 8000f24:	4b0f      	ldr	r3, [pc, #60]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f26:	695b      	ldr	r3, [r3, #20]
 8000f28:	2202      	movs	r2, #2
 8000f2a:	4013      	ands	r3, r2
 8000f2c:	2b02      	cmp	r3, #2
 8000f2e:	d107      	bne.n	8000f40 <EXTI0_1_IRQHandler+0x20>
   {
      /* Clear EXTI1 pending request bit */
      EXTI->PR |= EXTI_PR_PIF1;
 8000f30:	4b0c      	ldr	r3, [pc, #48]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f32:	695a      	ldr	r2, [r3, #20]
 8000f34:	4b0b      	ldr	r3, [pc, #44]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f36:	2102      	movs	r1, #2
 8000f38:	430a      	orrs	r2, r1
 8000f3a:	615a      	str	r2, [r3, #20]

      /* Execute EXTI1 callback */
      EXTI1_Callback();
 8000f3c:	f000 f856 	bl	8000fec <EXTI1_Callback>
   }

   /* If pending request is on EXTI0 (= GPIOC0 = INT1 of ADXL345) */
   if ( ( EXTI->PR & EXTI_PR_PIF0 ) == EXTI_PR_PIF0 )
 8000f40:	4b08      	ldr	r3, [pc, #32]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f42:	695b      	ldr	r3, [r3, #20]
 8000f44:	2201      	movs	r2, #1
 8000f46:	4013      	ands	r3, r2
 8000f48:	2b01      	cmp	r3, #1
 8000f4a:	d107      	bne.n	8000f5c <EXTI0_1_IRQHandler+0x3c>
   {
      /* Clear EXTI0 pending request bit */
      EXTI->PR |= EXTI_PR_PIF0;
 8000f4c:	4b05      	ldr	r3, [pc, #20]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f4e:	695a      	ldr	r2, [r3, #20]
 8000f50:	4b04      	ldr	r3, [pc, #16]	; (8000f64 <EXTI0_1_IRQHandler+0x44>)
 8000f52:	2101      	movs	r1, #1
 8000f54:	430a      	orrs	r2, r1
 8000f56:	615a      	str	r2, [r3, #20]
         (do not read DATA registers from the ADXL345, so that FIFO replaces previous data stored
         and overrun interrupt will be triggered).
         if OVERRUN_INTERRUPT is not enabled, read the ADXL345 DATA registers instead */
      #if !defined (ADXL345_OVERRUN_INTERRUPT)
         /* Execute EXTI0 callback */
         EXTI0_Callback();
 8000f58:	f000 f82c 	bl	8000fb4 <EXTI0_Callback>
      #endif
   }
}
 8000f5c:	46c0      	nop			; (mov r8, r8)
 8000f5e:	46bd      	mov	sp, r7
 8000f60:	bd80      	pop	{r7, pc}
 8000f62:	46c0      	nop			; (mov r8, r8)
 8000f64:	40010400 	.word	0x40010400

08000f68 <EXTI4_15_IRQHandler>:

void EXTI4_15_IRQHandler( void )
{
 8000f68:	b580      	push	{r7, lr}
 8000f6a:	af00      	add	r7, sp, #0
   /* If pending request is on GPIOC13 (board button) */
   if ( ( EXTI->PR & EXTI_PR_PIF13 ) == EXTI_PR_PIF13 )
 8000f6c:	4b0a      	ldr	r3, [pc, #40]	; (8000f98 <EXTI4_15_IRQHandler+0x30>)
 8000f6e:	695a      	ldr	r2, [r3, #20]
 8000f70:	2380      	movs	r3, #128	; 0x80
 8000f72:	019b      	lsls	r3, r3, #6
 8000f74:	401a      	ands	r2, r3
 8000f76:	2380      	movs	r3, #128	; 0x80
 8000f78:	019b      	lsls	r3, r3, #6
 8000f7a:	429a      	cmp	r2, r3
 8000f7c:	d108      	bne.n	8000f90 <EXTI4_15_IRQHandler+0x28>
   {
      /* Clear EXTI13 peding request bit */
      EXTI->PR |= EXTI_PR_PIF13;
 8000f7e:	4b06      	ldr	r3, [pc, #24]	; (8000f98 <EXTI4_15_IRQHandler+0x30>)
 8000f80:	695a      	ldr	r2, [r3, #20]
 8000f82:	4b05      	ldr	r3, [pc, #20]	; (8000f98 <EXTI4_15_IRQHandler+0x30>)
 8000f84:	2180      	movs	r1, #128	; 0x80
 8000f86:	0189      	lsls	r1, r1, #6
 8000f88:	430a      	orrs	r2, r1
 8000f8a:	615a      	str	r2, [r3, #20]

      /* Execute EXTI13 callback */
      EXTI13_Callback();
 8000f8c:	f000 f838 	bl	8001000 <EXTI13_Callback>
   }
}
 8000f90:	46c0      	nop			; (mov r8, r8)
 8000f92:	46bd      	mov	sp, r7
 8000f94:	bd80      	pop	{r7, pc}
 8000f96:	46c0      	nop			; (mov r8, r8)
 8000f98:	40010400 	.word	0x40010400

08000f9c <SysTick_Callback>:

void SysTick_Callback( void )
{   
 8000f9c:	b580      	push	{r7, lr}
 8000f9e:	af00      	add	r7, sp, #0
   /* Every time the SysTick exception occurs (1ms)
      the SysTick counter will be increased,
      this counter can be used by the user as a timebase
      to execute periodic tasks */
   tick++;
 8000fa0:	4b03      	ldr	r3, [pc, #12]	; (8000fb0 <SysTick_Callback+0x14>)
 8000fa2:	681b      	ldr	r3, [r3, #0]
 8000fa4:	1c5a      	adds	r2, r3, #1
 8000fa6:	4b02      	ldr	r3, [pc, #8]	; (8000fb0 <SysTick_Callback+0x14>)
 8000fa8:	601a      	str	r2, [r3, #0]
}
 8000faa:	46c0      	nop			; (mov r8, r8)
 8000fac:	46bd      	mov	sp, r7
 8000fae:	bd80      	pop	{r7, pc}
 8000fb0:	20000054 	.word	0x20000054

08000fb4 <EXTI0_Callback>:

void EXTI0_Callback( void )
{
 8000fb4:	b580      	push	{r7, lr}
 8000fb6:	af00      	add	r7, sp, #0
   /* If a previous SPI1 transmission is in progress when this interrupt was triggered */
   if ( ( GPIOA->ODR & GPIO_ODR_4 ) == 0U ) /* ADXL345 CS pin LOW = slave selected */
 8000fb8:	2390      	movs	r3, #144	; 0x90
 8000fba:	05db      	lsls	r3, r3, #23
 8000fbc:	695b      	ldr	r3, [r3, #20]
 8000fbe:	2210      	movs	r2, #16
 8000fc0:	4013      	ands	r3, r2
 8000fc2:	d101      	bne.n	8000fc8 <EXTI0_Callback+0x14>
   {  
      /* Set ADXL345 CS pin to HIGH (IDLE state = slave not selected).
         This avoids overlapping bits for the current and next SPI frames) */
      SPI1_CS_Disable();
 8000fc4:	f000 fdb8 	bl	8001b38 <SPI1_CS_Disable>
   }

   /* Read acceleration raw data registers */
   ADXL345_API_Read_Axes( &ACCEL_Handler, &xmeas, &ymeas, &zmeas );
 8000fc8:	4b04      	ldr	r3, [pc, #16]	; (8000fdc <EXTI0_Callback+0x28>)
 8000fca:	4a05      	ldr	r2, [pc, #20]	; (8000fe0 <EXTI0_Callback+0x2c>)
 8000fcc:	4905      	ldr	r1, [pc, #20]	; (8000fe4 <EXTI0_Callback+0x30>)
 8000fce:	4806      	ldr	r0, [pc, #24]	; (8000fe8 <EXTI0_Callback+0x34>)
 8000fd0:	f000 ffd4 	bl	8001f7c <ADXL345_API_Read_Axes>
}
 8000fd4:	46c0      	nop			; (mov r8, r8)
 8000fd6:	46bd      	mov	sp, r7
 8000fd8:	bd80      	pop	{r7, pc}
 8000fda:	46c0      	nop			; (mov r8, r8)
 8000fdc:	20000048 	.word	0x20000048
 8000fe0:	20000046 	.word	0x20000046
 8000fe4:	20000044 	.word	0x20000044
 8000fe8:	20000028 	.word	0x20000028

08000fec <EXTI1_Callback>:

void EXTI1_Callback( void )
{
 8000fec:	b580      	push	{r7, lr}
 8000fee:	af00      	add	r7, sp, #0
   /* Raise ADXL345 INT2 interrupt status flag */
   int2Flag = 1U;
 8000ff0:	4b02      	ldr	r3, [pc, #8]	; (8000ffc <EXTI1_Callback+0x10>)
 8000ff2:	2201      	movs	r2, #1
 8000ff4:	701a      	strb	r2, [r3, #0]
}
 8000ff6:	46c0      	nop			; (mov r8, r8)
 8000ff8:	46bd      	mov	sp, r7
 8000ffa:	bd80      	pop	{r7, pc}
 8000ffc:	2000003d 	.word	0x2000003d

08001000 <EXTI13_Callback>:

void EXTI13_Callback( void )
{
 8001000:	b580      	push	{r7, lr}
 8001002:	af00      	add	r7, sp, #0
   /* Read acceleration raw data registers (the number of entries in FIFO will decrease
      by one if FIFO is set to a mode other than bypass) */
   ADXL345_API_Read_Axes( &ACCEL_Handler, &xmeas, &ymeas, &zmeas );
 8001004:	4b04      	ldr	r3, [pc, #16]	; (8001018 <EXTI13_Callback+0x18>)
 8001006:	4a05      	ldr	r2, [pc, #20]	; (800101c <EXTI13_Callback+0x1c>)
 8001008:	4905      	ldr	r1, [pc, #20]	; (8001020 <EXTI13_Callback+0x20>)
 800100a:	4806      	ldr	r0, [pc, #24]	; (8001024 <EXTI13_Callback+0x24>)
 800100c:	f000 ffb6 	bl	8001f7c <ADXL345_API_Read_Axes>
}
 8001010:	46c0      	nop			; (mov r8, r8)
 8001012:	46bd      	mov	sp, r7
 8001014:	bd80      	pop	{r7, pc}
 8001016:	46c0      	nop			; (mov r8, r8)
 8001018:	20000048 	.word	0x20000048
 800101c:	20000046 	.word	0x20000046
 8001020:	20000044 	.word	0x20000044
 8001024:	20000028 	.word	0x20000028

08001028 <TIM3_Init>:
#include "timer.h"

void TIM3_Init( void )
{
 8001028:	b580      	push	{r7, lr}
 800102a:	af00      	add	r7, sp, #0
    /* Enable TIM3 clock */
    TIM3_CLK_ENBL();
 800102c:	4b0e      	ldr	r3, [pc, #56]	; (8001068 <TIM3_Init+0x40>)
 800102e:	69da      	ldr	r2, [r3, #28]
 8001030:	4b0d      	ldr	r3, [pc, #52]	; (8001068 <TIM3_Init+0x40>)
 8001032:	2102      	movs	r1, #2
 8001034:	430a      	orrs	r2, r1
 8001036:	61da      	str	r2, [r3, #28]

    /* TIM3 as upcounter */
    TIM3->CR1 &= ~TIM_CR1_DIR;
 8001038:	4b0c      	ldr	r3, [pc, #48]	; (800106c <TIM3_Init+0x44>)
 800103a:	681a      	ldr	r2, [r3, #0]
 800103c:	4b0b      	ldr	r3, [pc, #44]	; (800106c <TIM3_Init+0x44>)
 800103e:	2110      	movs	r1, #16
 8001040:	438a      	bics	r2, r1
 8001042:	601a      	str	r2, [r3, #0]

    /* Counter over/under flow, setting UG bit or update generation through
       slave mode controller are selected as UEV (update event) sources */
    TIM3->CR1 &= ~TIM_CR1_URS;
 8001044:	4b09      	ldr	r3, [pc, #36]	; (800106c <TIM3_Init+0x44>)
 8001046:	681a      	ldr	r2, [r3, #0]
 8001048:	4b08      	ldr	r3, [pc, #32]	; (800106c <TIM3_Init+0x44>)
 800104a:	2104      	movs	r1, #4
 800104c:	438a      	bics	r2, r1
 800104e:	601a      	str	r2, [r3, #0]

    /* TIM3 UEV (update event) generation enabled */
    TIM3->CR1 &= ~TIM_CR1_UDIS;
 8001050:	4b06      	ldr	r3, [pc, #24]	; (800106c <TIM3_Init+0x44>)
 8001052:	681a      	ldr	r2, [r3, #0]
 8001054:	4b05      	ldr	r3, [pc, #20]	; (800106c <TIM3_Init+0x44>)
 8001056:	2102      	movs	r1, #2
 8001058:	438a      	bics	r2, r1
 800105a:	601a      	str	r2, [r3, #0]
        
    /* TIM3 prescaler.
       CK_CNT = (PSC + 1) / fck_psc
       = (0 + 1) / 20MHz
       = 50ns */
    TIM3->PSC = 0x0000U;
 800105c:	4b03      	ldr	r3, [pc, #12]	; (800106c <TIM3_Init+0x44>)
 800105e:	2200      	movs	r2, #0
 8001060:	629a      	str	r2, [r3, #40]	; 0x28
}
 8001062:	46c0      	nop			; (mov r8, r8)
 8001064:	46bd      	mov	sp, r7
 8001066:	bd80      	pop	{r7, pc}
 8001068:	40021000 	.word	0x40021000
 800106c:	40000400 	.word	0x40000400

08001070 <TIM3_Delay_us>:

void TIM3_Delay_us( uint32_t useconds )
{   
 8001070:	b580      	push	{r7, lr}
 8001072:	b084      	sub	sp, #16
 8001074:	af00      	add	r7, sp, #0
 8001076:	6078      	str	r0, [r7, #4]

    /* TIM3 auto-reload register.
       In order to generate a timebase = 1us:
       AUTORELOAD = (1us / TIM3_period) - 1
       with TIM3_period = 50ns */
    TIM3->ARR = 0x0013U;
 8001078:	4b18      	ldr	r3, [pc, #96]	; (80010dc <TIM3_Delay_us+0x6c>)
 800107a:	2213      	movs	r2, #19
 800107c:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Clear TIM3 counter */
    TIM3->CNT = 0x0000U;
 800107e:	4b17      	ldr	r3, [pc, #92]	; (80010dc <TIM3_Delay_us+0x6c>)
 8001080:	2200      	movs	r2, #0
 8001082:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clear update flag */
    TIM3->SR &= ~TIM_SR_UIF;
 8001084:	4b15      	ldr	r3, [pc, #84]	; (80010dc <TIM3_Delay_us+0x6c>)
 8001086:	691a      	ldr	r2, [r3, #16]
 8001088:	4b14      	ldr	r3, [pc, #80]	; (80010dc <TIM3_Delay_us+0x6c>)
 800108a:	2101      	movs	r1, #1
 800108c:	438a      	bics	r2, r1
 800108e:	611a      	str	r2, [r3, #16]

    /* Enable TIM3 */
    TIM3->CR1 |= TIM_CR1_CEN;
 8001090:	4b12      	ldr	r3, [pc, #72]	; (80010dc <TIM3_Delay_us+0x6c>)
 8001092:	681a      	ldr	r2, [r3, #0]
 8001094:	4b11      	ldr	r3, [pc, #68]	; (80010dc <TIM3_Delay_us+0x6c>)
 8001096:	2101      	movs	r1, #1
 8001098:	430a      	orrs	r2, r1
 800109a:	601a      	str	r2, [r3, #0]
        
    /* Wait entered microseconds */
    for ( i = 0; i < useconds; i++ )
 800109c:	2300      	movs	r3, #0
 800109e:	60fb      	str	r3, [r7, #12]
 80010a0:	e00e      	b.n	80010c0 <TIM3_Delay_us+0x50>
    {
        /* Wait for update flag (1us) */
        while ( ( TIM3->SR & TIM_SR_UIF ) == 0U )
 80010a2:	46c0      	nop			; (mov r8, r8)
 80010a4:	4b0d      	ldr	r3, [pc, #52]	; (80010dc <TIM3_Delay_us+0x6c>)
 80010a6:	691b      	ldr	r3, [r3, #16]
 80010a8:	2201      	movs	r2, #1
 80010aa:	4013      	ands	r3, r2
 80010ac:	d0fa      	beq.n	80010a4 <TIM3_Delay_us+0x34>
        {
            /* Do nothing */
        }

        /* Clear update flag */
        TIM3->SR &= ~TIM_SR_UIF;
 80010ae:	4b0b      	ldr	r3, [pc, #44]	; (80010dc <TIM3_Delay_us+0x6c>)
 80010b0:	691a      	ldr	r2, [r3, #16]
 80010b2:	4b0a      	ldr	r3, [pc, #40]	; (80010dc <TIM3_Delay_us+0x6c>)
 80010b4:	2101      	movs	r1, #1
 80010b6:	438a      	bics	r2, r1
 80010b8:	611a      	str	r2, [r3, #16]
    for ( i = 0; i < useconds; i++ )
 80010ba:	68fb      	ldr	r3, [r7, #12]
 80010bc:	3301      	adds	r3, #1
 80010be:	60fb      	str	r3, [r7, #12]
 80010c0:	68fa      	ldr	r2, [r7, #12]
 80010c2:	687b      	ldr	r3, [r7, #4]
 80010c4:	429a      	cmp	r2, r3
 80010c6:	d3ec      	bcc.n	80010a2 <TIM3_Delay_us+0x32>
    }

    /* Disable TIM3 */
    TIM3->CR1 &= ~TIM_CR1_CEN;
 80010c8:	4b04      	ldr	r3, [pc, #16]	; (80010dc <TIM3_Delay_us+0x6c>)
 80010ca:	681a      	ldr	r2, [r3, #0]
 80010cc:	4b03      	ldr	r3, [pc, #12]	; (80010dc <TIM3_Delay_us+0x6c>)
 80010ce:	2101      	movs	r1, #1
 80010d0:	438a      	bics	r2, r1
 80010d2:	601a      	str	r2, [r3, #0]
}
 80010d4:	46c0      	nop			; (mov r8, r8)
 80010d6:	46bd      	mov	sp, r7
 80010d8:	b004      	add	sp, #16
 80010da:	bd80      	pop	{r7, pc}
 80010dc:	40000400 	.word	0x40000400

080010e0 <TIM3_Delay_ms>:

void TIM3_Delay_ms( uint32_t mseconds )
{
 80010e0:	b580      	push	{r7, lr}
 80010e2:	b084      	sub	sp, #16
 80010e4:	af00      	add	r7, sp, #0
 80010e6:	6078      	str	r0, [r7, #4]

    /* TIM3 auto-reload register.
       In order to generate a timebase = 1ms:
       AUTORELOAD = (1ms / TIM3_period) - 1
       with TIM3_period = 50ns */
    TIM3->ARR = 0x4E1F;
 80010e8:	4b18      	ldr	r3, [pc, #96]	; (800114c <TIM3_Delay_ms+0x6c>)
 80010ea:	4a19      	ldr	r2, [pc, #100]	; (8001150 <TIM3_Delay_ms+0x70>)
 80010ec:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Clear TIM3 counter */
    TIM3->CNT = 0x0000U;
 80010ee:	4b17      	ldr	r3, [pc, #92]	; (800114c <TIM3_Delay_ms+0x6c>)
 80010f0:	2200      	movs	r2, #0
 80010f2:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clear update flag */
    TIM3->SR &= ~TIM_SR_UIF;
 80010f4:	4b15      	ldr	r3, [pc, #84]	; (800114c <TIM3_Delay_ms+0x6c>)
 80010f6:	691a      	ldr	r2, [r3, #16]
 80010f8:	4b14      	ldr	r3, [pc, #80]	; (800114c <TIM3_Delay_ms+0x6c>)
 80010fa:	2101      	movs	r1, #1
 80010fc:	438a      	bics	r2, r1
 80010fe:	611a      	str	r2, [r3, #16]

    /* Enable TIM3 */
    TIM3->CR1 |= TIM_CR1_CEN;
 8001100:	4b12      	ldr	r3, [pc, #72]	; (800114c <TIM3_Delay_ms+0x6c>)
 8001102:	681a      	ldr	r2, [r3, #0]
 8001104:	4b11      	ldr	r3, [pc, #68]	; (800114c <TIM3_Delay_ms+0x6c>)
 8001106:	2101      	movs	r1, #1
 8001108:	430a      	orrs	r2, r1
 800110a:	601a      	str	r2, [r3, #0]

    /* Wait entered miliseconds */
    for ( i = 0; i < mseconds; i++ )
 800110c:	2300      	movs	r3, #0
 800110e:	60fb      	str	r3, [r7, #12]
 8001110:	e00e      	b.n	8001130 <TIM3_Delay_ms+0x50>
    {
        /* Wait for update flag (1ms) */
        while ( ( TIM3->SR & TIM_SR_UIF ) == 0U )
 8001112:	46c0      	nop			; (mov r8, r8)
 8001114:	4b0d      	ldr	r3, [pc, #52]	; (800114c <TIM3_Delay_ms+0x6c>)
 8001116:	691b      	ldr	r3, [r3, #16]
 8001118:	2201      	movs	r2, #1
 800111a:	4013      	ands	r3, r2
 800111c:	d0fa      	beq.n	8001114 <TIM3_Delay_ms+0x34>
        {
            /* Do nothing */
        }

        /* Clear update flag */
        TIM3->SR &= ~TIM_SR_UIF;
 800111e:	4b0b      	ldr	r3, [pc, #44]	; (800114c <TIM3_Delay_ms+0x6c>)
 8001120:	691a      	ldr	r2, [r3, #16]
 8001122:	4b0a      	ldr	r3, [pc, #40]	; (800114c <TIM3_Delay_ms+0x6c>)
 8001124:	2101      	movs	r1, #1
 8001126:	438a      	bics	r2, r1
 8001128:	611a      	str	r2, [r3, #16]
    for ( i = 0; i < mseconds; i++ )
 800112a:	68fb      	ldr	r3, [r7, #12]
 800112c:	3301      	adds	r3, #1
 800112e:	60fb      	str	r3, [r7, #12]
 8001130:	68fa      	ldr	r2, [r7, #12]
 8001132:	687b      	ldr	r3, [r7, #4]
 8001134:	429a      	cmp	r2, r3
 8001136:	d3ec      	bcc.n	8001112 <TIM3_Delay_ms+0x32>
    }

    /* Disable TIM3 */
    TIM3->CR1 &= ~TIM_CR1_CEN;
 8001138:	4b04      	ldr	r3, [pc, #16]	; (800114c <TIM3_Delay_ms+0x6c>)
 800113a:	681a      	ldr	r2, [r3, #0]
 800113c:	4b03      	ldr	r3, [pc, #12]	; (800114c <TIM3_Delay_ms+0x6c>)
 800113e:	2101      	movs	r1, #1
 8001140:	438a      	bics	r2, r1
 8001142:	601a      	str	r2, [r3, #0]
}
 8001144:	46c0      	nop			; (mov r8, r8)
 8001146:	46bd      	mov	sp, r7
 8001148:	b004      	add	sp, #16
 800114a:	bd80      	pop	{r7, pc}
 800114c:	40000400 	.word	0x40000400
 8001150:	00004e1f 	.word	0x00004e1f

08001154 <I2C1_Init>:
#include "i2c.h"

void I2C1_Init( void )
{
 8001154:	b580      	push	{r7, lr}
 8001156:	af00      	add	r7, sp, #0
    /* Enable GPIOB clock access */
    GPIOB_CLK_ENBL();
 8001158:	4b61      	ldr	r3, [pc, #388]	; (80012e0 <I2C1_Init+0x18c>)
 800115a:	695a      	ldr	r2, [r3, #20]
 800115c:	4b60      	ldr	r3, [pc, #384]	; (80012e0 <I2C1_Init+0x18c>)
 800115e:	2180      	movs	r1, #128	; 0x80
 8001160:	02c9      	lsls	r1, r1, #11
 8001162:	430a      	orrs	r2, r1
 8001164:	615a      	str	r2, [r3, #20]

    /* GPIOB8 (I2C1_SCL) in alternate function mode */
    GPIOB->MODER |=  GPIO_MODER_MODER8_1;
 8001166:	4b5f      	ldr	r3, [pc, #380]	; (80012e4 <I2C1_Init+0x190>)
 8001168:	681a      	ldr	r2, [r3, #0]
 800116a:	4b5e      	ldr	r3, [pc, #376]	; (80012e4 <I2C1_Init+0x190>)
 800116c:	2180      	movs	r1, #128	; 0x80
 800116e:	0289      	lsls	r1, r1, #10
 8001170:	430a      	orrs	r2, r1
 8001172:	601a      	str	r2, [r3, #0]
    GPIOB->MODER &= ~GPIO_MODER_MODER8_0;
 8001174:	4b5b      	ldr	r3, [pc, #364]	; (80012e4 <I2C1_Init+0x190>)
 8001176:	681a      	ldr	r2, [r3, #0]
 8001178:	4b5a      	ldr	r3, [pc, #360]	; (80012e4 <I2C1_Init+0x190>)
 800117a:	495b      	ldr	r1, [pc, #364]	; (80012e8 <I2C1_Init+0x194>)
 800117c:	400a      	ands	r2, r1
 800117e:	601a      	str	r2, [r3, #0]

    /* GPIOB8 (I2C1_SCL) as open-drain output */
    GPIOB->OTYPER |= GPIO_OTYPER_OT_8;
 8001180:	4b58      	ldr	r3, [pc, #352]	; (80012e4 <I2C1_Init+0x190>)
 8001182:	685a      	ldr	r2, [r3, #4]
 8001184:	4b57      	ldr	r3, [pc, #348]	; (80012e4 <I2C1_Init+0x190>)
 8001186:	2180      	movs	r1, #128	; 0x80
 8001188:	0049      	lsls	r1, r1, #1
 800118a:	430a      	orrs	r2, r1
 800118c:	605a      	str	r2, [r3, #4]

    /* GPIOB8 (I2C1_SCL) with pull-up resistor */
    GPIOB->PUPDR &= ~GPIO_PUPDR_PUPDR8_1;
 800118e:	4b55      	ldr	r3, [pc, #340]	; (80012e4 <I2C1_Init+0x190>)
 8001190:	68da      	ldr	r2, [r3, #12]
 8001192:	4b54      	ldr	r3, [pc, #336]	; (80012e4 <I2C1_Init+0x190>)
 8001194:	4955      	ldr	r1, [pc, #340]	; (80012ec <I2C1_Init+0x198>)
 8001196:	400a      	ands	r2, r1
 8001198:	60da      	str	r2, [r3, #12]
    GPIOB->PUPDR |=  GPIO_PUPDR_PUPDR8_0;
 800119a:	4b52      	ldr	r3, [pc, #328]	; (80012e4 <I2C1_Init+0x190>)
 800119c:	68da      	ldr	r2, [r3, #12]
 800119e:	4b51      	ldr	r3, [pc, #324]	; (80012e4 <I2C1_Init+0x190>)
 80011a0:	2180      	movs	r1, #128	; 0x80
 80011a2:	0249      	lsls	r1, r1, #9
 80011a4:	430a      	orrs	r2, r1
 80011a6:	60da      	str	r2, [r3, #12]

    /* GPIOB8 in AF1 (I2C1_SCL) */
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL8_3;
 80011a8:	4b4e      	ldr	r3, [pc, #312]	; (80012e4 <I2C1_Init+0x190>)
 80011aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011ac:	4b4d      	ldr	r3, [pc, #308]	; (80012e4 <I2C1_Init+0x190>)
 80011ae:	2108      	movs	r1, #8
 80011b0:	438a      	bics	r2, r1
 80011b2:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL8_2;
 80011b4:	4b4b      	ldr	r3, [pc, #300]	; (80012e4 <I2C1_Init+0x190>)
 80011b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011b8:	4b4a      	ldr	r3, [pc, #296]	; (80012e4 <I2C1_Init+0x190>)
 80011ba:	2104      	movs	r1, #4
 80011bc:	438a      	bics	r2, r1
 80011be:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL8_1;
 80011c0:	4b48      	ldr	r3, [pc, #288]	; (80012e4 <I2C1_Init+0x190>)
 80011c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011c4:	4b47      	ldr	r3, [pc, #284]	; (80012e4 <I2C1_Init+0x190>)
 80011c6:	2102      	movs	r1, #2
 80011c8:	438a      	bics	r2, r1
 80011ca:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] |=  GPIO_AFRL_AFSEL8_0;
 80011cc:	4b45      	ldr	r3, [pc, #276]	; (80012e4 <I2C1_Init+0x190>)
 80011ce:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80011d0:	4b44      	ldr	r3, [pc, #272]	; (80012e4 <I2C1_Init+0x190>)
 80011d2:	2101      	movs	r1, #1
 80011d4:	430a      	orrs	r2, r1
 80011d6:	625a      	str	r2, [r3, #36]	; 0x24

    /* GPIOB9 (I2C1_SDA) in alternate function mode */
    GPIOB->MODER |=  GPIO_MODER_MODER9_1;
 80011d8:	4b42      	ldr	r3, [pc, #264]	; (80012e4 <I2C1_Init+0x190>)
 80011da:	681a      	ldr	r2, [r3, #0]
 80011dc:	4b41      	ldr	r3, [pc, #260]	; (80012e4 <I2C1_Init+0x190>)
 80011de:	2180      	movs	r1, #128	; 0x80
 80011e0:	0309      	lsls	r1, r1, #12
 80011e2:	430a      	orrs	r2, r1
 80011e4:	601a      	str	r2, [r3, #0]
    GPIOB->MODER &= ~GPIO_MODER_MODER9_0;
 80011e6:	4b3f      	ldr	r3, [pc, #252]	; (80012e4 <I2C1_Init+0x190>)
 80011e8:	681a      	ldr	r2, [r3, #0]
 80011ea:	4b3e      	ldr	r3, [pc, #248]	; (80012e4 <I2C1_Init+0x190>)
 80011ec:	4940      	ldr	r1, [pc, #256]	; (80012f0 <I2C1_Init+0x19c>)
 80011ee:	400a      	ands	r2, r1
 80011f0:	601a      	str	r2, [r3, #0]

    /* GPIOB9 (I2C1_SDA) as open-drain output */
    GPIOB->OTYPER |= GPIO_OTYPER_OT_9;
 80011f2:	4b3c      	ldr	r3, [pc, #240]	; (80012e4 <I2C1_Init+0x190>)
 80011f4:	685a      	ldr	r2, [r3, #4]
 80011f6:	4b3b      	ldr	r3, [pc, #236]	; (80012e4 <I2C1_Init+0x190>)
 80011f8:	2180      	movs	r1, #128	; 0x80
 80011fa:	0089      	lsls	r1, r1, #2
 80011fc:	430a      	orrs	r2, r1
 80011fe:	605a      	str	r2, [r3, #4]

    /* GPIOB9 (I2C1_SDA) with pull-up resistor */
    GPIOB->PUPDR &= ~GPIO_PUPDR_PUPDR9_1;
 8001200:	4b38      	ldr	r3, [pc, #224]	; (80012e4 <I2C1_Init+0x190>)
 8001202:	68da      	ldr	r2, [r3, #12]
 8001204:	4b37      	ldr	r3, [pc, #220]	; (80012e4 <I2C1_Init+0x190>)
 8001206:	493b      	ldr	r1, [pc, #236]	; (80012f4 <I2C1_Init+0x1a0>)
 8001208:	400a      	ands	r2, r1
 800120a:	60da      	str	r2, [r3, #12]
    GPIOB->PUPDR |=  GPIO_PUPDR_PUPDR9_0;
 800120c:	4b35      	ldr	r3, [pc, #212]	; (80012e4 <I2C1_Init+0x190>)
 800120e:	68da      	ldr	r2, [r3, #12]
 8001210:	4b34      	ldr	r3, [pc, #208]	; (80012e4 <I2C1_Init+0x190>)
 8001212:	2180      	movs	r1, #128	; 0x80
 8001214:	02c9      	lsls	r1, r1, #11
 8001216:	430a      	orrs	r2, r1
 8001218:	60da      	str	r2, [r3, #12]

    /* GPIOB9 in AF1 (I2C1_SDA) */
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL9_3;
 800121a:	4b32      	ldr	r3, [pc, #200]	; (80012e4 <I2C1_Init+0x190>)
 800121c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800121e:	4b31      	ldr	r3, [pc, #196]	; (80012e4 <I2C1_Init+0x190>)
 8001220:	2180      	movs	r1, #128	; 0x80
 8001222:	438a      	bics	r2, r1
 8001224:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL9_2;
 8001226:	4b2f      	ldr	r3, [pc, #188]	; (80012e4 <I2C1_Init+0x190>)
 8001228:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800122a:	4b2e      	ldr	r3, [pc, #184]	; (80012e4 <I2C1_Init+0x190>)
 800122c:	2140      	movs	r1, #64	; 0x40
 800122e:	438a      	bics	r2, r1
 8001230:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] &= ~GPIO_AFRL_AFSEL9_1;
 8001232:	4b2c      	ldr	r3, [pc, #176]	; (80012e4 <I2C1_Init+0x190>)
 8001234:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001236:	4b2b      	ldr	r3, [pc, #172]	; (80012e4 <I2C1_Init+0x190>)
 8001238:	2120      	movs	r1, #32
 800123a:	438a      	bics	r2, r1
 800123c:	625a      	str	r2, [r3, #36]	; 0x24
    GPIOB->AFR[ 1 ] |=  GPIO_AFRL_AFSEL9_0;
 800123e:	4b29      	ldr	r3, [pc, #164]	; (80012e4 <I2C1_Init+0x190>)
 8001240:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001242:	4b28      	ldr	r3, [pc, #160]	; (80012e4 <I2C1_Init+0x190>)
 8001244:	2110      	movs	r1, #16
 8001246:	430a      	orrs	r2, r1
 8001248:	625a      	str	r2, [r3, #36]	; 0x24

    /* Enable I2C1 clock access */
    I2C1_CLK_ENBL();
 800124a:	4b25      	ldr	r3, [pc, #148]	; (80012e0 <I2C1_Init+0x18c>)
 800124c:	69da      	ldr	r2, [r3, #28]
 800124e:	4b24      	ldr	r3, [pc, #144]	; (80012e0 <I2C1_Init+0x18c>)
 8001250:	2180      	movs	r1, #128	; 0x80
 8001252:	0389      	lsls	r1, r1, #14
 8001254:	430a      	orrs	r2, r1
 8001256:	61da      	str	r2, [r3, #28]

    /* Analog filter enabled */
    I2C1->CR1 &= ~I2C_CR1_ANFOFF;
 8001258:	4b27      	ldr	r3, [pc, #156]	; (80012f8 <I2C1_Init+0x1a4>)
 800125a:	681a      	ldr	r2, [r3, #0]
 800125c:	4b26      	ldr	r3, [pc, #152]	; (80012f8 <I2C1_Init+0x1a4>)
 800125e:	4927      	ldr	r1, [pc, #156]	; (80012fc <I2C1_Init+0x1a8>)
 8001260:	400a      	ands	r2, r1
 8001262:	601a      	str	r2, [r3, #0]

    /* Select HSI (= 8 MHz) as I2C1 clock source*/
    RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 8001264:	4b1e      	ldr	r3, [pc, #120]	; (80012e0 <I2C1_Init+0x18c>)
 8001266:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001268:	4b1d      	ldr	r3, [pc, #116]	; (80012e0 <I2C1_Init+0x18c>)
 800126a:	2110      	movs	r1, #16
 800126c:	438a      	bics	r2, r1
 800126e:	631a      	str	r2, [r3, #48]	; 0x30

    /* Digital filter disabled */
    I2C1->CR1 &= ~I2C_CR1_DNF_3;
 8001270:	4b21      	ldr	r3, [pc, #132]	; (80012f8 <I2C1_Init+0x1a4>)
 8001272:	681a      	ldr	r2, [r3, #0]
 8001274:	4b20      	ldr	r3, [pc, #128]	; (80012f8 <I2C1_Init+0x1a4>)
 8001276:	4922      	ldr	r1, [pc, #136]	; (8001300 <I2C1_Init+0x1ac>)
 8001278:	400a      	ands	r2, r1
 800127a:	601a      	str	r2, [r3, #0]
    I2C1->CR1 &= ~I2C_CR1_DNF_2;
 800127c:	4b1e      	ldr	r3, [pc, #120]	; (80012f8 <I2C1_Init+0x1a4>)
 800127e:	681a      	ldr	r2, [r3, #0]
 8001280:	4b1d      	ldr	r3, [pc, #116]	; (80012f8 <I2C1_Init+0x1a4>)
 8001282:	4920      	ldr	r1, [pc, #128]	; (8001304 <I2C1_Init+0x1b0>)
 8001284:	400a      	ands	r2, r1
 8001286:	601a      	str	r2, [r3, #0]
    I2C1->CR1 &= ~I2C_CR1_DNF_1;
 8001288:	4b1b      	ldr	r3, [pc, #108]	; (80012f8 <I2C1_Init+0x1a4>)
 800128a:	681a      	ldr	r2, [r3, #0]
 800128c:	4b1a      	ldr	r3, [pc, #104]	; (80012f8 <I2C1_Init+0x1a4>)
 800128e:	491e      	ldr	r1, [pc, #120]	; (8001308 <I2C1_Init+0x1b4>)
 8001290:	400a      	ands	r2, r1
 8001292:	601a      	str	r2, [r3, #0]
    I2C1->CR1 &= ~I2C_CR1_DNF_0;
 8001294:	4b18      	ldr	r3, [pc, #96]	; (80012f8 <I2C1_Init+0x1a4>)
 8001296:	681a      	ldr	r2, [r3, #0]
 8001298:	4b17      	ldr	r3, [pc, #92]	; (80012f8 <I2C1_Init+0x1a4>)
 800129a:	491c      	ldr	r1, [pc, #112]	; (800130c <I2C1_Init+0x1b8>)
 800129c:	400a      	ands	r2, r1
 800129e:	601a      	str	r2, [r3, #0]

    /* Transfer will be complete after NBYTES data transfer */
    I2C1->CR2 &= ~I2C_CR2_RELOAD;
 80012a0:	4b15      	ldr	r3, [pc, #84]	; (80012f8 <I2C1_Init+0x1a4>)
 80012a2:	685a      	ldr	r2, [r3, #4]
 80012a4:	4b14      	ldr	r3, [pc, #80]	; (80012f8 <I2C1_Init+0x1a4>)
 80012a6:	491a      	ldr	r1, [pc, #104]	; (8001310 <I2C1_Init+0x1bc>)
 80012a8:	400a      	ands	r2, r1
 80012aa:	605a      	str	r2, [r3, #4]

    /* I2C1 in automatic end mode.
       Master automatically sends a STOP condition once the number
       of bytes in NBYTES has been transferred */
    I2C1->CR2 |= I2C_CR2_AUTOEND;
 80012ac:	4b12      	ldr	r3, [pc, #72]	; (80012f8 <I2C1_Init+0x1a4>)
 80012ae:	685a      	ldr	r2, [r3, #4]
 80012b0:	4b11      	ldr	r3, [pc, #68]	; (80012f8 <I2C1_Init+0x1a4>)
 80012b2:	2180      	movs	r1, #128	; 0x80
 80012b4:	0489      	lsls	r1, r1, #18
 80012b6:	430a      	orrs	r2, r1
 80012b8:	605a      	str	r2, [r3, #4]

    /* I2C1 in 7 bit addressing mode */
    I2C1->CR2 &= ~I2C_CR2_ADD10;
 80012ba:	4b0f      	ldr	r3, [pc, #60]	; (80012f8 <I2C1_Init+0x1a4>)
 80012bc:	685a      	ldr	r2, [r3, #4]
 80012be:	4b0e      	ldr	r3, [pc, #56]	; (80012f8 <I2C1_Init+0x1a4>)
 80012c0:	490f      	ldr	r1, [pc, #60]	; (8001300 <I2C1_Init+0x1ac>)
 80012c2:	400a      	ands	r2, r1
 80012c4:	605a      	str	r2, [r3, #4]
       SDADEL = 0  (0x00)
       SCLH   = 29 (0x1D)
       SCLL   = 43 (0x2B)
        
       NOTE: I2C1 in standard mode (100KHz) */
    I2C1->TIMINGR = 0x00201D2BU;
 80012c6:	4b0c      	ldr	r3, [pc, #48]	; (80012f8 <I2C1_Init+0x1a4>)
 80012c8:	4a12      	ldr	r2, [pc, #72]	; (8001314 <I2C1_Init+0x1c0>)
 80012ca:	611a      	str	r2, [r3, #16]

    /* Enable I2C1 */
    I2C1->CR1 |= I2C_CR1_PE;
 80012cc:	4b0a      	ldr	r3, [pc, #40]	; (80012f8 <I2C1_Init+0x1a4>)
 80012ce:	681a      	ldr	r2, [r3, #0]
 80012d0:	4b09      	ldr	r3, [pc, #36]	; (80012f8 <I2C1_Init+0x1a4>)
 80012d2:	2101      	movs	r1, #1
 80012d4:	430a      	orrs	r2, r1
 80012d6:	601a      	str	r2, [r3, #0]
}
 80012d8:	46c0      	nop			; (mov r8, r8)
 80012da:	46bd      	mov	sp, r7
 80012dc:	bd80      	pop	{r7, pc}
 80012de:	46c0      	nop			; (mov r8, r8)
 80012e0:	40021000 	.word	0x40021000
 80012e4:	48000400 	.word	0x48000400
 80012e8:	fffeffff 	.word	0xfffeffff
 80012ec:	fffdffff 	.word	0xfffdffff
 80012f0:	fffbffff 	.word	0xfffbffff
 80012f4:	fff7ffff 	.word	0xfff7ffff
 80012f8:	40005400 	.word	0x40005400
 80012fc:	ffffefff 	.word	0xffffefff
 8001300:	fffff7ff 	.word	0xfffff7ff
 8001304:	fffffbff 	.word	0xfffffbff
 8001308:	fffffdff 	.word	0xfffffdff
 800130c:	fffffeff 	.word	0xfffffeff
 8001310:	feffffff 	.word	0xfeffffff
 8001314:	00201d2b 	.word	0x00201d2b

08001318 <I2C1_Write>:

void I2C1_Write( uint8_t slaveAddr, uint8_t *data, uint8_t size )
{   
 8001318:	b580      	push	{r7, lr}
 800131a:	b084      	sub	sp, #16
 800131c:	af00      	add	r7, sp, #0
 800131e:	6039      	str	r1, [r7, #0]
 8001320:	0011      	movs	r1, r2
 8001322:	1dfb      	adds	r3, r7, #7
 8001324:	1c02      	adds	r2, r0, #0
 8001326:	701a      	strb	r2, [r3, #0]
 8001328:	1dbb      	adds	r3, r7, #6
 800132a:	1c0a      	adds	r2, r1, #0
 800132c:	701a      	strb	r2, [r3, #0]
    uint8_t byteCtr;
        
    /* Set slave address */
    I2C1->CR2 |= ( slaveAddr & SLAVE_ADDR_7b_Msk ) << I2C_CR2_SADD_7_1_Pos;
 800132e:	4b2a      	ldr	r3, [pc, #168]	; (80013d8 <I2C1_Write+0xc0>)
 8001330:	6859      	ldr	r1, [r3, #4]
 8001332:	1dfb      	adds	r3, r7, #7
 8001334:	781b      	ldrb	r3, [r3, #0]
 8001336:	005b      	lsls	r3, r3, #1
 8001338:	22ff      	movs	r2, #255	; 0xff
 800133a:	401a      	ands	r2, r3
 800133c:	4b26      	ldr	r3, [pc, #152]	; (80013d8 <I2C1_Write+0xc0>)
 800133e:	430a      	orrs	r2, r1
 8001340:	605a      	str	r2, [r3, #4]

    /* Set number of bytes to be sent */
    I2C1->CR2 |= size << I2C_CR2_NBYTES_Pos;
 8001342:	4b25      	ldr	r3, [pc, #148]	; (80013d8 <I2C1_Write+0xc0>)
 8001344:	6859      	ldr	r1, [r3, #4]
 8001346:	1dbb      	adds	r3, r7, #6
 8001348:	781b      	ldrb	r3, [r3, #0]
 800134a:	041a      	lsls	r2, r3, #16
 800134c:	4b22      	ldr	r3, [pc, #136]	; (80013d8 <I2C1_Write+0xc0>)
 800134e:	430a      	orrs	r2, r1
 8001350:	605a      	str	r2, [r3, #4]

    /* Set read/write bit (0 = write operation) */
    I2C1->CR2 &= ~I2C_CR2_RD_WRN;
 8001352:	4b21      	ldr	r3, [pc, #132]	; (80013d8 <I2C1_Write+0xc0>)
 8001354:	685a      	ldr	r2, [r3, #4]
 8001356:	4b20      	ldr	r3, [pc, #128]	; (80013d8 <I2C1_Write+0xc0>)
 8001358:	4920      	ldr	r1, [pc, #128]	; (80013dc <I2C1_Write+0xc4>)
 800135a:	400a      	ands	r2, r1
 800135c:	605a      	str	r2, [r3, #4]
        
    /* Set start bit */
    I2C1->CR2 |= I2C_CR2_START;
 800135e:	4b1e      	ldr	r3, [pc, #120]	; (80013d8 <I2C1_Write+0xc0>)
 8001360:	685a      	ldr	r2, [r3, #4]
 8001362:	4b1d      	ldr	r3, [pc, #116]	; (80013d8 <I2C1_Write+0xc0>)
 8001364:	2180      	movs	r1, #128	; 0x80
 8001366:	0189      	lsls	r1, r1, #6
 8001368:	430a      	orrs	r2, r1
 800136a:	605a      	str	r2, [r3, #4]
       master automatically sends start bit + slave address + write bit */

    /* If slave address is correct, then the slave will send an ACK bit */
        
    /* Wait for transmit data register (TXD) to be empty */
    while ( ( ( I2C1->ISR & I2C_ISR_TXE ) != I2C_ISR_TXE ) )
 800136c:	46c0      	nop			; (mov r8, r8)
 800136e:	4b1a      	ldr	r3, [pc, #104]	; (80013d8 <I2C1_Write+0xc0>)
 8001370:	699b      	ldr	r3, [r3, #24]
 8001372:	2201      	movs	r2, #1
 8001374:	4013      	ands	r3, r2
 8001376:	2b01      	cmp	r3, #1
 8001378:	d1f9      	bne.n	800136e <I2C1_Write+0x56>
    {
        /* Do nothing */
    }

    /* Send each byte from the data array over I2C1 */
    for ( byteCtr = 0; byteCtr < size; byteCtr++, data++ )
 800137a:	230f      	movs	r3, #15
 800137c:	18fb      	adds	r3, r7, r3
 800137e:	2200      	movs	r2, #0
 8001380:	701a      	strb	r2, [r3, #0]
 8001382:	e013      	b.n	80013ac <I2C1_Write+0x94>
    {   
        /* Transmit current data byte */
        I2C1->TXDR = ( uint32_t ) ( *data );
 8001384:	683b      	ldr	r3, [r7, #0]
 8001386:	781a      	ldrb	r2, [r3, #0]
 8001388:	4b13      	ldr	r3, [pc, #76]	; (80013d8 <I2C1_Write+0xc0>)
 800138a:	629a      	str	r2, [r3, #40]	; 0x28

        /* Wait for transmit data register (TXD) to be sent */
        while ( ( ( I2C1->ISR & I2C_ISR_TXE ) != I2C_ISR_TXE ) )
 800138c:	46c0      	nop			; (mov r8, r8)
 800138e:	4b12      	ldr	r3, [pc, #72]	; (80013d8 <I2C1_Write+0xc0>)
 8001390:	699b      	ldr	r3, [r3, #24]
 8001392:	2201      	movs	r2, #1
 8001394:	4013      	ands	r3, r2
 8001396:	2b01      	cmp	r3, #1
 8001398:	d1f9      	bne.n	800138e <I2C1_Write+0x76>
    for ( byteCtr = 0; byteCtr < size; byteCtr++, data++ )
 800139a:	210f      	movs	r1, #15
 800139c:	187b      	adds	r3, r7, r1
 800139e:	781a      	ldrb	r2, [r3, #0]
 80013a0:	187b      	adds	r3, r7, r1
 80013a2:	3201      	adds	r2, #1
 80013a4:	701a      	strb	r2, [r3, #0]
 80013a6:	683b      	ldr	r3, [r7, #0]
 80013a8:	3301      	adds	r3, #1
 80013aa:	603b      	str	r3, [r7, #0]
 80013ac:	230f      	movs	r3, #15
 80013ae:	18fa      	adds	r2, r7, r3
 80013b0:	1dbb      	adds	r3, r7, #6
 80013b2:	7812      	ldrb	r2, [r2, #0]
 80013b4:	781b      	ldrb	r3, [r3, #0]
 80013b6:	429a      	cmp	r2, r3
 80013b8:	d3e4      	bcc.n	8001384 <I2C1_Write+0x6c>

    /* Once transmission is complete ...
       master automatically sends a stop bit (due to autoend mode enabled) */
        
    /* Wait for I2C1 bus to be free (stop bit sent) */
    while ( ( I2C1->ISR & I2C_ISR_BUSY ) == I2C_ISR_BUSY )
 80013ba:	46c0      	nop			; (mov r8, r8)
 80013bc:	4b06      	ldr	r3, [pc, #24]	; (80013d8 <I2C1_Write+0xc0>)
 80013be:	699a      	ldr	r2, [r3, #24]
 80013c0:	2380      	movs	r3, #128	; 0x80
 80013c2:	021b      	lsls	r3, r3, #8
 80013c4:	401a      	ands	r2, r3
 80013c6:	2380      	movs	r3, #128	; 0x80
 80013c8:	021b      	lsls	r3, r3, #8
 80013ca:	429a      	cmp	r2, r3
 80013cc:	d0f6      	beq.n	80013bc <I2C1_Write+0xa4>
    {
        /* Do nothing */
    }
}
 80013ce:	46c0      	nop			; (mov r8, r8)
 80013d0:	46c0      	nop			; (mov r8, r8)
 80013d2:	46bd      	mov	sp, r7
 80013d4:	b004      	add	sp, #16
 80013d6:	bd80      	pop	{r7, pc}
 80013d8:	40005400 	.word	0x40005400
 80013dc:	fffffbff 	.word	0xfffffbff

080013e0 <LCD_Init>:

static uint8_t byte;
static uint8_t DDRAMADDR = 0U;

void LCD_Init( LCD_HandleTypeDef *hlcd )
{
 80013e0:	b590      	push	{r4, r7, lr}
 80013e2:	b085      	sub	sp, #20
 80013e4:	af00      	add	r7, sp, #0
 80013e6:	6078      	str	r0, [r7, #4]
    uint8_t i2cByte;

    /* Initialize TIM3 */
    TIM3_Init();
 80013e8:	f7ff fe1e 	bl	8001028 <TIM3_Init>

    /* Inititalize I2C1 */
    I2C1_Init();
 80013ec:	f7ff feb2 	bl	8001154 <I2C1_Init>

    /* Wait 40 ms */
    TIM3_Delay_ms( 40U );
 80013f0:	2028      	movs	r0, #40	; 0x28
 80013f2:	f7ff fe75 	bl	80010e0 <TIM3_Delay_ms>

    /* Function set (this is sent in 8 bit mode)
       DB7 = 0, DB6 = 0, DB5 = 1, DB4 = 1 = ST7066U in 8 bit mode
       backlight = backlight ON = 1, E = 0, RW = 0, RS = 0
       (not used) DB3 = N = x, DB2 = F = x, DB1 = x, DB0 = x */
    i2cByte = 0x38U;
 80013f6:	210f      	movs	r1, #15
 80013f8:	187b      	adds	r3, r7, r1
 80013fa:	2238      	movs	r2, #56	; 0x38
 80013fc:	701a      	strb	r2, [r3, #0]
    I2C1_Write( hlcd->lcdaddress, &i2cByte, 1U );
 80013fe:	687b      	ldr	r3, [r7, #4]
 8001400:	781b      	ldrb	r3, [r3, #0]
 8001402:	000c      	movs	r4, r1
 8001404:	1879      	adds	r1, r7, r1
 8001406:	2201      	movs	r2, #1
 8001408:	0018      	movs	r0, r3
 800140a:	f7ff ff85 	bl	8001318 <I2C1_Write>
    LCD_Start_Data_Write( hlcd, i2cByte );
 800140e:	193b      	adds	r3, r7, r4
 8001410:	781a      	ldrb	r2, [r3, #0]
 8001412:	687b      	ldr	r3, [r7, #4]
 8001414:	0011      	movs	r1, r2
 8001416:	0018      	movs	r0, r3
 8001418:	f000 f820 	bl	800145c <LCD_Start_Data_Write>

    /* Wait 37us */
    TIM3_Delay_us( 37U ),
 800141c:	2025      	movs	r0, #37	; 0x25
 800141e:	f7ff fe27 	bl	8001070 <TIM3_Delay_us>

    /* 1st try, set ST7066U to (8/4) bit datalength, (1/2) display line
       and (5x8/5x11) dots font mode */
    LCD_Send_Instruction( hlcd, FUNCTION_SET_REG );
 8001422:	687b      	ldr	r3, [r7, #4]
 8001424:	2120      	movs	r1, #32
 8001426:	0018      	movs	r0, r3
 8001428:	f000 f840 	bl	80014ac <LCD_Send_Instruction>

    /* 2nd try, set ST7066U to (8/4) bit datalength, (1/2) display line
       and (5x8/5x11) dots font mode */
    LCD_Send_Instruction( hlcd, FUNCTION_SET_REG );
 800142c:	687b      	ldr	r3, [r7, #4]
 800142e:	2120      	movs	r1, #32
 8001430:	0018      	movs	r0, r3
 8001432:	f000 f83b 	bl	80014ac <LCD_Send_Instruction>
        
    /* Turn (on/off) display, (enable/disable) cursor, 
       and (enable/disable) blink */
    LCD_Send_Instruction( hlcd, DISPLAY_ON_OFF_REG );
 8001436:	687b      	ldr	r3, [r7, #4]
 8001438:	2108      	movs	r1, #8
 800143a:	0018      	movs	r0, r3
 800143c:	f000 f836 	bl	80014ac <LCD_Send_Instruction>

    /* Clear display */
    LCD_Send_Instruction( hlcd, CLEAR_DISPLAY_REG );
 8001440:	687b      	ldr	r3, [r7, #4]
 8001442:	2101      	movs	r1, #1
 8001444:	0018      	movs	r0, r3
 8001446:	f000 f831 	bl	80014ac <LCD_Send_Instruction>

    /* Set (left/right) cursor direction and (shift/no shift) display */
    LCD_Send_Instruction( hlcd, ENTRY_MODE_SET_REG );
 800144a:	687b      	ldr	r3, [r7, #4]
 800144c:	2104      	movs	r1, #4
 800144e:	0018      	movs	r0, r3
 8001450:	f000 f82c 	bl	80014ac <LCD_Send_Instruction>
}
 8001454:	46c0      	nop			; (mov r8, r8)
 8001456:	46bd      	mov	sp, r7
 8001458:	b005      	add	sp, #20
 800145a:	bd90      	pop	{r4, r7, pc}

0800145c <LCD_Start_Data_Write>:

void LCD_Start_Data_Write( LCD_HandleTypeDef *hlcd, uint8_t prevData )
{   
 800145c:	b580      	push	{r7, lr}
 800145e:	b082      	sub	sp, #8
 8001460:	af00      	add	r7, sp, #0
 8001462:	6078      	str	r0, [r7, #4]
 8001464:	000a      	movs	r2, r1
 8001466:	1cfb      	adds	r3, r7, #3
 8001468:	701a      	strb	r2, [r3, #0]
    /* Enable E signal without touching previous data.
       This tells the ST7066U driver to accept current data on its pins */
    prevData |= E_ENABLED;
 800146a:	1cfb      	adds	r3, r7, #3
 800146c:	781b      	ldrb	r3, [r3, #0]
 800146e:	2204      	movs	r2, #4
 8001470:	4313      	orrs	r3, r2
 8001472:	b2da      	uxtb	r2, r3
 8001474:	1cfb      	adds	r3, r7, #3
 8001476:	701a      	strb	r2, [r3, #0]
    I2C1_Write( hlcd->lcdaddress, &prevData, 1U );
 8001478:	687b      	ldr	r3, [r7, #4]
 800147a:	781b      	ldrb	r3, [r3, #0]
 800147c:	1cf9      	adds	r1, r7, #3
 800147e:	2201      	movs	r2, #1
 8001480:	0018      	movs	r0, r3
 8001482:	f7ff ff49 	bl	8001318 <I2C1_Write>

    /* Disable E signal.
       Prepare driver for future commands or data */
    prevData &= ~E_ENABLED;
 8001486:	1cfb      	adds	r3, r7, #3
 8001488:	781b      	ldrb	r3, [r3, #0]
 800148a:	2204      	movs	r2, #4
 800148c:	4393      	bics	r3, r2
 800148e:	b2da      	uxtb	r2, r3
 8001490:	1cfb      	adds	r3, r7, #3
 8001492:	701a      	strb	r2, [r3, #0]
    I2C1_Write( hlcd->lcdaddress, &prevData, 1U );
 8001494:	687b      	ldr	r3, [r7, #4]
 8001496:	781b      	ldrb	r3, [r3, #0]
 8001498:	1cf9      	adds	r1, r7, #3
 800149a:	2201      	movs	r2, #1
 800149c:	0018      	movs	r0, r3
 800149e:	f7ff ff3b 	bl	8001318 <I2C1_Write>
}
 80014a2:	46c0      	nop			; (mov r8, r8)
 80014a4:	46bd      	mov	sp, r7
 80014a6:	b002      	add	sp, #8
 80014a8:	bd80      	pop	{r7, pc}
	...

080014ac <LCD_Send_Instruction>:

void LCD_Send_Instruction( LCD_HandleTypeDef *hlcd, uint8_t instruction )
{
 80014ac:	b580      	push	{r7, lr}
 80014ae:	b082      	sub	sp, #8
 80014b0:	af00      	add	r7, sp, #0
 80014b2:	6078      	str	r0, [r7, #4]
 80014b4:	000a      	movs	r2, r1
 80014b6:	1cfb      	adds	r3, r7, #3
 80014b8:	701a      	strb	r2, [r3, #0]
    /* Instruction's MOST SIGNIFICANT nibble + light + write instruction */
    byte = ( instruction & 0xF0U ) | hlcd->backlight | RW_WRITE | RS_INSTRUCTION;
 80014ba:	1cfb      	adds	r3, r7, #3
 80014bc:	781b      	ldrb	r3, [r3, #0]
 80014be:	220f      	movs	r2, #15
 80014c0:	4393      	bics	r3, r2
 80014c2:	b2da      	uxtb	r2, r3
 80014c4:	687b      	ldr	r3, [r7, #4]
 80014c6:	785b      	ldrb	r3, [r3, #1]
 80014c8:	4313      	orrs	r3, r2
 80014ca:	b2da      	uxtb	r2, r3
 80014cc:	4b5d      	ldr	r3, [pc, #372]	; (8001644 <LCD_Send_Instruction+0x198>)
 80014ce:	701a      	strb	r2, [r3, #0]

    switch ( instruction )
 80014d0:	1cfb      	adds	r3, r7, #3
 80014d2:	781b      	ldrb	r3, [r3, #0]
 80014d4:	2b20      	cmp	r3, #32
 80014d6:	d002      	beq.n	80014de <LCD_Send_Instruction+0x32>
 80014d8:	2b80      	cmp	r3, #128	; 0x80
 80014da:	d009      	beq.n	80014f0 <LCD_Send_Instruction+0x44>
            byte |= ( DDRAMADDR & 0x70U );
            break;

        default:
            /* Do nothing */
            break;
 80014dc:	e014      	b.n	8001508 <LCD_Send_Instruction+0x5c>
            byte |= hlcd->datalenght;
 80014de:	687b      	ldr	r3, [r7, #4]
 80014e0:	7a9a      	ldrb	r2, [r3, #10]
 80014e2:	4b58      	ldr	r3, [pc, #352]	; (8001644 <LCD_Send_Instruction+0x198>)
 80014e4:	781b      	ldrb	r3, [r3, #0]
 80014e6:	4313      	orrs	r3, r2
 80014e8:	b2da      	uxtb	r2, r3
 80014ea:	4b56      	ldr	r3, [pc, #344]	; (8001644 <LCD_Send_Instruction+0x198>)
 80014ec:	701a      	strb	r2, [r3, #0]
            break;
 80014ee:	e00b      	b.n	8001508 <LCD_Send_Instruction+0x5c>
            byte |= ( DDRAMADDR & 0x70U );
 80014f0:	4b55      	ldr	r3, [pc, #340]	; (8001648 <LCD_Send_Instruction+0x19c>)
 80014f2:	781b      	ldrb	r3, [r3, #0]
 80014f4:	2270      	movs	r2, #112	; 0x70
 80014f6:	4013      	ands	r3, r2
 80014f8:	b2da      	uxtb	r2, r3
 80014fa:	4b52      	ldr	r3, [pc, #328]	; (8001644 <LCD_Send_Instruction+0x198>)
 80014fc:	781b      	ldrb	r3, [r3, #0]
 80014fe:	4313      	orrs	r3, r2
 8001500:	b2da      	uxtb	r2, r3
 8001502:	4b50      	ldr	r3, [pc, #320]	; (8001644 <LCD_Send_Instruction+0x198>)
 8001504:	701a      	strb	r2, [r3, #0]
            break;
 8001506:	46c0      	nop			; (mov r8, r8)
    }

    /* Send MOST SIGNIFICANT nibble + extra parameters over I2C1 */
    I2C1_Write( hlcd->lcdaddress, &byte, 1U );
 8001508:	687b      	ldr	r3, [r7, #4]
 800150a:	781b      	ldrb	r3, [r3, #0]
 800150c:	494d      	ldr	r1, [pc, #308]	; (8001644 <LCD_Send_Instruction+0x198>)
 800150e:	2201      	movs	r2, #1
 8001510:	0018      	movs	r0, r3
 8001512:	f7ff ff01 	bl	8001318 <I2C1_Write>
    LCD_Start_Data_Write( hlcd, byte );
 8001516:	4b4b      	ldr	r3, [pc, #300]	; (8001644 <LCD_Send_Instruction+0x198>)
 8001518:	781a      	ldrb	r2, [r3, #0]
 800151a:	687b      	ldr	r3, [r7, #4]
 800151c:	0011      	movs	r1, r2
 800151e:	0018      	movs	r0, r3
 8001520:	f7ff ff9c 	bl	800145c <LCD_Start_Data_Write>

    /* Instruction's LEAST SIGNIFICANT nibble + light + write instruction */
    byte = ( instruction << 4 ) | hlcd->backlight | RW_WRITE | RS_INSTRUCTION;
 8001524:	1cfb      	adds	r3, r7, #3
 8001526:	781b      	ldrb	r3, [r3, #0]
 8001528:	011b      	lsls	r3, r3, #4
 800152a:	b25a      	sxtb	r2, r3
 800152c:	687b      	ldr	r3, [r7, #4]
 800152e:	785b      	ldrb	r3, [r3, #1]
 8001530:	b25b      	sxtb	r3, r3
 8001532:	4313      	orrs	r3, r2
 8001534:	b25b      	sxtb	r3, r3
 8001536:	b2da      	uxtb	r2, r3
 8001538:	4b42      	ldr	r3, [pc, #264]	; (8001644 <LCD_Send_Instruction+0x198>)
 800153a:	701a      	strb	r2, [r3, #0]
        
    switch ( instruction )
 800153c:	1cfb      	adds	r3, r7, #3
 800153e:	781b      	ldrb	r3, [r3, #0]
 8001540:	2b80      	cmp	r3, #128	; 0x80
 8001542:	d04f      	beq.n	80015e4 <LCD_Send_Instruction+0x138>
 8001544:	dc59      	bgt.n	80015fa <LCD_Send_Instruction+0x14e>
 8001546:	2b20      	cmp	r3, #32
 8001548:	d03b      	beq.n	80015c2 <LCD_Send_Instruction+0x116>
 800154a:	dc56      	bgt.n	80015fa <LCD_Send_Instruction+0x14e>
 800154c:	2b10      	cmp	r3, #16
 800154e:	d02b      	beq.n	80015a8 <LCD_Send_Instruction+0xfc>
 8001550:	dc53      	bgt.n	80015fa <LCD_Send_Instruction+0x14e>
 8001552:	2b04      	cmp	r3, #4
 8001554:	d002      	beq.n	800155c <LCD_Send_Instruction+0xb0>
 8001556:	2b08      	cmp	r3, #8
 8001558:	d011      	beq.n	800157e <LCD_Send_Instruction+0xd2>
            byte |= ( DDRAMADDR & 0x0FU ) << 4;
            break;

        default:
            /* Do nothing */
            break;
 800155a:	e04e      	b.n	80015fa <LCD_Send_Instruction+0x14e>
            byte |= ( hlcd->incrementddram | hlcd->shiftdisplay ) << 4;
 800155c:	687b      	ldr	r3, [r7, #4]
 800155e:	78da      	ldrb	r2, [r3, #3]
 8001560:	687b      	ldr	r3, [r7, #4]
 8001562:	789b      	ldrb	r3, [r3, #2]
 8001564:	4313      	orrs	r3, r2
 8001566:	b2db      	uxtb	r3, r3
 8001568:	011b      	lsls	r3, r3, #4
 800156a:	b25a      	sxtb	r2, r3
 800156c:	4b35      	ldr	r3, [pc, #212]	; (8001644 <LCD_Send_Instruction+0x198>)
 800156e:	781b      	ldrb	r3, [r3, #0]
 8001570:	b25b      	sxtb	r3, r3
 8001572:	4313      	orrs	r3, r2
 8001574:	b25b      	sxtb	r3, r3
 8001576:	b2da      	uxtb	r2, r3
 8001578:	4b32      	ldr	r3, [pc, #200]	; (8001644 <LCD_Send_Instruction+0x198>)
 800157a:	701a      	strb	r2, [r3, #0]
            break;
 800157c:	e03e      	b.n	80015fc <LCD_Send_Instruction+0x150>
            byte |= ( hlcd->display | hlcd->cursor | hlcd->blink ) << 4;
 800157e:	687b      	ldr	r3, [r7, #4]
 8001580:	799a      	ldrb	r2, [r3, #6]
 8001582:	687b      	ldr	r3, [r7, #4]
 8001584:	795b      	ldrb	r3, [r3, #5]
 8001586:	4313      	orrs	r3, r2
 8001588:	b2da      	uxtb	r2, r3
 800158a:	687b      	ldr	r3, [r7, #4]
 800158c:	791b      	ldrb	r3, [r3, #4]
 800158e:	4313      	orrs	r3, r2
 8001590:	b2db      	uxtb	r3, r3
 8001592:	011b      	lsls	r3, r3, #4
 8001594:	b25a      	sxtb	r2, r3
 8001596:	4b2b      	ldr	r3, [pc, #172]	; (8001644 <LCD_Send_Instruction+0x198>)
 8001598:	781b      	ldrb	r3, [r3, #0]
 800159a:	b25b      	sxtb	r3, r3
 800159c:	4313      	orrs	r3, r2
 800159e:	b25b      	sxtb	r3, r3
 80015a0:	b2da      	uxtb	r2, r3
 80015a2:	4b28      	ldr	r3, [pc, #160]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015a4:	701a      	strb	r2, [r3, #0]
            break;
 80015a6:	e029      	b.n	80015fc <LCD_Send_Instruction+0x150>
            byte |= hlcd->shiftcursor << 4;
 80015a8:	687b      	ldr	r3, [r7, #4]
 80015aa:	79db      	ldrb	r3, [r3, #7]
 80015ac:	011b      	lsls	r3, r3, #4
 80015ae:	b25a      	sxtb	r2, r3
 80015b0:	4b24      	ldr	r3, [pc, #144]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015b2:	781b      	ldrb	r3, [r3, #0]
 80015b4:	b25b      	sxtb	r3, r3
 80015b6:	4313      	orrs	r3, r2
 80015b8:	b25b      	sxtb	r3, r3
 80015ba:	b2da      	uxtb	r2, r3
 80015bc:	4b21      	ldr	r3, [pc, #132]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015be:	701a      	strb	r2, [r3, #0]
            break;
 80015c0:	e01c      	b.n	80015fc <LCD_Send_Instruction+0x150>
            byte |= ( hlcd->displayline | hlcd->font ) << 4;
 80015c2:	687b      	ldr	r3, [r7, #4]
 80015c4:	7a5a      	ldrb	r2, [r3, #9]
 80015c6:	687b      	ldr	r3, [r7, #4]
 80015c8:	7a1b      	ldrb	r3, [r3, #8]
 80015ca:	4313      	orrs	r3, r2
 80015cc:	b2db      	uxtb	r3, r3
 80015ce:	011b      	lsls	r3, r3, #4
 80015d0:	b25a      	sxtb	r2, r3
 80015d2:	4b1c      	ldr	r3, [pc, #112]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015d4:	781b      	ldrb	r3, [r3, #0]
 80015d6:	b25b      	sxtb	r3, r3
 80015d8:	4313      	orrs	r3, r2
 80015da:	b25b      	sxtb	r3, r3
 80015dc:	b2da      	uxtb	r2, r3
 80015de:	4b19      	ldr	r3, [pc, #100]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015e0:	701a      	strb	r2, [r3, #0]
            break;
 80015e2:	e00b      	b.n	80015fc <LCD_Send_Instruction+0x150>
            byte |= ( DDRAMADDR & 0x0FU ) << 4;
 80015e4:	4b18      	ldr	r3, [pc, #96]	; (8001648 <LCD_Send_Instruction+0x19c>)
 80015e6:	781b      	ldrb	r3, [r3, #0]
 80015e8:	011b      	lsls	r3, r3, #4
 80015ea:	b2da      	uxtb	r2, r3
 80015ec:	4b15      	ldr	r3, [pc, #84]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015ee:	781b      	ldrb	r3, [r3, #0]
 80015f0:	4313      	orrs	r3, r2
 80015f2:	b2da      	uxtb	r2, r3
 80015f4:	4b13      	ldr	r3, [pc, #76]	; (8001644 <LCD_Send_Instruction+0x198>)
 80015f6:	701a      	strb	r2, [r3, #0]
            break;
 80015f8:	e000      	b.n	80015fc <LCD_Send_Instruction+0x150>
            break;
 80015fa:	46c0      	nop			; (mov r8, r8)
    }

    /* Send LEAST SIGNIFICANT nibble + extra parameters over I2C1 */
    I2C1_Write( hlcd->lcdaddress, &byte, 1U );
 80015fc:	687b      	ldr	r3, [r7, #4]
 80015fe:	781b      	ldrb	r3, [r3, #0]
 8001600:	4910      	ldr	r1, [pc, #64]	; (8001644 <LCD_Send_Instruction+0x198>)
 8001602:	2201      	movs	r2, #1
 8001604:	0018      	movs	r0, r3
 8001606:	f7ff fe87 	bl	8001318 <I2C1_Write>
    LCD_Start_Data_Write( hlcd, byte );
 800160a:	4b0e      	ldr	r3, [pc, #56]	; (8001644 <LCD_Send_Instruction+0x198>)
 800160c:	781a      	ldrb	r2, [r3, #0]
 800160e:	687b      	ldr	r3, [r7, #4]
 8001610:	0011      	movs	r1, r2
 8001612:	0018      	movs	r0, r3
 8001614:	f7ff ff22 	bl	800145c <LCD_Start_Data_Write>

    if ( ( instruction == CLEAR_DISPLAY_REG ) || ( instruction == RETURN_HOME_REG ) )
 8001618:	1cfb      	adds	r3, r7, #3
 800161a:	781b      	ldrb	r3, [r3, #0]
 800161c:	2b01      	cmp	r3, #1
 800161e:	d003      	beq.n	8001628 <LCD_Send_Instruction+0x17c>
 8001620:	1cfb      	adds	r3, r7, #3
 8001622:	781b      	ldrb	r3, [r3, #0]
 8001624:	2b02      	cmp	r3, #2
 8001626:	d105      	bne.n	8001634 <LCD_Send_Instruction+0x188>
    {   
        /* Wait 1.52 ms */
        TIM3_Delay_us( 1520U );
 8001628:	23be      	movs	r3, #190	; 0xbe
 800162a:	00db      	lsls	r3, r3, #3
 800162c:	0018      	movs	r0, r3
 800162e:	f7ff fd1f 	bl	8001070 <TIM3_Delay_us>
 8001632:	e003      	b.n	800163c <LCD_Send_Instruction+0x190>
    }
    else
    {
        /* Wait 37 us */
        TIM3_Delay_us( 37U );
 8001634:	2025      	movs	r0, #37	; 0x25
 8001636:	f7ff fd1b 	bl	8001070 <TIM3_Delay_us>
    }
}
 800163a:	46c0      	nop			; (mov r8, r8)
 800163c:	46c0      	nop			; (mov r8, r8)
 800163e:	46bd      	mov	sp, r7
 8001640:	b002      	add	sp, #8
 8001642:	bd80      	pop	{r7, pc}
 8001644:	20000050 	.word	0x20000050
 8001648:	20000051 	.word	0x20000051

0800164c <LCD_Write_To_DDRAM>:

void LCD_Write_To_DDRAM( LCD_HandleTypeDef *hlcd, uint8_t data )
{
 800164c:	b580      	push	{r7, lr}
 800164e:	b082      	sub	sp, #8
 8001650:	af00      	add	r7, sp, #0
 8001652:	6078      	str	r0, [r7, #4]
 8001654:	000a      	movs	r2, r1
 8001656:	1cfb      	adds	r3, r7, #3
 8001658:	701a      	strb	r2, [r3, #0]
    /* Data's MSB nible + extra parameters */
    byte = ( data & 0xF0U ) | hlcd->backlight | RW_WRITE | RS_DATA;
 800165a:	1cfb      	adds	r3, r7, #3
 800165c:	781b      	ldrb	r3, [r3, #0]
 800165e:	220f      	movs	r2, #15
 8001660:	4393      	bics	r3, r2
 8001662:	b2da      	uxtb	r2, r3
 8001664:	687b      	ldr	r3, [r7, #4]
 8001666:	785b      	ldrb	r3, [r3, #1]
 8001668:	4313      	orrs	r3, r2
 800166a:	b2db      	uxtb	r3, r3
 800166c:	2201      	movs	r2, #1
 800166e:	4313      	orrs	r3, r2
 8001670:	b2da      	uxtb	r2, r3
 8001672:	4b1a      	ldr	r3, [pc, #104]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 8001674:	701a      	strb	r2, [r3, #0]
    I2C1_Write( hlcd->lcdaddress, &byte, 1 );
 8001676:	687b      	ldr	r3, [r7, #4]
 8001678:	781b      	ldrb	r3, [r3, #0]
 800167a:	4918      	ldr	r1, [pc, #96]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 800167c:	2201      	movs	r2, #1
 800167e:	0018      	movs	r0, r3
 8001680:	f7ff fe4a 	bl	8001318 <I2C1_Write>
    LCD_Start_Data_Write( hlcd, byte );
 8001684:	4b15      	ldr	r3, [pc, #84]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 8001686:	781a      	ldrb	r2, [r3, #0]
 8001688:	687b      	ldr	r3, [r7, #4]
 800168a:	0011      	movs	r1, r2
 800168c:	0018      	movs	r0, r3
 800168e:	f7ff fee5 	bl	800145c <LCD_Start_Data_Write>

    /* Data's LSB nible + extra parameters */
    byte = ( data << 4 ) | hlcd->backlight | RW_WRITE | RS_DATA;
 8001692:	1cfb      	adds	r3, r7, #3
 8001694:	781b      	ldrb	r3, [r3, #0]
 8001696:	011b      	lsls	r3, r3, #4
 8001698:	b25a      	sxtb	r2, r3
 800169a:	687b      	ldr	r3, [r7, #4]
 800169c:	785b      	ldrb	r3, [r3, #1]
 800169e:	b25b      	sxtb	r3, r3
 80016a0:	4313      	orrs	r3, r2
 80016a2:	b25b      	sxtb	r3, r3
 80016a4:	b2db      	uxtb	r3, r3
 80016a6:	2201      	movs	r2, #1
 80016a8:	4313      	orrs	r3, r2
 80016aa:	b2da      	uxtb	r2, r3
 80016ac:	4b0b      	ldr	r3, [pc, #44]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 80016ae:	701a      	strb	r2, [r3, #0]
    I2C1_Write( hlcd->lcdaddress, &byte, 1U );
 80016b0:	687b      	ldr	r3, [r7, #4]
 80016b2:	781b      	ldrb	r3, [r3, #0]
 80016b4:	4909      	ldr	r1, [pc, #36]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 80016b6:	2201      	movs	r2, #1
 80016b8:	0018      	movs	r0, r3
 80016ba:	f7ff fe2d 	bl	8001318 <I2C1_Write>
    LCD_Start_Data_Write( hlcd, byte );
 80016be:	4b07      	ldr	r3, [pc, #28]	; (80016dc <LCD_Write_To_DDRAM+0x90>)
 80016c0:	781a      	ldrb	r2, [r3, #0]
 80016c2:	687b      	ldr	r3, [r7, #4]
 80016c4:	0011      	movs	r1, r2
 80016c6:	0018      	movs	r0, r3
 80016c8:	f7ff fec8 	bl	800145c <LCD_Start_Data_Write>

    /* Wait 37 us */
    TIM3_Delay_us( 37U );
 80016cc:	2025      	movs	r0, #37	; 0x25
 80016ce:	f7ff fccf 	bl	8001070 <TIM3_Delay_us>
}
 80016d2:	46c0      	nop			; (mov r8, r8)
 80016d4:	46bd      	mov	sp, r7
 80016d6:	b002      	add	sp, #8
 80016d8:	bd80      	pop	{r7, pc}
 80016da:	46c0      	nop			; (mov r8, r8)
 80016dc:	20000050 	.word	0x20000050

080016e0 <LCD_API_Move_Cursor>:

void LCD_API_Move_Cursor( LCD_HandleTypeDef *hlcd, uint8_t row, uint8_t col )
{
 80016e0:	b580      	push	{r7, lr}
 80016e2:	b082      	sub	sp, #8
 80016e4:	af00      	add	r7, sp, #0
 80016e6:	6078      	str	r0, [r7, #4]
 80016e8:	0008      	movs	r0, r1
 80016ea:	0011      	movs	r1, r2
 80016ec:	1cfb      	adds	r3, r7, #3
 80016ee:	1c02      	adds	r2, r0, #0
 80016f0:	701a      	strb	r2, [r3, #0]
 80016f2:	1cbb      	adds	r3, r7, #2
 80016f4:	1c0a      	adds	r2, r1, #0
 80016f6:	701a      	strb	r2, [r3, #0]
    if ( row <= 1U && col <= 15U )
 80016f8:	1cfb      	adds	r3, r7, #3
 80016fa:	781b      	ldrb	r3, [r3, #0]
 80016fc:	2b01      	cmp	r3, #1
 80016fe:	d817      	bhi.n	8001730 <LCD_API_Move_Cursor+0x50>
 8001700:	1cbb      	adds	r3, r7, #2
 8001702:	781b      	ldrb	r3, [r3, #0]
 8001704:	2b0f      	cmp	r3, #15
 8001706:	d813      	bhi.n	8001730 <LCD_API_Move_Cursor+0x50>
    {   
        if ( row == 1U )
 8001708:	1cfb      	adds	r3, r7, #3
 800170a:	781b      	ldrb	r3, [r3, #0]
 800170c:	2b01      	cmp	r3, #1
 800170e:	d102      	bne.n	8001716 <LCD_API_Move_Cursor+0x36>
        {
            row = 0x40U;
 8001710:	1cfb      	adds	r3, r7, #3
 8001712:	2240      	movs	r2, #64	; 0x40
 8001714:	701a      	strb	r2, [r3, #0]
        }

        DDRAMADDR = row + col;
 8001716:	1cfa      	adds	r2, r7, #3
 8001718:	1cbb      	adds	r3, r7, #2
 800171a:	7812      	ldrb	r2, [r2, #0]
 800171c:	781b      	ldrb	r3, [r3, #0]
 800171e:	18d3      	adds	r3, r2, r3
 8001720:	b2da      	uxtb	r2, r3
 8001722:	4b05      	ldr	r3, [pc, #20]	; (8001738 <LCD_API_Move_Cursor+0x58>)
 8001724:	701a      	strb	r2, [r3, #0]
        LCD_Send_Instruction( hlcd, SET_DDRAM_ADDRESS_REG );
 8001726:	687b      	ldr	r3, [r7, #4]
 8001728:	2180      	movs	r1, #128	; 0x80
 800172a:	0018      	movs	r0, r3
 800172c:	f7ff febe 	bl	80014ac <LCD_Send_Instruction>
    }
}
 8001730:	46c0      	nop			; (mov r8, r8)
 8001732:	46bd      	mov	sp, r7
 8001734:	b002      	add	sp, #8
 8001736:	bd80      	pop	{r7, pc}
 8001738:	20000051 	.word	0x20000051

0800173c <LCD_API_Print_Character>:

void LCD_API_Print_Character( LCD_HandleTypeDef *hlcd, uint8_t character )
{
 800173c:	b580      	push	{r7, lr}
 800173e:	b082      	sub	sp, #8
 8001740:	af00      	add	r7, sp, #0
 8001742:	6078      	str	r0, [r7, #4]
 8001744:	000a      	movs	r2, r1
 8001746:	1cfb      	adds	r3, r7, #3
 8001748:	701a      	strb	r2, [r3, #0]
    if ( character >= ' ' && character <= '}' )
 800174a:	1cfb      	adds	r3, r7, #3
 800174c:	781b      	ldrb	r3, [r3, #0]
 800174e:	2b1f      	cmp	r3, #31
 8001750:	d90a      	bls.n	8001768 <LCD_API_Print_Character+0x2c>
 8001752:	1cfb      	adds	r3, r7, #3
 8001754:	781b      	ldrb	r3, [r3, #0]
 8001756:	2b7d      	cmp	r3, #125	; 0x7d
 8001758:	d806      	bhi.n	8001768 <LCD_API_Print_Character+0x2c>
    {
        LCD_Write_To_DDRAM( hlcd, character );
 800175a:	1cfb      	adds	r3, r7, #3
 800175c:	781a      	ldrb	r2, [r3, #0]
 800175e:	687b      	ldr	r3, [r7, #4]
 8001760:	0011      	movs	r1, r2
 8001762:	0018      	movs	r0, r3
 8001764:	f7ff ff72 	bl	800164c <LCD_Write_To_DDRAM>
    }
}
 8001768:	46c0      	nop			; (mov r8, r8)
 800176a:	46bd      	mov	sp, r7
 800176c:	b002      	add	sp, #8
 800176e:	bd80      	pop	{r7, pc}

08001770 <LCD_API_Print_String>:

void LCD_API_Print_String( LCD_HandleTypeDef *hlcd, uint8_t *string, uint8_t size )
{
 8001770:	b590      	push	{r4, r7, lr}
 8001772:	b087      	sub	sp, #28
 8001774:	af00      	add	r7, sp, #0
 8001776:	60f8      	str	r0, [r7, #12]
 8001778:	60b9      	str	r1, [r7, #8]
 800177a:	1dfb      	adds	r3, r7, #7
 800177c:	701a      	strb	r2, [r3, #0]
    uint8_t i;

    for ( i = 0U; i < size; i++ )
 800177e:	2317      	movs	r3, #23
 8001780:	18fb      	adds	r3, r7, r3
 8001782:	2200      	movs	r2, #0
 8001784:	701a      	strb	r2, [r3, #0]
 8001786:	e00f      	b.n	80017a8 <LCD_API_Print_String+0x38>
    {
        LCD_API_Print_Character( hlcd, string[ i ] );
 8001788:	2417      	movs	r4, #23
 800178a:	193b      	adds	r3, r7, r4
 800178c:	781b      	ldrb	r3, [r3, #0]
 800178e:	68ba      	ldr	r2, [r7, #8]
 8001790:	18d3      	adds	r3, r2, r3
 8001792:	781a      	ldrb	r2, [r3, #0]
 8001794:	68fb      	ldr	r3, [r7, #12]
 8001796:	0011      	movs	r1, r2
 8001798:	0018      	movs	r0, r3
 800179a:	f7ff ffcf 	bl	800173c <LCD_API_Print_Character>
    for ( i = 0U; i < size; i++ )
 800179e:	193b      	adds	r3, r7, r4
 80017a0:	781a      	ldrb	r2, [r3, #0]
 80017a2:	193b      	adds	r3, r7, r4
 80017a4:	3201      	adds	r2, #1
 80017a6:	701a      	strb	r2, [r3, #0]
 80017a8:	2317      	movs	r3, #23
 80017aa:	18fa      	adds	r2, r7, r3
 80017ac:	1dfb      	adds	r3, r7, #7
 80017ae:	7812      	ldrb	r2, [r2, #0]
 80017b0:	781b      	ldrb	r3, [r3, #0]
 80017b2:	429a      	cmp	r2, r3
 80017b4:	d3e8      	bcc.n	8001788 <LCD_API_Print_String+0x18>
    }
}
 80017b6:	46c0      	nop			; (mov r8, r8)
 80017b8:	46c0      	nop			; (mov r8, r8)
 80017ba:	46bd      	mov	sp, r7
 80017bc:	b007      	add	sp, #28
 80017be:	bd90      	pop	{r4, r7, pc}

080017c0 <SysTick_Init>:

/* Systick global variable updated every time the Systick exception takes place (1ms). Refer to interrupts.c */
uint32_t tick = 0U;

void SysTick_Init( void )
{
 80017c0:	b580      	push	{r7, lr}
 80017c2:	af00      	add	r7, sp, #0
   /* Processor clock (HCLK = 20MHz) as SysTick clocksource */
   SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;
 80017c4:	4b09      	ldr	r3, [pc, #36]	; (80017ec <SysTick_Init+0x2c>)
 80017c6:	2204      	movs	r2, #4
 80017c8:	601a      	str	r2, [r3, #0]

   /* SysTick reload value set to 1ms.
      RELOAD = 1ms / ( 1 / HCLK )
      with HCLK = 20MHz */
   SysTick->LOAD = 0x4E20U;
 80017ca:	4b08      	ldr	r3, [pc, #32]	; (80017ec <SysTick_Init+0x2c>)
 80017cc:	4a08      	ldr	r2, [pc, #32]	; (80017f0 <SysTick_Init+0x30>)
 80017ce:	605a      	str	r2, [r3, #4]

   /* Enable SysTick exception request */
   SysTick_Exception_Init();
 80017d0:	f000 f810 	bl	80017f4 <SysTick_Exception_Init>

   /* SysTick current value set to 0 */
   SysTick->VAL = 0x00U;
 80017d4:	4b05      	ldr	r3, [pc, #20]	; (80017ec <SysTick_Init+0x2c>)
 80017d6:	2200      	movs	r2, #0
 80017d8:	609a      	str	r2, [r3, #8]

   /* Enable SysTick */
   SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
 80017da:	4b04      	ldr	r3, [pc, #16]	; (80017ec <SysTick_Init+0x2c>)
 80017dc:	681a      	ldr	r2, [r3, #0]
 80017de:	4b03      	ldr	r3, [pc, #12]	; (80017ec <SysTick_Init+0x2c>)
 80017e0:	2101      	movs	r1, #1
 80017e2:	430a      	orrs	r2, r1
 80017e4:	601a      	str	r2, [r3, #0]
}
 80017e6:	46c0      	nop			; (mov r8, r8)
 80017e8:	46bd      	mov	sp, r7
 80017ea:	bd80      	pop	{r7, pc}
 80017ec:	e000e010 	.word	0xe000e010
 80017f0:	00004e20 	.word	0x00004e20

080017f4 <SysTick_Exception_Init>:

void SysTick_Exception_Init( void )
{
 80017f4:	b580      	push	{r7, lr}
 80017f6:	af00      	add	r7, sp, #0
   /* Enable SysTick exception request
      (counting down to zero asserts the exception request) */
   SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
 80017f8:	4b04      	ldr	r3, [pc, #16]	; (800180c <SysTick_Exception_Init+0x18>)
 80017fa:	681a      	ldr	r2, [r3, #0]
 80017fc:	4b03      	ldr	r3, [pc, #12]	; (800180c <SysTick_Exception_Init+0x18>)
 80017fe:	2102      	movs	r1, #2
 8001800:	430a      	orrs	r2, r1
 8001802:	601a      	str	r2, [r3, #0]
}
 8001804:	46c0      	nop			; (mov r8, r8)
 8001806:	46bd      	mov	sp, r7
 8001808:	bd80      	pop	{r7, pc}
 800180a:	46c0      	nop			; (mov r8, r8)
 800180c:	e000e010 	.word	0xe000e010

08001810 <Get_SysTick>:

uint32_t Get_SysTick( void )
{
 8001810:	b580      	push	{r7, lr}
 8001812:	af00      	add	r7, sp, #0
   /* Increment by 1 the Systick global variable */
   return tick;
 8001814:	4b02      	ldr	r3, [pc, #8]	; (8001820 <Get_SysTick+0x10>)
 8001816:	681b      	ldr	r3, [r3, #0]
}
 8001818:	0018      	movs	r0, r3
 800181a:	46bd      	mov	sp, r7
 800181c:	bd80      	pop	{r7, pc}
 800181e:	46c0      	nop			; (mov r8, r8)
 8001820:	20000054 	.word	0x20000054

08001824 <SPI1_GPIO_Init>:
#include "spi.h"

void SPI1_GPIO_Init( void )
{
 8001824:	b580      	push	{r7, lr}
 8001826:	af00      	add	r7, sp, #0
    /* Enable GPIOA clock access */
    GPIOA_CLK_ENBL();
 8001828:	4b66      	ldr	r3, [pc, #408]	; (80019c4 <SPI1_GPIO_Init+0x1a0>)
 800182a:	695a      	ldr	r2, [r3, #20]
 800182c:	4b65      	ldr	r3, [pc, #404]	; (80019c4 <SPI1_GPIO_Init+0x1a0>)
 800182e:	2180      	movs	r1, #128	; 0x80
 8001830:	0289      	lsls	r1, r1, #10
 8001832:	430a      	orrs	r2, r1
 8001834:	615a      	str	r2, [r3, #20]

    /* PA4 (SPI_CE) as output */
    GPIOA->MODER &= ~GPIO_MODER_MODER4_1;
 8001836:	2390      	movs	r3, #144	; 0x90
 8001838:	05db      	lsls	r3, r3, #23
 800183a:	681a      	ldr	r2, [r3, #0]
 800183c:	2390      	movs	r3, #144	; 0x90
 800183e:	05db      	lsls	r3, r3, #23
 8001840:	4961      	ldr	r1, [pc, #388]	; (80019c8 <SPI1_GPIO_Init+0x1a4>)
 8001842:	400a      	ands	r2, r1
 8001844:	601a      	str	r2, [r3, #0]
    GPIOA->MODER |=  GPIO_MODER_MODER4_0;
 8001846:	2390      	movs	r3, #144	; 0x90
 8001848:	05db      	lsls	r3, r3, #23
 800184a:	681a      	ldr	r2, [r3, #0]
 800184c:	2390      	movs	r3, #144	; 0x90
 800184e:	05db      	lsls	r3, r3, #23
 8001850:	2180      	movs	r1, #128	; 0x80
 8001852:	0049      	lsls	r1, r1, #1
 8001854:	430a      	orrs	r2, r1
 8001856:	601a      	str	r2, [r3, #0]

    /* PA5 (SPI1_SCK), PA6 (SPI1_MISO) and PA7 (SPI1_MOSI)
       in alternate function mode */
    GPIOA->MODER |=  GPIO_MODER_MODER5_1;
 8001858:	2390      	movs	r3, #144	; 0x90
 800185a:	05db      	lsls	r3, r3, #23
 800185c:	681a      	ldr	r2, [r3, #0]
 800185e:	2390      	movs	r3, #144	; 0x90
 8001860:	05db      	lsls	r3, r3, #23
 8001862:	2180      	movs	r1, #128	; 0x80
 8001864:	0109      	lsls	r1, r1, #4
 8001866:	430a      	orrs	r2, r1
 8001868:	601a      	str	r2, [r3, #0]
    GPIOA->MODER &= ~GPIO_MODER_MODER5_0;
 800186a:	2390      	movs	r3, #144	; 0x90
 800186c:	05db      	lsls	r3, r3, #23
 800186e:	681a      	ldr	r2, [r3, #0]
 8001870:	2390      	movs	r3, #144	; 0x90
 8001872:	05db      	lsls	r3, r3, #23
 8001874:	4955      	ldr	r1, [pc, #340]	; (80019cc <SPI1_GPIO_Init+0x1a8>)
 8001876:	400a      	ands	r2, r1
 8001878:	601a      	str	r2, [r3, #0]
    GPIOA->MODER |=  GPIO_MODER_MODER6_1;
 800187a:	2390      	movs	r3, #144	; 0x90
 800187c:	05db      	lsls	r3, r3, #23
 800187e:	681a      	ldr	r2, [r3, #0]
 8001880:	2390      	movs	r3, #144	; 0x90
 8001882:	05db      	lsls	r3, r3, #23
 8001884:	2180      	movs	r1, #128	; 0x80
 8001886:	0189      	lsls	r1, r1, #6
 8001888:	430a      	orrs	r2, r1
 800188a:	601a      	str	r2, [r3, #0]
    GPIOA->MODER &= ~GPIO_MODER_MODER6_0;
 800188c:	2390      	movs	r3, #144	; 0x90
 800188e:	05db      	lsls	r3, r3, #23
 8001890:	681a      	ldr	r2, [r3, #0]
 8001892:	2390      	movs	r3, #144	; 0x90
 8001894:	05db      	lsls	r3, r3, #23
 8001896:	494e      	ldr	r1, [pc, #312]	; (80019d0 <SPI1_GPIO_Init+0x1ac>)
 8001898:	400a      	ands	r2, r1
 800189a:	601a      	str	r2, [r3, #0]
    GPIOA->MODER |=  GPIO_MODER_MODER7_1;
 800189c:	2390      	movs	r3, #144	; 0x90
 800189e:	05db      	lsls	r3, r3, #23
 80018a0:	681a      	ldr	r2, [r3, #0]
 80018a2:	2390      	movs	r3, #144	; 0x90
 80018a4:	05db      	lsls	r3, r3, #23
 80018a6:	2180      	movs	r1, #128	; 0x80
 80018a8:	0209      	lsls	r1, r1, #8
 80018aa:	430a      	orrs	r2, r1
 80018ac:	601a      	str	r2, [r3, #0]
    GPIOA->MODER &= ~GPIO_MODER_MODER7_0;
 80018ae:	2390      	movs	r3, #144	; 0x90
 80018b0:	05db      	lsls	r3, r3, #23
 80018b2:	681a      	ldr	r2, [r3, #0]
 80018b4:	2390      	movs	r3, #144	; 0x90
 80018b6:	05db      	lsls	r3, r3, #23
 80018b8:	4946      	ldr	r1, [pc, #280]	; (80019d4 <SPI1_GPIO_Init+0x1b0>)
 80018ba:	400a      	ands	r2, r1
 80018bc:	601a      	str	r2, [r3, #0]

    /* PA4 (SPI1_CE), PA5 (SPI1_SCK), PA6 (SPI1_MISO) and PA7 (SPI1_MOSI)
       in output push-pull mode */
    GPIOA->OTYPER &= ~GPIO_OTYPER_OT_4;
 80018be:	2390      	movs	r3, #144	; 0x90
 80018c0:	05db      	lsls	r3, r3, #23
 80018c2:	685a      	ldr	r2, [r3, #4]
 80018c4:	2390      	movs	r3, #144	; 0x90
 80018c6:	05db      	lsls	r3, r3, #23
 80018c8:	2110      	movs	r1, #16
 80018ca:	438a      	bics	r2, r1
 80018cc:	605a      	str	r2, [r3, #4]
    GPIOA->OTYPER &= ~GPIO_OTYPER_OT_5;
 80018ce:	2390      	movs	r3, #144	; 0x90
 80018d0:	05db      	lsls	r3, r3, #23
 80018d2:	685a      	ldr	r2, [r3, #4]
 80018d4:	2390      	movs	r3, #144	; 0x90
 80018d6:	05db      	lsls	r3, r3, #23
 80018d8:	2120      	movs	r1, #32
 80018da:	438a      	bics	r2, r1
 80018dc:	605a      	str	r2, [r3, #4]
    GPIOA->OTYPER &= ~GPIO_OTYPER_OT_6;
 80018de:	2390      	movs	r3, #144	; 0x90
 80018e0:	05db      	lsls	r3, r3, #23
 80018e2:	685a      	ldr	r2, [r3, #4]
 80018e4:	2390      	movs	r3, #144	; 0x90
 80018e6:	05db      	lsls	r3, r3, #23
 80018e8:	2140      	movs	r1, #64	; 0x40
 80018ea:	438a      	bics	r2, r1
 80018ec:	605a      	str	r2, [r3, #4]
    GPIOA->OTYPER &= ~GPIO_OTYPER_OT_7;
 80018ee:	2390      	movs	r3, #144	; 0x90
 80018f0:	05db      	lsls	r3, r3, #23
 80018f2:	685a      	ldr	r2, [r3, #4]
 80018f4:	2390      	movs	r3, #144	; 0x90
 80018f6:	05db      	lsls	r3, r3, #23
 80018f8:	2180      	movs	r1, #128	; 0x80
 80018fa:	438a      	bics	r2, r1
 80018fc:	605a      	str	r2, [r3, #4]

    /* PA5 in AF0 (SPI1_SCK) */
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL5_3;
 80018fe:	2390      	movs	r3, #144	; 0x90
 8001900:	05db      	lsls	r3, r3, #23
 8001902:	6a1a      	ldr	r2, [r3, #32]
 8001904:	2390      	movs	r3, #144	; 0x90
 8001906:	05db      	lsls	r3, r3, #23
 8001908:	4933      	ldr	r1, [pc, #204]	; (80019d8 <SPI1_GPIO_Init+0x1b4>)
 800190a:	400a      	ands	r2, r1
 800190c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL5_2;
 800190e:	2390      	movs	r3, #144	; 0x90
 8001910:	05db      	lsls	r3, r3, #23
 8001912:	6a1a      	ldr	r2, [r3, #32]
 8001914:	2390      	movs	r3, #144	; 0x90
 8001916:	05db      	lsls	r3, r3, #23
 8001918:	4930      	ldr	r1, [pc, #192]	; (80019dc <SPI1_GPIO_Init+0x1b8>)
 800191a:	400a      	ands	r2, r1
 800191c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL5_1;
 800191e:	2390      	movs	r3, #144	; 0x90
 8001920:	05db      	lsls	r3, r3, #23
 8001922:	6a1a      	ldr	r2, [r3, #32]
 8001924:	2390      	movs	r3, #144	; 0x90
 8001926:	05db      	lsls	r3, r3, #23
 8001928:	492d      	ldr	r1, [pc, #180]	; (80019e0 <SPI1_GPIO_Init+0x1bc>)
 800192a:	400a      	ands	r2, r1
 800192c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL5_0;
 800192e:	2390      	movs	r3, #144	; 0x90
 8001930:	05db      	lsls	r3, r3, #23
 8001932:	6a1a      	ldr	r2, [r3, #32]
 8001934:	2390      	movs	r3, #144	; 0x90
 8001936:	05db      	lsls	r3, r3, #23
 8001938:	492a      	ldr	r1, [pc, #168]	; (80019e4 <SPI1_GPIO_Init+0x1c0>)
 800193a:	400a      	ands	r2, r1
 800193c:	621a      	str	r2, [r3, #32]

    /* PA6 in AF0 (SPI1_MISO) */
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL6_3;
 800193e:	2390      	movs	r3, #144	; 0x90
 8001940:	05db      	lsls	r3, r3, #23
 8001942:	6a1a      	ldr	r2, [r3, #32]
 8001944:	2390      	movs	r3, #144	; 0x90
 8001946:	05db      	lsls	r3, r3, #23
 8001948:	4927      	ldr	r1, [pc, #156]	; (80019e8 <SPI1_GPIO_Init+0x1c4>)
 800194a:	400a      	ands	r2, r1
 800194c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL6_2;
 800194e:	2390      	movs	r3, #144	; 0x90
 8001950:	05db      	lsls	r3, r3, #23
 8001952:	6a1a      	ldr	r2, [r3, #32]
 8001954:	2390      	movs	r3, #144	; 0x90
 8001956:	05db      	lsls	r3, r3, #23
 8001958:	4924      	ldr	r1, [pc, #144]	; (80019ec <SPI1_GPIO_Init+0x1c8>)
 800195a:	400a      	ands	r2, r1
 800195c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL6_1;
 800195e:	2390      	movs	r3, #144	; 0x90
 8001960:	05db      	lsls	r3, r3, #23
 8001962:	6a1a      	ldr	r2, [r3, #32]
 8001964:	2390      	movs	r3, #144	; 0x90
 8001966:	05db      	lsls	r3, r3, #23
 8001968:	4921      	ldr	r1, [pc, #132]	; (80019f0 <SPI1_GPIO_Init+0x1cc>)
 800196a:	400a      	ands	r2, r1
 800196c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL6_0;
 800196e:	2390      	movs	r3, #144	; 0x90
 8001970:	05db      	lsls	r3, r3, #23
 8001972:	6a1a      	ldr	r2, [r3, #32]
 8001974:	2390      	movs	r3, #144	; 0x90
 8001976:	05db      	lsls	r3, r3, #23
 8001978:	491e      	ldr	r1, [pc, #120]	; (80019f4 <SPI1_GPIO_Init+0x1d0>)
 800197a:	400a      	ands	r2, r1
 800197c:	621a      	str	r2, [r3, #32]

    /* PA7 in AF0 (SPI1_MOSI) */
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL7_3;
 800197e:	2390      	movs	r3, #144	; 0x90
 8001980:	05db      	lsls	r3, r3, #23
 8001982:	6a1a      	ldr	r2, [r3, #32]
 8001984:	2390      	movs	r3, #144	; 0x90
 8001986:	05db      	lsls	r3, r3, #23
 8001988:	0052      	lsls	r2, r2, #1
 800198a:	0852      	lsrs	r2, r2, #1
 800198c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL7_2;
 800198e:	2390      	movs	r3, #144	; 0x90
 8001990:	05db      	lsls	r3, r3, #23
 8001992:	6a1a      	ldr	r2, [r3, #32]
 8001994:	2390      	movs	r3, #144	; 0x90
 8001996:	05db      	lsls	r3, r3, #23
 8001998:	4917      	ldr	r1, [pc, #92]	; (80019f8 <SPI1_GPIO_Init+0x1d4>)
 800199a:	400a      	ands	r2, r1
 800199c:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL7_1;
 800199e:	2390      	movs	r3, #144	; 0x90
 80019a0:	05db      	lsls	r3, r3, #23
 80019a2:	6a1a      	ldr	r2, [r3, #32]
 80019a4:	2390      	movs	r3, #144	; 0x90
 80019a6:	05db      	lsls	r3, r3, #23
 80019a8:	4914      	ldr	r1, [pc, #80]	; (80019fc <SPI1_GPIO_Init+0x1d8>)
 80019aa:	400a      	ands	r2, r1
 80019ac:	621a      	str	r2, [r3, #32]
    GPIOA->AFR[ 0 ] &= ~GPIO_AFRL_AFSEL7_0;
 80019ae:	2390      	movs	r3, #144	; 0x90
 80019b0:	05db      	lsls	r3, r3, #23
 80019b2:	6a1a      	ldr	r2, [r3, #32]
 80019b4:	2390      	movs	r3, #144	; 0x90
 80019b6:	05db      	lsls	r3, r3, #23
 80019b8:	4911      	ldr	r1, [pc, #68]	; (8001a00 <SPI1_GPIO_Init+0x1dc>)
 80019ba:	400a      	ands	r2, r1
 80019bc:	621a      	str	r2, [r3, #32]
}
 80019be:	46c0      	nop			; (mov r8, r8)
 80019c0:	46bd      	mov	sp, r7
 80019c2:	bd80      	pop	{r7, pc}
 80019c4:	40021000 	.word	0x40021000
 80019c8:	fffffdff 	.word	0xfffffdff
 80019cc:	fffffbff 	.word	0xfffffbff
 80019d0:	ffffefff 	.word	0xffffefff
 80019d4:	ffffbfff 	.word	0xffffbfff
 80019d8:	ff7fffff 	.word	0xff7fffff
 80019dc:	ffbfffff 	.word	0xffbfffff
 80019e0:	ffdfffff 	.word	0xffdfffff
 80019e4:	ffefffff 	.word	0xffefffff
 80019e8:	f7ffffff 	.word	0xf7ffffff
 80019ec:	fbffffff 	.word	0xfbffffff
 80019f0:	fdffffff 	.word	0xfdffffff
 80019f4:	feffffff 	.word	0xfeffffff
 80019f8:	bfffffff 	.word	0xbfffffff
 80019fc:	dfffffff 	.word	0xdfffffff
 8001a00:	efffffff 	.word	0xefffffff

08001a04 <SPI1_Init>:

void SPI1_Init( void )
{   
 8001a04:	b580      	push	{r7, lr}
 8001a06:	af00      	add	r7, sp, #0
    /* Enable GPIO resources for SPI1 */
    SPI1_GPIO_Init();
 8001a08:	f7ff ff0c 	bl	8001824 <SPI1_GPIO_Init>
   
    /* Enable SPI1 clock access */
    SPI1_CLK_ENBL();
 8001a0c:	4b44      	ldr	r3, [pc, #272]	; (8001b20 <SPI1_Init+0x11c>)
 8001a0e:	699a      	ldr	r2, [r3, #24]
 8001a10:	4b43      	ldr	r3, [pc, #268]	; (8001b20 <SPI1_Init+0x11c>)
 8001a12:	2180      	movs	r1, #128	; 0x80
 8001a14:	0149      	lsls	r1, r1, #5
 8001a16:	430a      	orrs	r2, r1
 8001a18:	619a      	str	r2, [r3, #24]

    /* SPI1 2-line unidirectional data mode */
    SPI1->CR1 &= ~SPI_CR1_BIDIMODE;
 8001a1a:	4b42      	ldr	r3, [pc, #264]	; (8001b24 <SPI1_Init+0x120>)
 8001a1c:	681a      	ldr	r2, [r3, #0]
 8001a1e:	4b41      	ldr	r3, [pc, #260]	; (8001b24 <SPI1_Init+0x120>)
 8001a20:	4941      	ldr	r1, [pc, #260]	; (8001b28 <SPI1_Init+0x124>)
 8001a22:	400a      	ands	r2, r1
 8001a24:	601a      	str	r2, [r3, #0]
    
    /* SPI1 CRC disabled */
    SPI1->CR1 &= ~SPI_CR1_CRCEN;
 8001a26:	4b3f      	ldr	r3, [pc, #252]	; (8001b24 <SPI1_Init+0x120>)
 8001a28:	681a      	ldr	r2, [r3, #0]
 8001a2a:	4b3e      	ldr	r3, [pc, #248]	; (8001b24 <SPI1_Init+0x120>)
 8001a2c:	493f      	ldr	r1, [pc, #252]	; (8001b2c <SPI1_Init+0x128>)
 8001a2e:	400a      	ands	r2, r1
 8001a30:	601a      	str	r2, [r3, #0]

    /* SPI1 in full-duplex mode */
    SPI1->CR1 &= ~SPI_CR1_RXONLY;
 8001a32:	4b3c      	ldr	r3, [pc, #240]	; (8001b24 <SPI1_Init+0x120>)
 8001a34:	681a      	ldr	r2, [r3, #0]
 8001a36:	4b3b      	ldr	r3, [pc, #236]	; (8001b24 <SPI1_Init+0x120>)
 8001a38:	493d      	ldr	r1, [pc, #244]	; (8001b30 <SPI1_Init+0x12c>)
 8001a3a:	400a      	ands	r2, r1
 8001a3c:	601a      	str	r2, [r3, #0]

    /* SPI1 software slave management disabled */
    SPI1->CR1 &= SPI_CR1_SSM;
 8001a3e:	4b39      	ldr	r3, [pc, #228]	; (8001b24 <SPI1_Init+0x120>)
 8001a40:	6819      	ldr	r1, [r3, #0]
 8001a42:	4b38      	ldr	r3, [pc, #224]	; (8001b24 <SPI1_Init+0x120>)
 8001a44:	2280      	movs	r2, #128	; 0x80
 8001a46:	0092      	lsls	r2, r2, #2
 8001a48:	400a      	ands	r2, r1
 8001a4a:	601a      	str	r2, [r3, #0]

    /* SPI1 MSB transmitted/received first */
    SPI1->CR1 &= ~SPI_CR1_LSBFIRST;
 8001a4c:	4b35      	ldr	r3, [pc, #212]	; (8001b24 <SPI1_Init+0x120>)
 8001a4e:	681a      	ldr	r2, [r3, #0]
 8001a50:	4b34      	ldr	r3, [pc, #208]	; (8001b24 <SPI1_Init+0x120>)
 8001a52:	2180      	movs	r1, #128	; 0x80
 8001a54:	438a      	bics	r2, r1
 8001a56:	601a      	str	r2, [r3, #0]

    /* SPI1 baud rate fPCLK/4.
       With fPCLK = 20 MHz,
       therefore SPI1 baud = 5 MHz */
    SPI1->CR1 &= ~SPI_CR1_BR_2;
 8001a58:	4b32      	ldr	r3, [pc, #200]	; (8001b24 <SPI1_Init+0x120>)
 8001a5a:	681a      	ldr	r2, [r3, #0]
 8001a5c:	4b31      	ldr	r3, [pc, #196]	; (8001b24 <SPI1_Init+0x120>)
 8001a5e:	2120      	movs	r1, #32
 8001a60:	438a      	bics	r2, r1
 8001a62:	601a      	str	r2, [r3, #0]
    SPI1->CR1 &= ~SPI_CR1_BR_1;
 8001a64:	4b2f      	ldr	r3, [pc, #188]	; (8001b24 <SPI1_Init+0x120>)
 8001a66:	681a      	ldr	r2, [r3, #0]
 8001a68:	4b2e      	ldr	r3, [pc, #184]	; (8001b24 <SPI1_Init+0x120>)
 8001a6a:	2110      	movs	r1, #16
 8001a6c:	438a      	bics	r2, r1
 8001a6e:	601a      	str	r2, [r3, #0]
    SPI1->CR1 |=  SPI_CR1_BR_0;
 8001a70:	4b2c      	ldr	r3, [pc, #176]	; (8001b24 <SPI1_Init+0x120>)
 8001a72:	681a      	ldr	r2, [r3, #0]
 8001a74:	4b2b      	ldr	r3, [pc, #172]	; (8001b24 <SPI1_Init+0x120>)
 8001a76:	2108      	movs	r1, #8
 8001a78:	430a      	orrs	r2, r1
 8001a7a:	601a      	str	r2, [r3, #0]

    /* SPI1 as master */
    SPI1->CR1 |= SPI_CR1_MSTR;
 8001a7c:	4b29      	ldr	r3, [pc, #164]	; (8001b24 <SPI1_Init+0x120>)
 8001a7e:	681a      	ldr	r2, [r3, #0]
 8001a80:	4b28      	ldr	r3, [pc, #160]	; (8001b24 <SPI1_Init+0x120>)
 8001a82:	2104      	movs	r1, #4
 8001a84:	430a      	orrs	r2, r1
 8001a86:	601a      	str	r2, [r3, #0]

    /* SPI1 clock is HIGH when idle */
    SPI1->CR1 |= SPI_CR1_CPOL;
 8001a88:	4b26      	ldr	r3, [pc, #152]	; (8001b24 <SPI1_Init+0x120>)
 8001a8a:	681a      	ldr	r2, [r3, #0]
 8001a8c:	4b25      	ldr	r3, [pc, #148]	; (8001b24 <SPI1_Init+0x120>)
 8001a8e:	2102      	movs	r1, #2
 8001a90:	430a      	orrs	r2, r1
 8001a92:	601a      	str	r2, [r3, #0]

    /* SPI1 clock phase, 1st clock transition is the
       1st data capture edge */
    SPI1->CR1 |= SPI_CR1_CPHA;
 8001a94:	4b23      	ldr	r3, [pc, #140]	; (8001b24 <SPI1_Init+0x120>)
 8001a96:	681a      	ldr	r2, [r3, #0]
 8001a98:	4b22      	ldr	r3, [pc, #136]	; (8001b24 <SPI1_Init+0x120>)
 8001a9a:	2101      	movs	r1, #1
 8001a9c:	430a      	orrs	r2, r1
 8001a9e:	601a      	str	r2, [r3, #0]

    /* SPI1 RXNE event generated if FIFO >= 8 bits */
    SPI1->CR2 |= SPI_CR2_FRXTH;
 8001aa0:	4b20      	ldr	r3, [pc, #128]	; (8001b24 <SPI1_Init+0x120>)
 8001aa2:	685a      	ldr	r2, [r3, #4]
 8001aa4:	4b1f      	ldr	r3, [pc, #124]	; (8001b24 <SPI1_Init+0x120>)
 8001aa6:	2180      	movs	r1, #128	; 0x80
 8001aa8:	0149      	lsls	r1, r1, #5
 8001aaa:	430a      	orrs	r2, r1
 8001aac:	605a      	str	r2, [r3, #4]

    /* SPI1 8 bits Data size */
    SPI1->CR2 &= ~SPI_CR2_DS_3;
 8001aae:	4b1d      	ldr	r3, [pc, #116]	; (8001b24 <SPI1_Init+0x120>)
 8001ab0:	685a      	ldr	r2, [r3, #4]
 8001ab2:	4b1c      	ldr	r3, [pc, #112]	; (8001b24 <SPI1_Init+0x120>)
 8001ab4:	491f      	ldr	r1, [pc, #124]	; (8001b34 <SPI1_Init+0x130>)
 8001ab6:	400a      	ands	r2, r1
 8001ab8:	605a      	str	r2, [r3, #4]
    SPI1->CR2 |=  SPI_CR2_DS_2;
 8001aba:	4b1a      	ldr	r3, [pc, #104]	; (8001b24 <SPI1_Init+0x120>)
 8001abc:	685a      	ldr	r2, [r3, #4]
 8001abe:	4b19      	ldr	r3, [pc, #100]	; (8001b24 <SPI1_Init+0x120>)
 8001ac0:	2180      	movs	r1, #128	; 0x80
 8001ac2:	00c9      	lsls	r1, r1, #3
 8001ac4:	430a      	orrs	r2, r1
 8001ac6:	605a      	str	r2, [r3, #4]
    SPI1->CR2 |=  SPI_CR2_DS_1;
 8001ac8:	4b16      	ldr	r3, [pc, #88]	; (8001b24 <SPI1_Init+0x120>)
 8001aca:	685a      	ldr	r2, [r3, #4]
 8001acc:	4b15      	ldr	r3, [pc, #84]	; (8001b24 <SPI1_Init+0x120>)
 8001ace:	2180      	movs	r1, #128	; 0x80
 8001ad0:	0089      	lsls	r1, r1, #2
 8001ad2:	430a      	orrs	r2, r1
 8001ad4:	605a      	str	r2, [r3, #4]
    SPI1->CR2 |=  SPI_CR2_DS_0;
 8001ad6:	4b13      	ldr	r3, [pc, #76]	; (8001b24 <SPI1_Init+0x120>)
 8001ad8:	685a      	ldr	r2, [r3, #4]
 8001ada:	4b12      	ldr	r3, [pc, #72]	; (8001b24 <SPI1_Init+0x120>)
 8001adc:	2180      	movs	r1, #128	; 0x80
 8001ade:	0049      	lsls	r1, r1, #1
 8001ae0:	430a      	orrs	r2, r1
 8001ae2:	605a      	str	r2, [r3, #4]

    /* SPI1 Motorola mode frame format */
    SPI1->CR2 &= ~SPI_CR2_FRF;
 8001ae4:	4b0f      	ldr	r3, [pc, #60]	; (8001b24 <SPI1_Init+0x120>)
 8001ae6:	685a      	ldr	r2, [r3, #4]
 8001ae8:	4b0e      	ldr	r3, [pc, #56]	; (8001b24 <SPI1_Init+0x120>)
 8001aea:	2110      	movs	r1, #16
 8001aec:	438a      	bics	r2, r1
 8001aee:	605a      	str	r2, [r3, #4]

    /* SPI1 no NSS pulse */
    SPI1->CR2 &= ~SPI_CR2_NSSP;
 8001af0:	4b0c      	ldr	r3, [pc, #48]	; (8001b24 <SPI1_Init+0x120>)
 8001af2:	685a      	ldr	r2, [r3, #4]
 8001af4:	4b0b      	ldr	r3, [pc, #44]	; (8001b24 <SPI1_Init+0x120>)
 8001af6:	2108      	movs	r1, #8
 8001af8:	438a      	bics	r2, r1
 8001afa:	605a      	str	r2, [r3, #4]

    /* SPI1 SS output enabled */
    SPI1->CR2 |= SPI_CR2_SSOE;
 8001afc:	4b09      	ldr	r3, [pc, #36]	; (8001b24 <SPI1_Init+0x120>)
 8001afe:	685a      	ldr	r2, [r3, #4]
 8001b00:	4b08      	ldr	r3, [pc, #32]	; (8001b24 <SPI1_Init+0x120>)
 8001b02:	2104      	movs	r1, #4
 8001b04:	430a      	orrs	r2, r1
 8001b06:	605a      	str	r2, [r3, #4]

    /* Set CS pin to IDLE state (HIGH) */
    SPI1_CS_Disable();
 8001b08:	f000 f816 	bl	8001b38 <SPI1_CS_Disable>

    /* enable SPI1 */
    SPI1->CR1 |= SPI_CR1_SPE;
 8001b0c:	4b05      	ldr	r3, [pc, #20]	; (8001b24 <SPI1_Init+0x120>)
 8001b0e:	681a      	ldr	r2, [r3, #0]
 8001b10:	4b04      	ldr	r3, [pc, #16]	; (8001b24 <SPI1_Init+0x120>)
 8001b12:	2140      	movs	r1, #64	; 0x40
 8001b14:	430a      	orrs	r2, r1
 8001b16:	601a      	str	r2, [r3, #0]
}
 8001b18:	46c0      	nop			; (mov r8, r8)
 8001b1a:	46bd      	mov	sp, r7
 8001b1c:	bd80      	pop	{r7, pc}
 8001b1e:	46c0      	nop			; (mov r8, r8)
 8001b20:	40021000 	.word	0x40021000
 8001b24:	40013000 	.word	0x40013000
 8001b28:	ffff7fff 	.word	0xffff7fff
 8001b2c:	ffffdfff 	.word	0xffffdfff
 8001b30:	fffffbff 	.word	0xfffffbff
 8001b34:	fffff7ff 	.word	0xfffff7ff

08001b38 <SPI1_CS_Disable>:

void SPI1_CS_Disable( void )
{
 8001b38:	b580      	push	{r7, lr}
 8001b3a:	af00      	add	r7, sp, #0
    /* Set SPI1 CS pin to IDLE state (HIGH) */
    GPIOA->ODR |= GPIO_ODR_4;
 8001b3c:	2390      	movs	r3, #144	; 0x90
 8001b3e:	05db      	lsls	r3, r3, #23
 8001b40:	695a      	ldr	r2, [r3, #20]
 8001b42:	2390      	movs	r3, #144	; 0x90
 8001b44:	05db      	lsls	r3, r3, #23
 8001b46:	2110      	movs	r1, #16
 8001b48:	430a      	orrs	r2, r1
 8001b4a:	615a      	str	r2, [r3, #20]
}
 8001b4c:	46c0      	nop			; (mov r8, r8)
 8001b4e:	46bd      	mov	sp, r7
 8001b50:	bd80      	pop	{r7, pc}

08001b52 <SPI1_CS_Enable>:

void SPI1_CS_Enable( void )
{
 8001b52:	b580      	push	{r7, lr}
 8001b54:	af00      	add	r7, sp, #0
    /* Set SPI1 CS pin to LOW state (slave selected) */
    GPIOA->ODR &= ~GPIO_ODR_4;
 8001b56:	2390      	movs	r3, #144	; 0x90
 8001b58:	05db      	lsls	r3, r3, #23
 8001b5a:	695a      	ldr	r2, [r3, #20]
 8001b5c:	2390      	movs	r3, #144	; 0x90
 8001b5e:	05db      	lsls	r3, r3, #23
 8001b60:	2110      	movs	r1, #16
 8001b62:	438a      	bics	r2, r1
 8001b64:	615a      	str	r2, [r3, #20]
}
 8001b66:	46c0      	nop			; (mov r8, r8)
 8001b68:	46bd      	mov	sp, r7
 8001b6a:	bd80      	pop	{r7, pc}

08001b6c <SPI1_Write>:

void SPI1_Write( uint8_t *data, uint8_t size )
{
 8001b6c:	b580      	push	{r7, lr}
 8001b6e:	b084      	sub	sp, #16
 8001b70:	af00      	add	r7, sp, #0
 8001b72:	6078      	str	r0, [r7, #4]
 8001b74:	000a      	movs	r2, r1
 8001b76:	1cfb      	adds	r3, r7, #3
 8001b78:	701a      	strb	r2, [r3, #0]
    uint8_t item;
    uint8_t temp;

    /* Wait for SPI1 bus to be free */
    while ( ( SPI1->SR & SPI_SR_BSY ) == SPI_SR_BSY )
 8001b7a:	46c0      	nop			; (mov r8, r8)
 8001b7c:	4b20      	ldr	r3, [pc, #128]	; (8001c00 <SPI1_Write+0x94>)
 8001b7e:	689b      	ldr	r3, [r3, #8]
 8001b80:	2280      	movs	r2, #128	; 0x80
 8001b82:	4013      	ands	r3, r2
 8001b84:	2b80      	cmp	r3, #128	; 0x80
 8001b86:	d0f9      	beq.n	8001b7c <SPI1_Write+0x10>
    {
        /* Do nothing */
    }
    
    /* Loop through the data array */
    for ( item = 0U; item < size; item++ )
 8001b88:	230f      	movs	r3, #15
 8001b8a:	18fb      	adds	r3, r7, r3
 8001b8c:	2200      	movs	r2, #0
 8001b8e:	701a      	strb	r2, [r3, #0]
 8001b90:	e01e      	b.n	8001bd0 <SPI1_Write+0x64>
    {   
        /* Send current byte from the data array */
        *( uint8_t * )( &( SPI1->DR ) ) = data[ item ];
 8001b92:	230f      	movs	r3, #15
 8001b94:	18fb      	adds	r3, r7, r3
 8001b96:	781b      	ldrb	r3, [r3, #0]
 8001b98:	687a      	ldr	r2, [r7, #4]
 8001b9a:	18d3      	adds	r3, r2, r3
 8001b9c:	4a19      	ldr	r2, [pc, #100]	; (8001c04 <SPI1_Write+0x98>)
 8001b9e:	781b      	ldrb	r3, [r3, #0]
 8001ba0:	7013      	strb	r3, [r2, #0]

        /* Wait for SPI1 transmit buffer to be empty */
        while ( ( SPI1->SR & SPI_SR_TXE ) == 0U )
 8001ba2:	46c0      	nop			; (mov r8, r8)
 8001ba4:	4b16      	ldr	r3, [pc, #88]	; (8001c00 <SPI1_Write+0x94>)
 8001ba6:	689b      	ldr	r3, [r3, #8]
 8001ba8:	2202      	movs	r2, #2
 8001baa:	4013      	ands	r3, r2
 8001bac:	d0fa      	beq.n	8001ba4 <SPI1_Write+0x38>
                 therefore for each data sent over MISO, data received in the MISO
                 pin is sampled every clock cycle, meaning that we send and receive
                 data at the same time although that may not what we intend. */

        /* Wait for RX buffer to receive 1 byte data (FRXTH = 1) */
        while ( ( SPI1->SR & SPI_SR_RXNE ) == 0U )
 8001bae:	46c0      	nop			; (mov r8, r8)
 8001bb0:	4b13      	ldr	r3, [pc, #76]	; (8001c00 <SPI1_Write+0x94>)
 8001bb2:	689b      	ldr	r3, [r3, #8]
 8001bb4:	2201      	movs	r2, #1
 8001bb6:	4013      	ands	r3, r2
 8001bb8:	d0fa      	beq.n	8001bb0 <SPI1_Write+0x44>
        }

        /* Store data read on MISO (this data will be ignored and not used)
           in order to clear the RX buffer. Also by reading data the 
           RXNE flag (receive buffer not empty) is automatically cleared */
        temp = ( uint8_t )( SPI1->DR );
 8001bba:	4b11      	ldr	r3, [pc, #68]	; (8001c00 <SPI1_Write+0x94>)
 8001bbc:	68da      	ldr	r2, [r3, #12]
 8001bbe:	230e      	movs	r3, #14
 8001bc0:	18fb      	adds	r3, r7, r3
 8001bc2:	701a      	strb	r2, [r3, #0]
    for ( item = 0U; item < size; item++ )
 8001bc4:	210f      	movs	r1, #15
 8001bc6:	187b      	adds	r3, r7, r1
 8001bc8:	781a      	ldrb	r2, [r3, #0]
 8001bca:	187b      	adds	r3, r7, r1
 8001bcc:	3201      	adds	r2, #1
 8001bce:	701a      	strb	r2, [r3, #0]
 8001bd0:	230f      	movs	r3, #15
 8001bd2:	18fa      	adds	r2, r7, r3
 8001bd4:	1cfb      	adds	r3, r7, #3
 8001bd6:	7812      	ldrb	r2, [r2, #0]
 8001bd8:	781b      	ldrb	r3, [r3, #0]
 8001bda:	429a      	cmp	r2, r3
 8001bdc:	d3d9      	bcc.n	8001b92 <SPI1_Write+0x26>
    }
      
    /* Wait for SPI1 bus to be free */
    while ( ( SPI1->SR & SPI_SR_BSY ) == SPI_SR_BSY )
 8001bde:	46c0      	nop			; (mov r8, r8)
 8001be0:	4b07      	ldr	r3, [pc, #28]	; (8001c00 <SPI1_Write+0x94>)
 8001be2:	689b      	ldr	r3, [r3, #8]
 8001be4:	2280      	movs	r2, #128	; 0x80
 8001be6:	4013      	ands	r3, r2
 8001be8:	2b80      	cmp	r3, #128	; 0x80
 8001bea:	d0f9      	beq.n	8001be0 <SPI1_Write+0x74>
        /* Do nothing */
    }

    /* Clear the overrun flag just in case the buffer is full and 
       attempt to store more receiving data on MISO is made */
    SPI1->SR &= ~SPI_SR_OVR;
 8001bec:	4b04      	ldr	r3, [pc, #16]	; (8001c00 <SPI1_Write+0x94>)
 8001bee:	689a      	ldr	r2, [r3, #8]
 8001bf0:	4b03      	ldr	r3, [pc, #12]	; (8001c00 <SPI1_Write+0x94>)
 8001bf2:	2140      	movs	r1, #64	; 0x40
 8001bf4:	438a      	bics	r2, r1
 8001bf6:	609a      	str	r2, [r3, #8]
}
 8001bf8:	46c0      	nop			; (mov r8, r8)
 8001bfa:	46bd      	mov	sp, r7
 8001bfc:	b004      	add	sp, #16
 8001bfe:	bd80      	pop	{r7, pc}
 8001c00:	40013000 	.word	0x40013000
 8001c04:	4001300c 	.word	0x4001300c

08001c08 <SPI1_Read>:

void SPI1_Read( uint8_t *read, uint8_t size )
{   
 8001c08:	b580      	push	{r7, lr}
 8001c0a:	b084      	sub	sp, #16
 8001c0c:	af00      	add	r7, sp, #0
 8001c0e:	6078      	str	r0, [r7, #4]
 8001c10:	000a      	movs	r2, r1
 8001c12:	1cfb      	adds	r3, r7, #3
 8001c14:	701a      	strb	r2, [r3, #0]
             therefore for each data sent over MISO, data received in the MISO
             pin is sampled every clock cycle, meaning that we send and receive
             data at the same time although that may not what we intend. */
    
    /* Store each data byte into the array */
    for ( item = 0; item < size; item++, read++ )
 8001c16:	230f      	movs	r3, #15
 8001c18:	18fb      	adds	r3, r7, r3
 8001c1a:	2200      	movs	r2, #0
 8001c1c:	701a      	strb	r2, [r3, #0]
 8001c1e:	e016      	b.n	8001c4e <SPI1_Read+0x46>
    {
        /* Send dummy data (this allows us to receive data on MISO) */
        *( uint8_t * )( &( SPI1->DR ) ) = 0U;
 8001c20:	4b11      	ldr	r3, [pc, #68]	; (8001c68 <SPI1_Read+0x60>)
 8001c22:	2200      	movs	r2, #0
 8001c24:	701a      	strb	r2, [r3, #0]

        /* Wait for RX buffer to receive data */
        while ( ( SPI1->SR & SPI_SR_RXNE ) == 0U )
 8001c26:	46c0      	nop			; (mov r8, r8)
 8001c28:	4b10      	ldr	r3, [pc, #64]	; (8001c6c <SPI1_Read+0x64>)
 8001c2a:	689b      	ldr	r3, [r3, #8]
 8001c2c:	2201      	movs	r2, #1
 8001c2e:	4013      	ands	r3, r2
 8001c30:	d0fa      	beq.n	8001c28 <SPI1_Read+0x20>
        {
            /* Do nothing */
        }

        /* Store received byte (this also clears the SPI1 RX buffer not empty flag) */
        *read = ( uint8_t )( SPI1->DR );
 8001c32:	4b0e      	ldr	r3, [pc, #56]	; (8001c6c <SPI1_Read+0x64>)
 8001c34:	68db      	ldr	r3, [r3, #12]
 8001c36:	b2da      	uxtb	r2, r3
 8001c38:	687b      	ldr	r3, [r7, #4]
 8001c3a:	701a      	strb	r2, [r3, #0]
    for ( item = 0; item < size; item++, read++ )
 8001c3c:	210f      	movs	r1, #15
 8001c3e:	187b      	adds	r3, r7, r1
 8001c40:	781a      	ldrb	r2, [r3, #0]
 8001c42:	187b      	adds	r3, r7, r1
 8001c44:	3201      	adds	r2, #1
 8001c46:	701a      	strb	r2, [r3, #0]
 8001c48:	687b      	ldr	r3, [r7, #4]
 8001c4a:	3301      	adds	r3, #1
 8001c4c:	607b      	str	r3, [r7, #4]
 8001c4e:	230f      	movs	r3, #15
 8001c50:	18fa      	adds	r2, r7, r3
 8001c52:	1cfb      	adds	r3, r7, #3
 8001c54:	7812      	ldrb	r2, [r2, #0]
 8001c56:	781b      	ldrb	r3, [r3, #0]
 8001c58:	429a      	cmp	r2, r3
 8001c5a:	d3e1      	bcc.n	8001c20 <SPI1_Read+0x18>
    }
}
 8001c5c:	46c0      	nop			; (mov r8, r8)
 8001c5e:	46c0      	nop			; (mov r8, r8)
 8001c60:	46bd      	mov	sp, r7
 8001c62:	b004      	add	sp, #16
 8001c64:	bd80      	pop	{r7, pc}
 8001c66:	46c0      	nop			; (mov r8, r8)
 8001c68:	4001300c 	.word	0x4001300c
 8001c6c:	40013000 	.word	0x40013000

08001c70 <ADXL345_Write>:
#include "accelerometer.h"

void ADXL345_Write( uint8_t reg_addr, uint8_t data )
{
 8001c70:	b590      	push	{r4, r7, lr}
 8001c72:	b085      	sub	sp, #20
 8001c74:	af00      	add	r7, sp, #0
 8001c76:	0002      	movs	r2, r0
 8001c78:	1dfb      	adds	r3, r7, #7
 8001c7a:	701a      	strb	r2, [r3, #0]
 8001c7c:	1dbb      	adds	r3, r7, #6
 8001c7e:	1c0a      	adds	r2, r1, #0
 8001c80:	701a      	strb	r2, [r3, #0]
    uint8_t spi1_write[ 2 ];

    /* Write bit (0) + multiple bit (0) + register address */
    spi1_write[ 0 ] = SPI_WRITE | MULTIPLE_BYTE_DISABLED | ( reg_addr & REG_ADDRESS_MASK );
 8001c82:	1dfb      	adds	r3, r7, #7
 8001c84:	781b      	ldrb	r3, [r3, #0]
 8001c86:	223f      	movs	r2, #63	; 0x3f
 8001c88:	4013      	ands	r3, r2
 8001c8a:	b2da      	uxtb	r2, r3
 8001c8c:	240c      	movs	r4, #12
 8001c8e:	193b      	adds	r3, r7, r4
 8001c90:	701a      	strb	r2, [r3, #0]
    /* Data to be written into reg_addr */
    spi1_write[ 1 ] = data;
 8001c92:	193b      	adds	r3, r7, r4
 8001c94:	1dba      	adds	r2, r7, #6
 8001c96:	7812      	ldrb	r2, [r2, #0]
 8001c98:	705a      	strb	r2, [r3, #1]

    /* Send instruction over SPI1 to the ADXL345 */
    SPI1_CS_Enable();
 8001c9a:	f7ff ff5a 	bl	8001b52 <SPI1_CS_Enable>
    SPI1_Write( spi1_write, 2U );
 8001c9e:	193b      	adds	r3, r7, r4
 8001ca0:	2102      	movs	r1, #2
 8001ca2:	0018      	movs	r0, r3
 8001ca4:	f7ff ff62 	bl	8001b6c <SPI1_Write>
    SPI1_CS_Disable();
 8001ca8:	f7ff ff46 	bl	8001b38 <SPI1_CS_Disable>
}
 8001cac:	46c0      	nop			; (mov r8, r8)
 8001cae:	46bd      	mov	sp, r7
 8001cb0:	b005      	add	sp, #20
 8001cb2:	bd90      	pop	{r4, r7, pc}

08001cb4 <ADXL345_Read>:

uint8_t ADXL345_Read( uint8_t reg_addr )
{
 8001cb4:	b590      	push	{r4, r7, lr}
 8001cb6:	b085      	sub	sp, #20
 8001cb8:	af00      	add	r7, sp, #0
 8001cba:	0002      	movs	r2, r0
 8001cbc:	1dfb      	adds	r3, r7, #7
 8001cbe:	701a      	strb	r2, [r3, #0]
    uint8_t spi1_write;
    uint8_t spi1_read;

    /* Read bit (0) + multiple bit (0) + register address */
    spi1_write = SPI_READ | MULTIPLE_BYTE_DISABLED | ( reg_addr & REG_ADDRESS_MASK );
 8001cc0:	1dfb      	adds	r3, r7, #7
 8001cc2:	781b      	ldrb	r3, [r3, #0]
 8001cc4:	223f      	movs	r2, #63	; 0x3f
 8001cc6:	4013      	ands	r3, r2
 8001cc8:	b2db      	uxtb	r3, r3
 8001cca:	2280      	movs	r2, #128	; 0x80
 8001ccc:	4252      	negs	r2, r2
 8001cce:	4313      	orrs	r3, r2
 8001cd0:	b2da      	uxtb	r2, r3
 8001cd2:	240f      	movs	r4, #15
 8001cd4:	193b      	adds	r3, r7, r4
 8001cd6:	701a      	strb	r2, [r3, #0]

    /* Request reading of specified register and store data read into local variable */
    SPI1_CS_Enable();
 8001cd8:	f7ff ff3b 	bl	8001b52 <SPI1_CS_Enable>
    SPI1_Write( &spi1_write, 1U );
 8001cdc:	193b      	adds	r3, r7, r4
 8001cde:	2101      	movs	r1, #1
 8001ce0:	0018      	movs	r0, r3
 8001ce2:	f7ff ff43 	bl	8001b6c <SPI1_Write>
    SPI1_Read( &spi1_read, 1U );
 8001ce6:	240e      	movs	r4, #14
 8001ce8:	193b      	adds	r3, r7, r4
 8001cea:	2101      	movs	r1, #1
 8001cec:	0018      	movs	r0, r3
 8001cee:	f7ff ff8b 	bl	8001c08 <SPI1_Read>
    SPI1_CS_Disable();
 8001cf2:	f7ff ff21 	bl	8001b38 <SPI1_CS_Disable>

    return spi1_read;
 8001cf6:	193b      	adds	r3, r7, r4
 8001cf8:	781b      	ldrb	r3, [r3, #0]
}
 8001cfa:	0018      	movs	r0, r3
 8001cfc:	46bd      	mov	sp, r7
 8001cfe:	b005      	add	sp, #20
 8001d00:	bd90      	pop	{r4, r7, pc}

08001d02 <ADXL345_Init>:

void ADXL345_Init( ACCEL_HandleTypeDef *haccel )
{
 8001d02:	b580      	push	{r7, lr}
 8001d04:	b082      	sub	sp, #8
 8001d06:	af00      	add	r7, sp, #0
 8001d08:	6078      	str	r0, [r7, #4]
    /* Initialize SPI1 peripheral */
    SPI1_Init();
 8001d0a:	f7ff fe7b 	bl	8001a04 <SPI1_Init>

    /* Set ADXL345 to standby mode */
    ADXL345_Write( POWER_CTL_REG, MEASURE_STANDBY );
 8001d0e:	2100      	movs	r1, #0
 8001d10:	202d      	movs	r0, #45	; 0x2d
 8001d12:	f7ff ffad 	bl	8001c70 <ADXL345_Write>

    /* Configure data format: self test, SPI 3/4 bit mode, interrupt active high/low, 
       full/10bit resolution, right/left justified, 2/4/8/16 g range */
    ADXL345_Write( DATA_FORMAT_REG, haccel->dataformat );
 8001d16:	687b      	ldr	r3, [r7, #4]
 8001d18:	7cdb      	ldrb	r3, [r3, #19]
 8001d1a:	0019      	movs	r1, r3
 8001d1c:	2031      	movs	r0, #49	; 0x31
 8001d1e:	f7ff ffa7 	bl	8001c70 <ADXL345_Write>

    /* Configure power mode and output data rate */
    ADXL345_Write( BW_RATE_REG, haccel->bwrate );
 8001d22:	687b      	ldr	r3, [r7, #4]
 8001d24:	7bdb      	ldrb	r3, [r3, #15]
 8001d26:	0019      	movs	r1, r3
 8001d28:	202c      	movs	r0, #44	; 0x2c
 8001d2a:	f7ff ffa1 	bl	8001c70 <ADXL345_Write>

    /* Configure X, Y and Z axis offset values */
    ADXL345_Write( OFSX_REG, haccel->ofsx );
 8001d2e:	687b      	ldr	r3, [r7, #4]
 8001d30:	789b      	ldrb	r3, [r3, #2]
 8001d32:	0019      	movs	r1, r3
 8001d34:	201e      	movs	r0, #30
 8001d36:	f7ff ff9b 	bl	8001c70 <ADXL345_Write>
    ADXL345_Write( OFSY_REG, haccel->ofsy );
 8001d3a:	687b      	ldr	r3, [r7, #4]
 8001d3c:	78db      	ldrb	r3, [r3, #3]
 8001d3e:	0019      	movs	r1, r3
 8001d40:	201f      	movs	r0, #31
 8001d42:	f7ff ff95 	bl	8001c70 <ADXL345_Write>
    ADXL345_Write( OFSZ_REG, haccel->ofsz );
 8001d46:	687b      	ldr	r3, [r7, #4]
 8001d48:	791b      	ldrb	r3, [r3, #4]
 8001d4a:	0019      	movs	r1, r3
 8001d4c:	2020      	movs	r0, #32
 8001d4e:	f7ff ff8f 	bl	8001c70 <ADXL345_Write>

    /* Map and enable user selected interrupts */
    ADXL345_API_Enable_Int( haccel, haccel->intenable, haccel->intmap );
 8001d52:	687b      	ldr	r3, [r7, #4]
 8001d54:	7c59      	ldrb	r1, [r3, #17]
 8001d56:	687b      	ldr	r3, [r7, #4]
 8001d58:	7c9a      	ldrb	r2, [r3, #18]
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	0018      	movs	r0, r3
 8001d5e:	f000 fb2b 	bl	80023b8 <ADXL345_API_Enable_Int>

    /* If single tap or double tap interrupts are enabled */
    if ( ( ( haccel->intenable & SINGLE_TAP_INT_ENABLED ) == SINGLE_TAP_INT_ENABLED ) || 
 8001d62:	687b      	ldr	r3, [r7, #4]
 8001d64:	7c5b      	ldrb	r3, [r3, #17]
 8001d66:	001a      	movs	r2, r3
 8001d68:	2340      	movs	r3, #64	; 0x40
 8001d6a:	4013      	ands	r3, r2
 8001d6c:	d105      	bne.n	8001d7a <ADXL345_Init+0x78>
         ( ( haccel->intenable & DOUBLE_TAP_INT_ENABLED ) == DOUBLE_TAP_INT_ENABLED ) )
 8001d6e:	687b      	ldr	r3, [r7, #4]
 8001d70:	7c5b      	ldrb	r3, [r3, #17]
 8001d72:	001a      	movs	r2, r3
 8001d74:	2320      	movs	r3, #32
 8001d76:	4013      	ands	r3, r2
    if ( ( ( haccel->intenable & SINGLE_TAP_INT_ENABLED ) == SINGLE_TAP_INT_ENABLED ) || 
 8001d78:	d011      	beq.n	8001d9e <ADXL345_Init+0x9c>
    {
        /* Configure tap threshold */
        ADXL345_Write( THRESH_TAP_REG, haccel->threshtap );
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	785b      	ldrb	r3, [r3, #1]
 8001d7e:	0019      	movs	r1, r3
 8001d80:	201d      	movs	r0, #29
 8001d82:	f7ff ff75 	bl	8001c70 <ADXL345_Write>

        /* Configure tap duration */
        ADXL345_Write( DUR_REG, haccel->dur );
 8001d86:	687b      	ldr	r3, [r7, #4]
 8001d88:	795b      	ldrb	r3, [r3, #5]
 8001d8a:	0019      	movs	r1, r3
 8001d8c:	2021      	movs	r0, #33	; 0x21
 8001d8e:	f7ff ff6f 	bl	8001c70 <ADXL345_Write>

        /* Enable participating axes in tap detection (and double tap supressing if double tap int. enabled) */
        ADXL345_Write( TAP_AXES_REG, haccel->tapaxes );
 8001d92:	687b      	ldr	r3, [r7, #4]
 8001d94:	7b9b      	ldrb	r3, [r3, #14]
 8001d96:	0019      	movs	r1, r3
 8001d98:	202a      	movs	r0, #42	; 0x2a
 8001d9a:	f7ff ff69 	bl	8001c70 <ADXL345_Write>
    }
    
    /* Configure latent and window for double tap detection (if enabled) */
    if ( ( haccel->intenable & DOUBLE_TAP_INT_ENABLED ) == DOUBLE_TAP_INT_ENABLED )
 8001d9e:	687b      	ldr	r3, [r7, #4]
 8001da0:	7c5b      	ldrb	r3, [r3, #17]
 8001da2:	001a      	movs	r2, r3
 8001da4:	2320      	movs	r3, #32
 8001da6:	4013      	ands	r3, r2
 8001da8:	d00b      	beq.n	8001dc2 <ADXL345_Init+0xc0>
    {
        ADXL345_Write( LATENT_REG, haccel->latent );
 8001daa:	687b      	ldr	r3, [r7, #4]
 8001dac:	799b      	ldrb	r3, [r3, #6]
 8001dae:	0019      	movs	r1, r3
 8001db0:	2022      	movs	r0, #34	; 0x22
 8001db2:	f7ff ff5d 	bl	8001c70 <ADXL345_Write>
        ADXL345_Write( WINDOW_REG, haccel->window );
 8001db6:	687b      	ldr	r3, [r7, #4]
 8001db8:	79db      	ldrb	r3, [r3, #7]
 8001dba:	0019      	movs	r1, r3
 8001dbc:	2023      	movs	r0, #35	; 0x23
 8001dbe:	f7ff ff57 	bl	8001c70 <ADXL345_Write>
    }

    /* If activity interrupt is enabled */
    if ( ( haccel->intenable & ACTIVITY_INT_ENABLED ) == ACTIVITY_INT_ENABLED )
 8001dc2:	687b      	ldr	r3, [r7, #4]
 8001dc4:	7c5b      	ldrb	r3, [r3, #17]
 8001dc6:	001a      	movs	r2, r3
 8001dc8:	2310      	movs	r3, #16
 8001dca:	4013      	ands	r3, r2
 8001dcc:	d00b      	beq.n	8001de6 <ADXL345_Init+0xe4>
    {
        /* Configure threshold for activity */
        ADXL345_Write( THRESH_ACT_REG, haccel->threshact );
 8001dce:	687b      	ldr	r3, [r7, #4]
 8001dd0:	7a1b      	ldrb	r3, [r3, #8]
 8001dd2:	0019      	movs	r1, r3
 8001dd4:	2024      	movs	r0, #36	; 0x24
 8001dd6:	f7ff ff4b 	bl	8001c70 <ADXL345_Write>

        /* Enable participating axes in activity detection */
        ADXL345_Write( ACT_INACT_CTL_REG, haccel->actinactctl );
 8001dda:	687b      	ldr	r3, [r7, #4]
 8001ddc:	7adb      	ldrb	r3, [r3, #11]
 8001dde:	0019      	movs	r1, r3
 8001de0:	2027      	movs	r0, #39	; 0x27
 8001de2:	f7ff ff45 	bl	8001c70 <ADXL345_Write>
    }

    /* If inactivity interrupt is enabled */
    if ( ( haccel->intenable & INACTIVITY_INT_ENABLED ) == INACTIVITY_INT_ENABLED )
 8001de6:	687b      	ldr	r3, [r7, #4]
 8001de8:	7c5b      	ldrb	r3, [r3, #17]
 8001dea:	001a      	movs	r2, r3
 8001dec:	2308      	movs	r3, #8
 8001dee:	4013      	ands	r3, r2
 8001df0:	d011      	beq.n	8001e16 <ADXL345_Init+0x114>
    {
        /* Configure threshold for inactivity */
        ADXL345_Write( THRESH_INACT_REG, haccel->threshinact );
 8001df2:	687b      	ldr	r3, [r7, #4]
 8001df4:	7a5b      	ldrb	r3, [r3, #9]
 8001df6:	0019      	movs	r1, r3
 8001df8:	2025      	movs	r0, #37	; 0x25
 8001dfa:	f7ff ff39 	bl	8001c70 <ADXL345_Write>
        
        /* Configure time for inactivity */
        ADXL345_Write( TIME_INACT_REG, haccel->timeinact );
 8001dfe:	687b      	ldr	r3, [r7, #4]
 8001e00:	7a9b      	ldrb	r3, [r3, #10]
 8001e02:	0019      	movs	r1, r3
 8001e04:	2026      	movs	r0, #38	; 0x26
 8001e06:	f7ff ff33 	bl	8001c70 <ADXL345_Write>

        /* Enable participating axes in inactivity detection */
        ADXL345_Write( ACT_INACT_CTL_REG, haccel->actinactctl );
 8001e0a:	687b      	ldr	r3, [r7, #4]
 8001e0c:	7adb      	ldrb	r3, [r3, #11]
 8001e0e:	0019      	movs	r1, r3
 8001e10:	2027      	movs	r0, #39	; 0x27
 8001e12:	f7ff ff2d 	bl	8001c70 <ADXL345_Write>
    }

    /* If free-fall interrupt is enabled */
    if ( ( ( haccel->intenable & FREE_FALL_INT_ENABLED ) == FREE_FALL_INT_ENABLED ) )
 8001e16:	687b      	ldr	r3, [r7, #4]
 8001e18:	7c5b      	ldrb	r3, [r3, #17]
 8001e1a:	001a      	movs	r2, r3
 8001e1c:	2304      	movs	r3, #4
 8001e1e:	4013      	ands	r3, r2
 8001e20:	d00b      	beq.n	8001e3a <ADXL345_Init+0x138>
    {
        /* Configure freefall threshold */
        ADXL345_Write( THRESH_FF_REG, haccel->threshff );
 8001e22:	687b      	ldr	r3, [r7, #4]
 8001e24:	7b1b      	ldrb	r3, [r3, #12]
 8001e26:	0019      	movs	r1, r3
 8001e28:	2028      	movs	r0, #40	; 0x28
 8001e2a:	f7ff ff21 	bl	8001c70 <ADXL345_Write>

        /* Configure freefall time */
        ADXL345_Write( TIME_FF_REG, haccel->timeff );
 8001e2e:	687b      	ldr	r3, [r7, #4]
 8001e30:	7b5b      	ldrb	r3, [r3, #13]
 8001e32:	0019      	movs	r1, r3
 8001e34:	2029      	movs	r0, #41	; 0x29
 8001e36:	f7ff ff1b 	bl	8001c70 <ADXL345_Write>
    }

    /* Configure FIFO mode (and number of samples for the watermark interrupt, if enabled) */
    ADXL345_Write( FIFO_CTL_REG, haccel->fifoctl );
 8001e3a:	687b      	ldr	r3, [r7, #4]
 8001e3c:	7d1b      	ldrb	r3, [r3, #20]
 8001e3e:	0019      	movs	r1, r3
 8001e40:	2038      	movs	r0, #56	; 0x38
 8001e42:	f7ff ff15 	bl	8001c70 <ADXL345_Write>
    
    /* Configure power mode (if measure bit is set, ADXL345 enters normal mode) */
    ADXL345_Write( POWER_CTL_REG, haccel->powerctl );
 8001e46:	687b      	ldr	r3, [r7, #4]
 8001e48:	7c1b      	ldrb	r3, [r3, #16]
 8001e4a:	0019      	movs	r1, r3
 8001e4c:	202d      	movs	r0, #45	; 0x2d
 8001e4e:	f7ff ff0f 	bl	8001c70 <ADXL345_Write>
}
 8001e52:	46c0      	nop			; (mov r8, r8)
 8001e54:	46bd      	mov	sp, r7
 8001e56:	b002      	add	sp, #8
 8001e58:	bd80      	pop	{r7, pc}

08001e5a <ADXL345_API_Standby_Mode>:
    /* Read ADXL345 DEVICE ID, 0xE5H should be returned */
    haccel->devid = ADXL345_Read( DEVID_REG );
}

void ADXL345_API_Standby_Mode( ACCEL_HandleTypeDef *haccel )
{
 8001e5a:	b580      	push	{r7, lr}
 8001e5c:	b082      	sub	sp, #8
 8001e5e:	af00      	add	r7, sp, #0
 8001e60:	6078      	str	r0, [r7, #4]
    /* Set ADXL345 to standby mode (keep the other parameters of POWER_CTL) */
    haccel->powerctl &= ~MEASURE_ENABLED;
 8001e62:	687b      	ldr	r3, [r7, #4]
 8001e64:	7c1b      	ldrb	r3, [r3, #16]
 8001e66:	2208      	movs	r2, #8
 8001e68:	4393      	bics	r3, r2
 8001e6a:	b2da      	uxtb	r2, r3
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	741a      	strb	r2, [r3, #16]
    ADXL345_Write( POWER_CTL_REG, haccel->powerctl );
 8001e70:	687b      	ldr	r3, [r7, #4]
 8001e72:	7c1b      	ldrb	r3, [r3, #16]
 8001e74:	0019      	movs	r1, r3
 8001e76:	202d      	movs	r0, #45	; 0x2d
 8001e78:	f7ff fefa 	bl	8001c70 <ADXL345_Write>
}
 8001e7c:	46c0      	nop			; (mov r8, r8)
 8001e7e:	46bd      	mov	sp, r7
 8001e80:	b002      	add	sp, #8
 8001e82:	bd80      	pop	{r7, pc}

08001e84 <ADXL345_API_Measurement_Mode>:

void ADXL345_API_Measurement_Mode( ACCEL_HandleTypeDef *haccel )
{
 8001e84:	b580      	push	{r7, lr}
 8001e86:	b082      	sub	sp, #8
 8001e88:	af00      	add	r7, sp, #0
 8001e8a:	6078      	str	r0, [r7, #4]
    /* Set ADXL345 to measurement mode (keep the other parameters of POWER_CTL) */
    haccel->powerctl |= MEASURE_ENABLED;
 8001e8c:	687b      	ldr	r3, [r7, #4]
 8001e8e:	7c1b      	ldrb	r3, [r3, #16]
 8001e90:	2208      	movs	r2, #8
 8001e92:	4313      	orrs	r3, r2
 8001e94:	b2da      	uxtb	r2, r3
 8001e96:	687b      	ldr	r3, [r7, #4]
 8001e98:	741a      	strb	r2, [r3, #16]
    ADXL345_Write( POWER_CTL_REG, haccel->powerctl );
 8001e9a:	687b      	ldr	r3, [r7, #4]
 8001e9c:	7c1b      	ldrb	r3, [r3, #16]
 8001e9e:	0019      	movs	r1, r3
 8001ea0:	202d      	movs	r0, #45	; 0x2d
 8001ea2:	f7ff fee5 	bl	8001c70 <ADXL345_Write>
}
 8001ea6:	46c0      	nop			; (mov r8, r8)
 8001ea8:	46bd      	mov	sp, r7
 8001eaa:	b002      	add	sp, #8
 8001eac:	bd80      	pop	{r7, pc}

08001eae <ADXL345_API_Manual_OffsetCal>:
    haccel->powerctl |= LINK_DELAY_ACT_UNTIL_INACT;
    ADXL345_Write( POWER_CTL_REG, haccel->powerctl );
}

void ADXL345_API_Manual_OffsetCal( ACCEL_HandleTypeDef *haccel, int16_t *x0g, int16_t *y0g, int16_t *z0g )
{
 8001eae:	b580      	push	{r7, lr}
 8001eb0:	b086      	sub	sp, #24
 8001eb2:	af00      	add	r7, sp, #0
 8001eb4:	60f8      	str	r0, [r7, #12]
 8001eb6:	60b9      	str	r1, [r7, #8]
 8001eb8:	607a      	str	r2, [r7, #4]
 8001eba:	603b      	str	r3, [r7, #0]
    uint8_t spi1_read;

    /* Read current measured values for X, Y and Z axis.
       NOTE: ADXL345 has to be oriented such that Z is in the 1g field whereas X and Y are in a 0g gravity field */
    ADXL345_API_Read_Axes( haccel, x0g , y0g, z0g );
 8001ebc:	683b      	ldr	r3, [r7, #0]
 8001ebe:	687a      	ldr	r2, [r7, #4]
 8001ec0:	68b9      	ldr	r1, [r7, #8]
 8001ec2:	68f8      	ldr	r0, [r7, #12]
 8001ec4:	f000 f85a 	bl	8001f7c <ADXL345_API_Read_Axes>

    /* Read DATA_FORMAT register */
    haccel->dataformat = ADXL345_Read( DATA_FORMAT_REG );
 8001ec8:	2031      	movs	r0, #49	; 0x31
 8001eca:	f7ff fef3 	bl	8001cb4 <ADXL345_Read>
 8001ece:	0003      	movs	r3, r0
 8001ed0:	001a      	movs	r2, r3
 8001ed2:	68fb      	ldr	r3, [r7, #12]
 8001ed4:	74da      	strb	r2, [r3, #19]

    /* Obtain FULL_RES (bit 3) and RANGE (bits 1 and 0) from DATA_FORMAT */
    spi1_read = haccel->dataformat & ( FULL_RES_ENABLED | RANGE_BIT_1 | RANGE_BIT_0 );
 8001ed6:	68fb      	ldr	r3, [r7, #12]
 8001ed8:	7cda      	ldrb	r2, [r3, #19]
 8001eda:	2017      	movs	r0, #23
 8001edc:	183b      	adds	r3, r7, r0
 8001ede:	210b      	movs	r1, #11
 8001ee0:	400a      	ands	r2, r1
 8001ee2:	701a      	strb	r2, [r3, #0]

    /* If full resolution is enabled */
    if ( ( spi1_read & FULL_RES_ENABLED ) == FULL_RES_ENABLED )
 8001ee4:	183b      	adds	r3, r7, r0
 8001ee6:	781b      	ldrb	r3, [r3, #0]
 8001ee8:	2208      	movs	r2, #8
 8001eea:	4013      	ands	r3, r2
 8001eec:	d00a      	beq.n	8001f04 <ADXL345_API_Manual_OffsetCal+0x56>
    {
        /* Subtract typ. sensitivity for full resolution mode at 1g in order to get Z for the 0g field */
        *z0g -= 256;
 8001eee:	683b      	ldr	r3, [r7, #0]
 8001ef0:	2200      	movs	r2, #0
 8001ef2:	5e9b      	ldrsh	r3, [r3, r2]
 8001ef4:	b29b      	uxth	r3, r3
 8001ef6:	3b01      	subs	r3, #1
 8001ef8:	3bff      	subs	r3, #255	; 0xff
 8001efa:	b29b      	uxth	r3, r3
 8001efc:	b21a      	sxth	r2, r3
 8001efe:	683b      	ldr	r3, [r7, #0]
 8001f00:	801a      	strh	r2, [r3, #0]
    }

    /* After this the values obtained for x0g, y0g and z0g must be subtracted from the X, Y and Z data registers
       for each new read in order to get the real values (take into consideration that scaling still needs to be
       done for a correct reading) */
}
 8001f02:	e037      	b.n	8001f74 <ADXL345_API_Manual_OffsetCal+0xc6>
        switch ( spi1_read )
 8001f04:	2317      	movs	r3, #23
 8001f06:	18fb      	adds	r3, r7, r3
 8001f08:	781b      	ldrb	r3, [r3, #0]
 8001f0a:	2b03      	cmp	r3, #3
 8001f0c:	d027      	beq.n	8001f5e <ADXL345_API_Manual_OffsetCal+0xb0>
 8001f0e:	dc30      	bgt.n	8001f72 <ADXL345_API_Manual_OffsetCal+0xc4>
 8001f10:	2b02      	cmp	r3, #2
 8001f12:	d01a      	beq.n	8001f4a <ADXL345_API_Manual_OffsetCal+0x9c>
 8001f14:	dc2d      	bgt.n	8001f72 <ADXL345_API_Manual_OffsetCal+0xc4>
 8001f16:	2b00      	cmp	r3, #0
 8001f18:	d002      	beq.n	8001f20 <ADXL345_API_Manual_OffsetCal+0x72>
 8001f1a:	2b01      	cmp	r3, #1
 8001f1c:	d00b      	beq.n	8001f36 <ADXL345_API_Manual_OffsetCal+0x88>
                break;
 8001f1e:	e028      	b.n	8001f72 <ADXL345_API_Manual_OffsetCal+0xc4>
                *z0g -= 256;
 8001f20:	683b      	ldr	r3, [r7, #0]
 8001f22:	2200      	movs	r2, #0
 8001f24:	5e9b      	ldrsh	r3, [r3, r2]
 8001f26:	b29b      	uxth	r3, r3
 8001f28:	3b01      	subs	r3, #1
 8001f2a:	3bff      	subs	r3, #255	; 0xff
 8001f2c:	b29b      	uxth	r3, r3
 8001f2e:	b21a      	sxth	r2, r3
 8001f30:	683b      	ldr	r3, [r7, #0]
 8001f32:	801a      	strh	r2, [r3, #0]
                break;
 8001f34:	e01e      	b.n	8001f74 <ADXL345_API_Manual_OffsetCal+0xc6>
                *z0g -= 128;
 8001f36:	683b      	ldr	r3, [r7, #0]
 8001f38:	2200      	movs	r2, #0
 8001f3a:	5e9b      	ldrsh	r3, [r3, r2]
 8001f3c:	b29b      	uxth	r3, r3
 8001f3e:	3b80      	subs	r3, #128	; 0x80
 8001f40:	b29b      	uxth	r3, r3
 8001f42:	b21a      	sxth	r2, r3
 8001f44:	683b      	ldr	r3, [r7, #0]
 8001f46:	801a      	strh	r2, [r3, #0]
                break;
 8001f48:	e014      	b.n	8001f74 <ADXL345_API_Manual_OffsetCal+0xc6>
                *z0g -= 64;
 8001f4a:	683b      	ldr	r3, [r7, #0]
 8001f4c:	2200      	movs	r2, #0
 8001f4e:	5e9b      	ldrsh	r3, [r3, r2]
 8001f50:	b29b      	uxth	r3, r3
 8001f52:	3b40      	subs	r3, #64	; 0x40
 8001f54:	b29b      	uxth	r3, r3
 8001f56:	b21a      	sxth	r2, r3
 8001f58:	683b      	ldr	r3, [r7, #0]
 8001f5a:	801a      	strh	r2, [r3, #0]
                break;
 8001f5c:	e00a      	b.n	8001f74 <ADXL345_API_Manual_OffsetCal+0xc6>
                *z0g -= 32;
 8001f5e:	683b      	ldr	r3, [r7, #0]
 8001f60:	2200      	movs	r2, #0
 8001f62:	5e9b      	ldrsh	r3, [r3, r2]
 8001f64:	b29b      	uxth	r3, r3
 8001f66:	3b20      	subs	r3, #32
 8001f68:	b29b      	uxth	r3, r3
 8001f6a:	b21a      	sxth	r2, r3
 8001f6c:	683b      	ldr	r3, [r7, #0]
 8001f6e:	801a      	strh	r2, [r3, #0]
                break;
 8001f70:	e000      	b.n	8001f74 <ADXL345_API_Manual_OffsetCal+0xc6>
                break;
 8001f72:	46c0      	nop			; (mov r8, r8)
}
 8001f74:	46c0      	nop			; (mov r8, r8)
 8001f76:	46bd      	mov	sp, r7
 8001f78:	b006      	add	sp, #24
 8001f7a:	bd80      	pop	{r7, pc}

08001f7c <ADXL345_API_Read_Axes>:
    haccel->fifoctl = FIFO_TRIGGER_MODE | trigger_pin | ( samples & SAMPLES_BITS_MASK );
    ADXL345_Write( FIFO_CTL_REG, haccel->fifoctl );
}

void ADXL345_API_Read_Axes( ACCEL_HandleTypeDef *haccel, int16_t *x_read, int16_t *y_read, int16_t *z_read )
{
 8001f7c:	b590      	push	{r4, r7, lr}
 8001f7e:	b087      	sub	sp, #28
 8001f80:	af00      	add	r7, sp, #0
 8001f82:	60f8      	str	r0, [r7, #12]
 8001f84:	60b9      	str	r1, [r7, #8]
 8001f86:	607a      	str	r2, [r7, #4]
 8001f88:	603b      	str	r3, [r7, #0]
    uint8_t spi1_write;
    uint8_t spi1_read[ 6 ];

    /* Read bit (0) + multiple bit (1) + DATAX0 register address */
    spi1_write = SPI_READ | MULTIPLE_BYTE_ENABLED | DATAX0_REG;
 8001f8a:	2417      	movs	r4, #23
 8001f8c:	193b      	adds	r3, r7, r4
 8001f8e:	22f2      	movs	r2, #242	; 0xf2
 8001f90:	701a      	strb	r2, [r3, #0]

    /* Request burst reading of the data registers (DATAX0, DATAX1, DATAY0, DATAY1, DATAZ0 and DATAZ1)
       and store the data read into spi_read[0], spi_read[1] ... spi_read[5] respectively */
    SPI1_CS_Enable();
 8001f92:	f7ff fdde 	bl	8001b52 <SPI1_CS_Enable>
    SPI1_Write( &spi1_write, 1U );
 8001f96:	193b      	adds	r3, r7, r4
 8001f98:	2101      	movs	r1, #1
 8001f9a:	0018      	movs	r0, r3
 8001f9c:	f7ff fde6 	bl	8001b6c <SPI1_Write>
    SPI1_Read( spi1_read, 6U );
 8001fa0:	2410      	movs	r4, #16
 8001fa2:	193b      	adds	r3, r7, r4
 8001fa4:	2106      	movs	r1, #6
 8001fa6:	0018      	movs	r0, r3
 8001fa8:	f7ff fe2e 	bl	8001c08 <SPI1_Read>
    SPI1_CS_Disable();
 8001fac:	f7ff fdc4 	bl	8001b38 <SPI1_CS_Disable>

    /* Align data for each axis and store it into destination variables */
    *x_read = ( int16_t )( ( spi1_read[ 1 ] << 8 ) + spi1_read[ 0 ] );
 8001fb0:	193b      	adds	r3, r7, r4
 8001fb2:	785b      	ldrb	r3, [r3, #1]
 8001fb4:	021b      	lsls	r3, r3, #8
 8001fb6:	b29b      	uxth	r3, r3
 8001fb8:	193a      	adds	r2, r7, r4
 8001fba:	7812      	ldrb	r2, [r2, #0]
 8001fbc:	189b      	adds	r3, r3, r2
 8001fbe:	b29b      	uxth	r3, r3
 8001fc0:	b21a      	sxth	r2, r3
 8001fc2:	68bb      	ldr	r3, [r7, #8]
 8001fc4:	801a      	strh	r2, [r3, #0]
    *y_read = ( int16_t )( ( spi1_read[ 3 ] << 8 ) + spi1_read[ 2 ] );
 8001fc6:	193b      	adds	r3, r7, r4
 8001fc8:	78db      	ldrb	r3, [r3, #3]
 8001fca:	021b      	lsls	r3, r3, #8
 8001fcc:	b29b      	uxth	r3, r3
 8001fce:	193a      	adds	r2, r7, r4
 8001fd0:	7892      	ldrb	r2, [r2, #2]
 8001fd2:	189b      	adds	r3, r3, r2
 8001fd4:	b29b      	uxth	r3, r3
 8001fd6:	b21a      	sxth	r2, r3
 8001fd8:	687b      	ldr	r3, [r7, #4]
 8001fda:	801a      	strh	r2, [r3, #0]
    *z_read = ( int16_t )( ( spi1_read[ 5 ] << 8 ) + spi1_read[ 4 ] );
 8001fdc:	193b      	adds	r3, r7, r4
 8001fde:	795b      	ldrb	r3, [r3, #5]
 8001fe0:	021b      	lsls	r3, r3, #8
 8001fe2:	b29b      	uxth	r3, r3
 8001fe4:	193a      	adds	r2, r7, r4
 8001fe6:	7912      	ldrb	r2, [r2, #4]
 8001fe8:	189b      	adds	r3, r3, r2
 8001fea:	b29b      	uxth	r3, r3
 8001fec:	b21a      	sxth	r2, r3
 8001fee:	683b      	ldr	r3, [r7, #0]
 8001ff0:	801a      	strh	r2, [r3, #0]

    /* Read DATA_FORMAT register */
    haccel->dataformat = ADXL345_Read( DATA_FORMAT_REG );
 8001ff2:	2031      	movs	r0, #49	; 0x31
 8001ff4:	f7ff fe5e 	bl	8001cb4 <ADXL345_Read>
 8001ff8:	0003      	movs	r3, r0
 8001ffa:	001a      	movs	r2, r3
 8001ffc:	68fb      	ldr	r3, [r7, #12]
 8001ffe:	74da      	strb	r2, [r3, #19]

    /* Obtain JUSTIFY (bit 2) from DATA_FORMAT */
    spi1_read[ 1 ] = haccel->dataformat & JUSTIFY_LEFT;
 8002000:	68fb      	ldr	r3, [r7, #12]
 8002002:	7cdb      	ldrb	r3, [r3, #19]
 8002004:	2204      	movs	r2, #4
 8002006:	4013      	ands	r3, r2
 8002008:	b2da      	uxtb	r2, r3
 800200a:	193b      	adds	r3, r7, r4
 800200c:	705a      	strb	r2, [r3, #1]

    /* Obtain FULL_RES (bit 3) from DATA_FORMAT */
    spi1_read[ 2 ] = haccel->dataformat & FULL_RES_ENABLED;
 800200e:	68fb      	ldr	r3, [r7, #12]
 8002010:	7cdb      	ldrb	r3, [r3, #19]
 8002012:	2208      	movs	r2, #8
 8002014:	4013      	ands	r3, r2
 8002016:	b2da      	uxtb	r2, r3
 8002018:	193b      	adds	r3, r7, r4
 800201a:	709a      	strb	r2, [r3, #2]

    /* Obtain RANGE (bits 1 and 0) from DATA_FORMAT */
    spi1_read[ 3 ] = haccel->dataformat & ( RANGE_BIT_1 | RANGE_BIT_0 );
 800201c:	68fb      	ldr	r3, [r7, #12]
 800201e:	7cdb      	ldrb	r3, [r3, #19]
 8002020:	2203      	movs	r2, #3
 8002022:	4013      	ands	r3, r2
 8002024:	b2da      	uxtb	r2, r3
 8002026:	193b      	adds	r3, r7, r4
 8002028:	70da      	strb	r2, [r3, #3]

    /* If data is left justified and full resolution is enabled */
    if ( ( spi1_read[ 1 ] == JUSTIFY_LEFT ) && ( spi1_read[ 2 ] == FULL_RES_ENABLED ) )
 800202a:	193b      	adds	r3, r7, r4
 800202c:	785b      	ldrb	r3, [r3, #1]
 800202e:	2b04      	cmp	r3, #4
 8002030:	d000      	beq.n	8002034 <ADXL345_API_Read_Axes+0xb8>
 8002032:	e06b      	b.n	800210c <ADXL345_API_Read_Axes+0x190>
 8002034:	193b      	adds	r3, r7, r4
 8002036:	789b      	ldrb	r3, [r3, #2]
 8002038:	2b08      	cmp	r3, #8
 800203a:	d167      	bne.n	800210c <ADXL345_API_Read_Axes+0x190>
    {   
        /* Get proper data depending on selected g range.
           NOTE: when right shifting, the C standard appends 0s or 1s on the left 
                 based on the sign of the data shifted, i.e. C handles the sign and
                 no extra operations are needed */
        switch( spi1_read[ 3 ] )
 800203c:	193b      	adds	r3, r7, r4
 800203e:	78db      	ldrb	r3, [r3, #3]
 8002040:	2b03      	cmp	r3, #3
 8002042:	d04a      	beq.n	80020da <ADXL345_API_Read_Axes+0x15e>
 8002044:	dc5f      	bgt.n	8002106 <ADXL345_API_Read_Axes+0x18a>
 8002046:	2b02      	cmp	r3, #2
 8002048:	d031      	beq.n	80020ae <ADXL345_API_Read_Axes+0x132>
 800204a:	dc5c      	bgt.n	8002106 <ADXL345_API_Read_Axes+0x18a>
 800204c:	2b00      	cmp	r3, #0
 800204e:	d002      	beq.n	8002056 <ADXL345_API_Read_Axes+0xda>
 8002050:	2b01      	cmp	r3, #1
 8002052:	d016      	beq.n	8002082 <ADXL345_API_Read_Axes+0x106>
                *z_read >>= 3;
                break;

            default:
                /* Do nothing */
                break;
 8002054:	e057      	b.n	8002106 <ADXL345_API_Read_Axes+0x18a>
                *x_read >>= 6;
 8002056:	68bb      	ldr	r3, [r7, #8]
 8002058:	2200      	movs	r2, #0
 800205a:	5e9b      	ldrsh	r3, [r3, r2]
 800205c:	119b      	asrs	r3, r3, #6
 800205e:	b21a      	sxth	r2, r3
 8002060:	68bb      	ldr	r3, [r7, #8]
 8002062:	801a      	strh	r2, [r3, #0]
                *y_read >>= 6;
 8002064:	687b      	ldr	r3, [r7, #4]
 8002066:	2200      	movs	r2, #0
 8002068:	5e9b      	ldrsh	r3, [r3, r2]
 800206a:	119b      	asrs	r3, r3, #6
 800206c:	b21a      	sxth	r2, r3
 800206e:	687b      	ldr	r3, [r7, #4]
 8002070:	801a      	strh	r2, [r3, #0]
                *z_read >>= 6;
 8002072:	683b      	ldr	r3, [r7, #0]
 8002074:	2200      	movs	r2, #0
 8002076:	5e9b      	ldrsh	r3, [r3, r2]
 8002078:	119b      	asrs	r3, r3, #6
 800207a:	b21a      	sxth	r2, r3
 800207c:	683b      	ldr	r3, [r7, #0]
 800207e:	801a      	strh	r2, [r3, #0]
                break;
 8002080:	e042      	b.n	8002108 <ADXL345_API_Read_Axes+0x18c>
                *x_read >>= 5;
 8002082:	68bb      	ldr	r3, [r7, #8]
 8002084:	2200      	movs	r2, #0
 8002086:	5e9b      	ldrsh	r3, [r3, r2]
 8002088:	115b      	asrs	r3, r3, #5
 800208a:	b21a      	sxth	r2, r3
 800208c:	68bb      	ldr	r3, [r7, #8]
 800208e:	801a      	strh	r2, [r3, #0]
                *y_read >>= 5;
 8002090:	687b      	ldr	r3, [r7, #4]
 8002092:	2200      	movs	r2, #0
 8002094:	5e9b      	ldrsh	r3, [r3, r2]
 8002096:	115b      	asrs	r3, r3, #5
 8002098:	b21a      	sxth	r2, r3
 800209a:	687b      	ldr	r3, [r7, #4]
 800209c:	801a      	strh	r2, [r3, #0]
                *z_read >>= 5;
 800209e:	683b      	ldr	r3, [r7, #0]
 80020a0:	2200      	movs	r2, #0
 80020a2:	5e9b      	ldrsh	r3, [r3, r2]
 80020a4:	115b      	asrs	r3, r3, #5
 80020a6:	b21a      	sxth	r2, r3
 80020a8:	683b      	ldr	r3, [r7, #0]
 80020aa:	801a      	strh	r2, [r3, #0]
                break;
 80020ac:	e02c      	b.n	8002108 <ADXL345_API_Read_Axes+0x18c>
                *x_read >>= 4;
 80020ae:	68bb      	ldr	r3, [r7, #8]
 80020b0:	2200      	movs	r2, #0
 80020b2:	5e9b      	ldrsh	r3, [r3, r2]
 80020b4:	111b      	asrs	r3, r3, #4
 80020b6:	b21a      	sxth	r2, r3
 80020b8:	68bb      	ldr	r3, [r7, #8]
 80020ba:	801a      	strh	r2, [r3, #0]
                *y_read >>= 4;
 80020bc:	687b      	ldr	r3, [r7, #4]
 80020be:	2200      	movs	r2, #0
 80020c0:	5e9b      	ldrsh	r3, [r3, r2]
 80020c2:	111b      	asrs	r3, r3, #4
 80020c4:	b21a      	sxth	r2, r3
 80020c6:	687b      	ldr	r3, [r7, #4]
 80020c8:	801a      	strh	r2, [r3, #0]
                *z_read >>= 4;
 80020ca:	683b      	ldr	r3, [r7, #0]
 80020cc:	2200      	movs	r2, #0
 80020ce:	5e9b      	ldrsh	r3, [r3, r2]
 80020d0:	111b      	asrs	r3, r3, #4
 80020d2:	b21a      	sxth	r2, r3
 80020d4:	683b      	ldr	r3, [r7, #0]
 80020d6:	801a      	strh	r2, [r3, #0]
                break;
 80020d8:	e016      	b.n	8002108 <ADXL345_API_Read_Axes+0x18c>
                *x_read >>= 3;
 80020da:	68bb      	ldr	r3, [r7, #8]
 80020dc:	2200      	movs	r2, #0
 80020de:	5e9b      	ldrsh	r3, [r3, r2]
 80020e0:	10db      	asrs	r3, r3, #3
 80020e2:	b21a      	sxth	r2, r3
 80020e4:	68bb      	ldr	r3, [r7, #8]
 80020e6:	801a      	strh	r2, [r3, #0]
                *y_read >>= 3;
 80020e8:	687b      	ldr	r3, [r7, #4]
 80020ea:	2200      	movs	r2, #0
 80020ec:	5e9b      	ldrsh	r3, [r3, r2]
 80020ee:	10db      	asrs	r3, r3, #3
 80020f0:	b21a      	sxth	r2, r3
 80020f2:	687b      	ldr	r3, [r7, #4]
 80020f4:	801a      	strh	r2, [r3, #0]
                *z_read >>= 3;
 80020f6:	683b      	ldr	r3, [r7, #0]
 80020f8:	2200      	movs	r2, #0
 80020fa:	5e9b      	ldrsh	r3, [r3, r2]
 80020fc:	10db      	asrs	r3, r3, #3
 80020fe:	b21a      	sxth	r2, r3
 8002100:	683b      	ldr	r3, [r7, #0]
 8002102:	801a      	strh	r2, [r3, #0]
                break;
 8002104:	e000      	b.n	8002108 <ADXL345_API_Read_Axes+0x18c>
                break;
 8002106:	46c0      	nop			; (mov r8, r8)
        switch( spi1_read[ 3 ] )
 8002108:	46c0      	nop			; (mov r8, r8)
             data, therefore there is no need for masking out such bits or perform any extra conversion
             as those bits are necessary in order to know the sign of said data */

    /* After this the values obtained for x, y and z must be
       scaled according to the selected resolution and g range */
}
 800210a:	e01d      	b.n	8002148 <ADXL345_API_Read_Axes+0x1cc>
    else if( ( spi1_read[ 1 ] == JUSTIFY_LEFT ) && ( spi1_read[ 2 ] == FULL_RES_10BIT_MODE ) )
 800210c:	2210      	movs	r2, #16
 800210e:	18bb      	adds	r3, r7, r2
 8002110:	785b      	ldrb	r3, [r3, #1]
 8002112:	2b04      	cmp	r3, #4
 8002114:	d118      	bne.n	8002148 <ADXL345_API_Read_Axes+0x1cc>
 8002116:	18bb      	adds	r3, r7, r2
 8002118:	789b      	ldrb	r3, [r3, #2]
 800211a:	2b00      	cmp	r3, #0
 800211c:	d114      	bne.n	8002148 <ADXL345_API_Read_Axes+0x1cc>
        *x_read >>= 6;
 800211e:	68bb      	ldr	r3, [r7, #8]
 8002120:	2200      	movs	r2, #0
 8002122:	5e9b      	ldrsh	r3, [r3, r2]
 8002124:	119b      	asrs	r3, r3, #6
 8002126:	b21a      	sxth	r2, r3
 8002128:	68bb      	ldr	r3, [r7, #8]
 800212a:	801a      	strh	r2, [r3, #0]
        *y_read >>= 6;
 800212c:	687b      	ldr	r3, [r7, #4]
 800212e:	2200      	movs	r2, #0
 8002130:	5e9b      	ldrsh	r3, [r3, r2]
 8002132:	119b      	asrs	r3, r3, #6
 8002134:	b21a      	sxth	r2, r3
 8002136:	687b      	ldr	r3, [r7, #4]
 8002138:	801a      	strh	r2, [r3, #0]
        *z_read >>= 6;
 800213a:	683b      	ldr	r3, [r7, #0]
 800213c:	2200      	movs	r2, #0
 800213e:	5e9b      	ldrsh	r3, [r3, r2]
 8002140:	119b      	asrs	r3, r3, #6
 8002142:	b21a      	sxth	r2, r3
 8002144:	683b      	ldr	r3, [r7, #0]
 8002146:	801a      	strh	r2, [r3, #0]
}
 8002148:	46c0      	nop			; (mov r8, r8)
 800214a:	46bd      	mov	sp, r7
 800214c:	b007      	add	sp, #28
 800214e:	bd90      	pop	{r4, r7, pc}

08002150 <ADXL345_API_Scale_Axes>:

float *ADXL345_API_Scale_Axes( ACCEL_HandleTypeDef *haccel, int16_t x_raw, int16_t y_raw, int16_t z_raw )
{
 8002150:	b5b0      	push	{r4, r5, r7, lr}
 8002152:	b086      	sub	sp, #24
 8002154:	af00      	add	r7, sp, #0
 8002156:	60f8      	str	r0, [r7, #12]
 8002158:	000c      	movs	r4, r1
 800215a:	0010      	movs	r0, r2
 800215c:	0019      	movs	r1, r3
 800215e:	250a      	movs	r5, #10
 8002160:	197b      	adds	r3, r7, r5
 8002162:	1c22      	adds	r2, r4, #0
 8002164:	801a      	strh	r2, [r3, #0]
 8002166:	2408      	movs	r4, #8
 8002168:	193b      	adds	r3, r7, r4
 800216a:	1c02      	adds	r2, r0, #0
 800216c:	801a      	strh	r2, [r3, #0]
 800216e:	1dbb      	adds	r3, r7, #6
 8002170:	1c0a      	adds	r2, r1, #0
 8002172:	801a      	strh	r2, [r3, #0]
    uint8_t spi1_read;
    static float axes[ 3 ]; /* axes[0] = scaled x, axes[1] = scaled y, axes[2] = scaled z */

    /* Read DATA_FORMAT register */
    haccel->dataformat = ADXL345_Read( DATA_FORMAT_REG );
 8002174:	2031      	movs	r0, #49	; 0x31
 8002176:	f7ff fd9d 	bl	8001cb4 <ADXL345_Read>
 800217a:	0003      	movs	r3, r0
 800217c:	001a      	movs	r2, r3
 800217e:	68fb      	ldr	r3, [r7, #12]
 8002180:	74da      	strb	r2, [r3, #19]

    /* Obtain FULL_RES (bit 3) and RANGE (bits 1 and 0) from DATA_FORMAT */
    spi1_read = haccel->dataformat & ( FULL_RES_ENABLED | RANGE_BIT_1 | RANGE_BIT_0 );
 8002182:	68fb      	ldr	r3, [r7, #12]
 8002184:	7cda      	ldrb	r2, [r3, #19]
 8002186:	2017      	movs	r0, #23
 8002188:	183b      	adds	r3, r7, r0
 800218a:	210b      	movs	r1, #11
 800218c:	400a      	ands	r2, r1
 800218e:	701a      	strb	r2, [r3, #0]

    /* If full resolution is configured */
    if ( ( spi1_read & FULL_RES_ENABLED ) == FULL_RES_ENABLED )
 8002190:	183b      	adds	r3, r7, r0
 8002192:	781b      	ldrb	r3, [r3, #0]
 8002194:	2208      	movs	r2, #8
 8002196:	4013      	ands	r3, r2
 8002198:	d02d      	beq.n	80021f6 <ADXL345_API_Scale_Axes+0xa6>
    {   
        /* Scale axes raw data for the full resolution mode */
        axes[ 0 ] = x_raw * 0.0039F;
 800219a:	197b      	adds	r3, r7, r5
 800219c:	2200      	movs	r2, #0
 800219e:	5e9b      	ldrsh	r3, [r3, r2]
 80021a0:	0018      	movs	r0, r3
 80021a2:	f001 fa95 	bl	80036d0 <__aeabi_i2f>
 80021a6:	1c03      	adds	r3, r0, #0
 80021a8:	497e      	ldr	r1, [pc, #504]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 80021aa:	1c18      	adds	r0, r3, #0
 80021ac:	f000 ffa0 	bl	80030f0 <__aeabi_fmul>
 80021b0:	1c03      	adds	r3, r0, #0
 80021b2:	1c1a      	adds	r2, r3, #0
 80021b4:	4b7c      	ldr	r3, [pc, #496]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80021b6:	601a      	str	r2, [r3, #0]
        axes[ 1 ] = y_raw * 0.0039F;
 80021b8:	193b      	adds	r3, r7, r4
 80021ba:	2200      	movs	r2, #0
 80021bc:	5e9b      	ldrsh	r3, [r3, r2]
 80021be:	0018      	movs	r0, r3
 80021c0:	f001 fa86 	bl	80036d0 <__aeabi_i2f>
 80021c4:	1c03      	adds	r3, r0, #0
 80021c6:	4977      	ldr	r1, [pc, #476]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 80021c8:	1c18      	adds	r0, r3, #0
 80021ca:	f000 ff91 	bl	80030f0 <__aeabi_fmul>
 80021ce:	1c03      	adds	r3, r0, #0
 80021d0:	1c1a      	adds	r2, r3, #0
 80021d2:	4b75      	ldr	r3, [pc, #468]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80021d4:	605a      	str	r2, [r3, #4]
        axes[ 2 ] = z_raw * 0.0039F;
 80021d6:	1dbb      	adds	r3, r7, #6
 80021d8:	2200      	movs	r2, #0
 80021da:	5e9b      	ldrsh	r3, [r3, r2]
 80021dc:	0018      	movs	r0, r3
 80021de:	f001 fa77 	bl	80036d0 <__aeabi_i2f>
 80021e2:	1c03      	adds	r3, r0, #0
 80021e4:	496f      	ldr	r1, [pc, #444]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 80021e6:	1c18      	adds	r0, r3, #0
 80021e8:	f000 ff82 	bl	80030f0 <__aeabi_fmul>
 80021ec:	1c03      	adds	r3, r0, #0
 80021ee:	1c1a      	adds	r2, r3, #0
 80021f0:	4b6d      	ldr	r3, [pc, #436]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80021f2:	609a      	str	r2, [r3, #8]
 80021f4:	e0d1      	b.n	800239a <ADXL345_API_Scale_Axes+0x24a>
    }
    /* If 10-bit mode is enabled */
    else
    {
        /* Scale axes raw data for the selected g range */
        switch ( spi1_read )
 80021f6:	2317      	movs	r3, #23
 80021f8:	18fb      	adds	r3, r7, r3
 80021fa:	781b      	ldrb	r3, [r3, #0]
 80021fc:	2b03      	cmp	r3, #3
 80021fe:	d100      	bne.n	8002202 <ADXL345_API_Scale_Axes+0xb2>
 8002200:	e09a      	b.n	8002338 <ADXL345_API_Scale_Axes+0x1e8>
 8002202:	dd00      	ble.n	8002206 <ADXL345_API_Scale_Axes+0xb6>
 8002204:	e0c8      	b.n	8002398 <ADXL345_API_Scale_Axes+0x248>
 8002206:	2b02      	cmp	r3, #2
 8002208:	d066      	beq.n	80022d8 <ADXL345_API_Scale_Axes+0x188>
 800220a:	dd00      	ble.n	800220e <ADXL345_API_Scale_Axes+0xbe>
 800220c:	e0c4      	b.n	8002398 <ADXL345_API_Scale_Axes+0x248>
 800220e:	2b00      	cmp	r3, #0
 8002210:	d002      	beq.n	8002218 <ADXL345_API_Scale_Axes+0xc8>
 8002212:	2b01      	cmp	r3, #1
 8002214:	d030      	beq.n	8002278 <ADXL345_API_Scale_Axes+0x128>
                axes[ 2 ] = z_raw * 0.0312F;
                break;

            default:
                /* Do nothing */
                break;
 8002216:	e0bf      	b.n	8002398 <ADXL345_API_Scale_Axes+0x248>
                axes[ 0 ] = x_raw * 0.0039F;
 8002218:	230a      	movs	r3, #10
 800221a:	18fb      	adds	r3, r7, r3
 800221c:	2200      	movs	r2, #0
 800221e:	5e9b      	ldrsh	r3, [r3, r2]
 8002220:	0018      	movs	r0, r3
 8002222:	f001 fa55 	bl	80036d0 <__aeabi_i2f>
 8002226:	1c03      	adds	r3, r0, #0
 8002228:	495e      	ldr	r1, [pc, #376]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 800222a:	1c18      	adds	r0, r3, #0
 800222c:	f000 ff60 	bl	80030f0 <__aeabi_fmul>
 8002230:	1c03      	adds	r3, r0, #0
 8002232:	1c1a      	adds	r2, r3, #0
 8002234:	4b5c      	ldr	r3, [pc, #368]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002236:	601a      	str	r2, [r3, #0]
                axes[ 1 ] = y_raw * 0.0039F;
 8002238:	2308      	movs	r3, #8
 800223a:	18fb      	adds	r3, r7, r3
 800223c:	2200      	movs	r2, #0
 800223e:	5e9b      	ldrsh	r3, [r3, r2]
 8002240:	0018      	movs	r0, r3
 8002242:	f001 fa45 	bl	80036d0 <__aeabi_i2f>
 8002246:	1c03      	adds	r3, r0, #0
 8002248:	4956      	ldr	r1, [pc, #344]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 800224a:	1c18      	adds	r0, r3, #0
 800224c:	f000 ff50 	bl	80030f0 <__aeabi_fmul>
 8002250:	1c03      	adds	r3, r0, #0
 8002252:	1c1a      	adds	r2, r3, #0
 8002254:	4b54      	ldr	r3, [pc, #336]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002256:	605a      	str	r2, [r3, #4]
                axes[ 2 ] = z_raw * 0.0039F;
 8002258:	1dbb      	adds	r3, r7, #6
 800225a:	2200      	movs	r2, #0
 800225c:	5e9b      	ldrsh	r3, [r3, r2]
 800225e:	0018      	movs	r0, r3
 8002260:	f001 fa36 	bl	80036d0 <__aeabi_i2f>
 8002264:	1c03      	adds	r3, r0, #0
 8002266:	494f      	ldr	r1, [pc, #316]	; (80023a4 <ADXL345_API_Scale_Axes+0x254>)
 8002268:	1c18      	adds	r0, r3, #0
 800226a:	f000 ff41 	bl	80030f0 <__aeabi_fmul>
 800226e:	1c03      	adds	r3, r0, #0
 8002270:	1c1a      	adds	r2, r3, #0
 8002272:	4b4d      	ldr	r3, [pc, #308]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002274:	609a      	str	r2, [r3, #8]
                break;
 8002276:	e090      	b.n	800239a <ADXL345_API_Scale_Axes+0x24a>
                axes[ 0 ] = x_raw * 0.0078F;
 8002278:	230a      	movs	r3, #10
 800227a:	18fb      	adds	r3, r7, r3
 800227c:	2200      	movs	r2, #0
 800227e:	5e9b      	ldrsh	r3, [r3, r2]
 8002280:	0018      	movs	r0, r3
 8002282:	f001 fa25 	bl	80036d0 <__aeabi_i2f>
 8002286:	1c03      	adds	r3, r0, #0
 8002288:	4948      	ldr	r1, [pc, #288]	; (80023ac <ADXL345_API_Scale_Axes+0x25c>)
 800228a:	1c18      	adds	r0, r3, #0
 800228c:	f000 ff30 	bl	80030f0 <__aeabi_fmul>
 8002290:	1c03      	adds	r3, r0, #0
 8002292:	1c1a      	adds	r2, r3, #0
 8002294:	4b44      	ldr	r3, [pc, #272]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002296:	601a      	str	r2, [r3, #0]
                axes[ 1 ] = y_raw * 0.0078F;
 8002298:	2308      	movs	r3, #8
 800229a:	18fb      	adds	r3, r7, r3
 800229c:	2200      	movs	r2, #0
 800229e:	5e9b      	ldrsh	r3, [r3, r2]
 80022a0:	0018      	movs	r0, r3
 80022a2:	f001 fa15 	bl	80036d0 <__aeabi_i2f>
 80022a6:	1c03      	adds	r3, r0, #0
 80022a8:	4940      	ldr	r1, [pc, #256]	; (80023ac <ADXL345_API_Scale_Axes+0x25c>)
 80022aa:	1c18      	adds	r0, r3, #0
 80022ac:	f000 ff20 	bl	80030f0 <__aeabi_fmul>
 80022b0:	1c03      	adds	r3, r0, #0
 80022b2:	1c1a      	adds	r2, r3, #0
 80022b4:	4b3c      	ldr	r3, [pc, #240]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80022b6:	605a      	str	r2, [r3, #4]
                axes[ 2 ] = z_raw * 0.0078F;
 80022b8:	1dbb      	adds	r3, r7, #6
 80022ba:	2200      	movs	r2, #0
 80022bc:	5e9b      	ldrsh	r3, [r3, r2]
 80022be:	0018      	movs	r0, r3
 80022c0:	f001 fa06 	bl	80036d0 <__aeabi_i2f>
 80022c4:	1c03      	adds	r3, r0, #0
 80022c6:	4939      	ldr	r1, [pc, #228]	; (80023ac <ADXL345_API_Scale_Axes+0x25c>)
 80022c8:	1c18      	adds	r0, r3, #0
 80022ca:	f000 ff11 	bl	80030f0 <__aeabi_fmul>
 80022ce:	1c03      	adds	r3, r0, #0
 80022d0:	1c1a      	adds	r2, r3, #0
 80022d2:	4b35      	ldr	r3, [pc, #212]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80022d4:	609a      	str	r2, [r3, #8]
                break;
 80022d6:	e060      	b.n	800239a <ADXL345_API_Scale_Axes+0x24a>
                axes[ 0 ] = x_raw * 0.0156F;
 80022d8:	230a      	movs	r3, #10
 80022da:	18fb      	adds	r3, r7, r3
 80022dc:	2200      	movs	r2, #0
 80022de:	5e9b      	ldrsh	r3, [r3, r2]
 80022e0:	0018      	movs	r0, r3
 80022e2:	f001 f9f5 	bl	80036d0 <__aeabi_i2f>
 80022e6:	1c03      	adds	r3, r0, #0
 80022e8:	4931      	ldr	r1, [pc, #196]	; (80023b0 <ADXL345_API_Scale_Axes+0x260>)
 80022ea:	1c18      	adds	r0, r3, #0
 80022ec:	f000 ff00 	bl	80030f0 <__aeabi_fmul>
 80022f0:	1c03      	adds	r3, r0, #0
 80022f2:	1c1a      	adds	r2, r3, #0
 80022f4:	4b2c      	ldr	r3, [pc, #176]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 80022f6:	601a      	str	r2, [r3, #0]
                axes[ 1 ] = y_raw * 0.0156F;
 80022f8:	2308      	movs	r3, #8
 80022fa:	18fb      	adds	r3, r7, r3
 80022fc:	2200      	movs	r2, #0
 80022fe:	5e9b      	ldrsh	r3, [r3, r2]
 8002300:	0018      	movs	r0, r3
 8002302:	f001 f9e5 	bl	80036d0 <__aeabi_i2f>
 8002306:	1c03      	adds	r3, r0, #0
 8002308:	4929      	ldr	r1, [pc, #164]	; (80023b0 <ADXL345_API_Scale_Axes+0x260>)
 800230a:	1c18      	adds	r0, r3, #0
 800230c:	f000 fef0 	bl	80030f0 <__aeabi_fmul>
 8002310:	1c03      	adds	r3, r0, #0
 8002312:	1c1a      	adds	r2, r3, #0
 8002314:	4b24      	ldr	r3, [pc, #144]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002316:	605a      	str	r2, [r3, #4]
                axes[ 2 ] = z_raw * 0.0156F;
 8002318:	1dbb      	adds	r3, r7, #6
 800231a:	2200      	movs	r2, #0
 800231c:	5e9b      	ldrsh	r3, [r3, r2]
 800231e:	0018      	movs	r0, r3
 8002320:	f001 f9d6 	bl	80036d0 <__aeabi_i2f>
 8002324:	1c03      	adds	r3, r0, #0
 8002326:	4922      	ldr	r1, [pc, #136]	; (80023b0 <ADXL345_API_Scale_Axes+0x260>)
 8002328:	1c18      	adds	r0, r3, #0
 800232a:	f000 fee1 	bl	80030f0 <__aeabi_fmul>
 800232e:	1c03      	adds	r3, r0, #0
 8002330:	1c1a      	adds	r2, r3, #0
 8002332:	4b1d      	ldr	r3, [pc, #116]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002334:	609a      	str	r2, [r3, #8]
                break;
 8002336:	e030      	b.n	800239a <ADXL345_API_Scale_Axes+0x24a>
                axes[ 0 ] = x_raw * 0.0312F;
 8002338:	230a      	movs	r3, #10
 800233a:	18fb      	adds	r3, r7, r3
 800233c:	2200      	movs	r2, #0
 800233e:	5e9b      	ldrsh	r3, [r3, r2]
 8002340:	0018      	movs	r0, r3
 8002342:	f001 f9c5 	bl	80036d0 <__aeabi_i2f>
 8002346:	1c03      	adds	r3, r0, #0
 8002348:	491a      	ldr	r1, [pc, #104]	; (80023b4 <ADXL345_API_Scale_Axes+0x264>)
 800234a:	1c18      	adds	r0, r3, #0
 800234c:	f000 fed0 	bl	80030f0 <__aeabi_fmul>
 8002350:	1c03      	adds	r3, r0, #0
 8002352:	1c1a      	adds	r2, r3, #0
 8002354:	4b14      	ldr	r3, [pc, #80]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002356:	601a      	str	r2, [r3, #0]
                axes[ 1 ] = y_raw * 0.0312F;
 8002358:	2308      	movs	r3, #8
 800235a:	18fb      	adds	r3, r7, r3
 800235c:	2200      	movs	r2, #0
 800235e:	5e9b      	ldrsh	r3, [r3, r2]
 8002360:	0018      	movs	r0, r3
 8002362:	f001 f9b5 	bl	80036d0 <__aeabi_i2f>
 8002366:	1c03      	adds	r3, r0, #0
 8002368:	4912      	ldr	r1, [pc, #72]	; (80023b4 <ADXL345_API_Scale_Axes+0x264>)
 800236a:	1c18      	adds	r0, r3, #0
 800236c:	f000 fec0 	bl	80030f0 <__aeabi_fmul>
 8002370:	1c03      	adds	r3, r0, #0
 8002372:	1c1a      	adds	r2, r3, #0
 8002374:	4b0c      	ldr	r3, [pc, #48]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002376:	605a      	str	r2, [r3, #4]
                axes[ 2 ] = z_raw * 0.0312F;
 8002378:	1dbb      	adds	r3, r7, #6
 800237a:	2200      	movs	r2, #0
 800237c:	5e9b      	ldrsh	r3, [r3, r2]
 800237e:	0018      	movs	r0, r3
 8002380:	f001 f9a6 	bl	80036d0 <__aeabi_i2f>
 8002384:	1c03      	adds	r3, r0, #0
 8002386:	490b      	ldr	r1, [pc, #44]	; (80023b4 <ADXL345_API_Scale_Axes+0x264>)
 8002388:	1c18      	adds	r0, r3, #0
 800238a:	f000 feb1 	bl	80030f0 <__aeabi_fmul>
 800238e:	1c03      	adds	r3, r0, #0
 8002390:	1c1a      	adds	r2, r3, #0
 8002392:	4b05      	ldr	r3, [pc, #20]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
 8002394:	609a      	str	r2, [r3, #8]
                break;
 8002396:	e000      	b.n	800239a <ADXL345_API_Scale_Axes+0x24a>
                break;
 8002398:	46c0      	nop			; (mov r8, r8)
        }
    }

    /* Return address of array containing the scaled data */
    return axes;
 800239a:	4b03      	ldr	r3, [pc, #12]	; (80023a8 <ADXL345_API_Scale_Axes+0x258>)
}
 800239c:	0018      	movs	r0, r3
 800239e:	46bd      	mov	sp, r7
 80023a0:	b006      	add	sp, #24
 80023a2:	bdb0      	pop	{r4, r5, r7, pc}
 80023a4:	3b7f9724 	.word	0x3b7f9724
 80023a8:	20000058 	.word	0x20000058
 80023ac:	3bff9724 	.word	0x3bff9724
 80023b0:	3c7f9724 	.word	0x3c7f9724
 80023b4:	3cff9724 	.word	0x3cff9724

080023b8 <ADXL345_API_Enable_Int>:
       in the datasheet of the ADXL345 (max and min values of this should be scaled according to the
       "Self-Test Output Scale Factors for Different Supply Voltages, VS" table if necessary) */
}

void ADXL345_API_Enable_Int( ACCEL_HandleTypeDef *haccel, uint8_t int_enable, uint8_t int_map )
{
 80023b8:	b580      	push	{r7, lr}
 80023ba:	b082      	sub	sp, #8
 80023bc:	af00      	add	r7, sp, #0
 80023be:	6078      	str	r0, [r7, #4]
 80023c0:	0008      	movs	r0, r1
 80023c2:	0011      	movs	r1, r2
 80023c4:	1cfb      	adds	r3, r7, #3
 80023c6:	1c02      	adds	r2, r0, #0
 80023c8:	701a      	strb	r2, [r3, #0]
 80023ca:	1cbb      	adds	r3, r7, #2
 80023cc:	1c0a      	adds	r2, r1, #0
 80023ce:	701a      	strb	r2, [r3, #0]
    /* Disable all interrupts */
    haccel->intenable = 0x00;
 80023d0:	687b      	ldr	r3, [r7, #4]
 80023d2:	2200      	movs	r2, #0
 80023d4:	745a      	strb	r2, [r3, #17]
    ADXL345_Write( INT_ENABLE_REG, haccel->intenable );
 80023d6:	687b      	ldr	r3, [r7, #4]
 80023d8:	7c5b      	ldrb	r3, [r3, #17]
 80023da:	0019      	movs	r1, r3
 80023dc:	202e      	movs	r0, #46	; 0x2e
 80023de:	f7ff fc47 	bl	8001c70 <ADXL345_Write>

    /* Map interrupts to the specified INTx pin */
    haccel->intmap = int_map;
 80023e2:	687b      	ldr	r3, [r7, #4]
 80023e4:	1cba      	adds	r2, r7, #2
 80023e6:	7812      	ldrb	r2, [r2, #0]
 80023e8:	749a      	strb	r2, [r3, #18]
    ADXL345_Write( INT_MAP_REG, haccel->intmap );
 80023ea:	687b      	ldr	r3, [r7, #4]
 80023ec:	7c9b      	ldrb	r3, [r3, #18]
 80023ee:	0019      	movs	r1, r3
 80023f0:	202f      	movs	r0, #47	; 0x2f
 80023f2:	f7ff fc3d 	bl	8001c70 <ADXL345_Write>

    /* Enable user selected interrupts */
    haccel->intenable = int_enable;
 80023f6:	687b      	ldr	r3, [r7, #4]
 80023f8:	1cfa      	adds	r2, r7, #3
 80023fa:	7812      	ldrb	r2, [r2, #0]
 80023fc:	745a      	strb	r2, [r3, #17]
    ADXL345_Write( INT_ENABLE_REG, haccel->intenable );
 80023fe:	687b      	ldr	r3, [r7, #4]
 8002400:	7c5b      	ldrb	r3, [r3, #17]
 8002402:	0019      	movs	r1, r3
 8002404:	202e      	movs	r0, #46	; 0x2e
 8002406:	f7ff fc33 	bl	8001c70 <ADXL345_Write>

    /* NOTE: interrupts can be set active high or active low in INT_INVERT bit from DATA_FORMAT register */
}
 800240a:	46c0      	nop			; (mov r8, r8)
 800240c:	46bd      	mov	sp, r7
 800240e:	b002      	add	sp, #8
 8002410:	bd80      	pop	{r7, pc}

08002412 <ADXL345_API_Disable_Int>:

void ADXL345_API_Disable_Int( ACCEL_HandleTypeDef *haccel, uint8_t interrupts )
{
 8002412:	b580      	push	{r7, lr}
 8002414:	b082      	sub	sp, #8
 8002416:	af00      	add	r7, sp, #0
 8002418:	6078      	str	r0, [r7, #4]
 800241a:	000a      	movs	r2, r1
 800241c:	1cfb      	adds	r3, r7, #3
 800241e:	701a      	strb	r2, [r3, #0]
    /* Disable selected interrupts */
    haccel->intenable &= ~interrupts;
 8002420:	687b      	ldr	r3, [r7, #4]
 8002422:	7c5b      	ldrb	r3, [r3, #17]
 8002424:	b25b      	sxtb	r3, r3
 8002426:	1cfa      	adds	r2, r7, #3
 8002428:	7812      	ldrb	r2, [r2, #0]
 800242a:	b252      	sxtb	r2, r2
 800242c:	43d2      	mvns	r2, r2
 800242e:	b252      	sxtb	r2, r2
 8002430:	4013      	ands	r3, r2
 8002432:	b25b      	sxtb	r3, r3
 8002434:	b2da      	uxtb	r2, r3
 8002436:	687b      	ldr	r3, [r7, #4]
 8002438:	745a      	strb	r2, [r3, #17]
    ADXL345_Write( INT_ENABLE_REG, haccel->intenable );
 800243a:	687b      	ldr	r3, [r7, #4]
 800243c:	7c5b      	ldrb	r3, [r3, #17]
 800243e:	0019      	movs	r1, r3
 8002440:	202e      	movs	r0, #46	; 0x2e
 8002442:	f7ff fc15 	bl	8001c70 <ADXL345_Write>
}
 8002446:	46c0      	nop			; (mov r8, r8)
 8002448:	46bd      	mov	sp, r7
 800244a:	b002      	add	sp, #8
 800244c:	bd80      	pop	{r7, pc}

0800244e <ADXL345_API_Read_Tap_Source>:
    source = ADXL345_Read( INT_SOURCE_REG );
    return source;
}

uint8_t ADXL345_API_Read_Tap_Source( ACCEL_HandleTypeDef *haccel )
{
 800244e:	b5b0      	push	{r4, r5, r7, lr}
 8002450:	b084      	sub	sp, #16
 8002452:	af00      	add	r7, sp, #0
 8002454:	6078      	str	r0, [r7, #4]
    uint8_t axis_tap_source;

    /* Read ACT_TAP_STATUS register through SPI in order to know which axis exceeded the THRESH_TAP */
    axis_tap_source = ADXL345_Read( ACT_TAP_STATUS_REG );
 8002456:	250f      	movs	r5, #15
 8002458:	197c      	adds	r4, r7, r5
 800245a:	202b      	movs	r0, #43	; 0x2b
 800245c:	f7ff fc2a 	bl	8001cb4 <ADXL345_Read>
 8002460:	0003      	movs	r3, r0
 8002462:	7023      	strb	r3, [r4, #0]

    /* Get bits regarding single tap generation axes */
    axis_tap_source &= ( TAP_X_SOURCE | TAP_Y_ENABLED | TAP_Z_SOURCE );
 8002464:	0028      	movs	r0, r5
 8002466:	183b      	adds	r3, r7, r0
 8002468:	183a      	adds	r2, r7, r0
 800246a:	7812      	ldrb	r2, [r2, #0]
 800246c:	2107      	movs	r1, #7
 800246e:	400a      	ands	r2, r1
 8002470:	701a      	strb	r2, [r3, #0]

    /* Return axis responsible for single tap interrupt */
    return axis_tap_source;
 8002472:	183b      	adds	r3, r7, r0
 8002474:	781b      	ldrb	r3, [r3, #0]
}
 8002476:	0018      	movs	r0, r3
 8002478:	46bd      	mov	sp, r7
 800247a:	b004      	add	sp, #16
 800247c:	bdb0      	pop	{r4, r5, r7, pc}

0800247e <ADXL345_API_Read_Activity_Source>:

uint8_t ADXL345_API_Read_Activity_Source( ACCEL_HandleTypeDef *haccel )
{
 800247e:	b5b0      	push	{r4, r5, r7, lr}
 8002480:	b084      	sub	sp, #16
 8002482:	af00      	add	r7, sp, #0
 8002484:	6078      	str	r0, [r7, #4]
    uint8_t axis_act_source;

    /* Read ACT_TAP_STATUS register through SPI in order to know which axis first detected activity */
    axis_act_source = ADXL345_Read( ACT_TAP_STATUS_REG );
 8002486:	250f      	movs	r5, #15
 8002488:	197c      	adds	r4, r7, r5
 800248a:	202b      	movs	r0, #43	; 0x2b
 800248c:	f7ff fc12 	bl	8001cb4 <ADXL345_Read>
 8002490:	0003      	movs	r3, r0
 8002492:	7023      	strb	r3, [r4, #0]

    /* Get bits regarding activity axes */
    axis_act_source &= ( ACT_X_SOURCE | ACT_Y_SOURCE | ACT_Y_SOURCE );
 8002494:	0028      	movs	r0, r5
 8002496:	183b      	adds	r3, r7, r0
 8002498:	183a      	adds	r2, r7, r0
 800249a:	7812      	ldrb	r2, [r2, #0]
 800249c:	2160      	movs	r1, #96	; 0x60
 800249e:	400a      	ands	r2, r1
 80024a0:	701a      	strb	r2, [r3, #0]

    /* Return axis responsible for activity interrupt */
    return axis_act_source;
 80024a2:	183b      	adds	r3, r7, r0
 80024a4:	781b      	ldrb	r3, [r3, #0]
}
 80024a6:	0018      	movs	r0, r3
 80024a8:	46bd      	mov	sp, r7
 80024aa:	b004      	add	sp, #16
 80024ac:	bdb0      	pop	{r4, r5, r7, pc}

080024ae <ADXL345_API_Read_FIFO_Entries>:

uint8_t ADXL345_API_Read_FIFO_Entries( ACCEL_HandleTypeDef *haccel )
{
 80024ae:	b5b0      	push	{r4, r5, r7, lr}
 80024b0:	b084      	sub	sp, #16
 80024b2:	af00      	add	r7, sp, #0
 80024b4:	6078      	str	r0, [r7, #4]
    uint8_t entries;

    /* Read FIFO_STATUS register */
    entries = ADXL345_Read( FIFO_STATUS_REG );
 80024b6:	250f      	movs	r5, #15
 80024b8:	197c      	adds	r4, r7, r5
 80024ba:	2039      	movs	r0, #57	; 0x39
 80024bc:	f7ff fbfa 	bl	8001cb4 <ADXL345_Read>
 80024c0:	0003      	movs	r3, r0
 80024c2:	7023      	strb	r3, [r4, #0]

    /* Keep ENTRIES bits in the FIFO_STATUS register */
    entries &= ENTRIES_BITS_MASK;
 80024c4:	0028      	movs	r0, r5
 80024c6:	183b      	adds	r3, r7, r0
 80024c8:	183a      	adds	r2, r7, r0
 80024ca:	7812      	ldrb	r2, [r2, #0]
 80024cc:	213f      	movs	r1, #63	; 0x3f
 80024ce:	400a      	ands	r2, r1
 80024d0:	701a      	strb	r2, [r3, #0]

    /* Return number of entries stored in FIFO */
    return entries;
 80024d2:	183b      	adds	r3, r7, r0
 80024d4:	781b      	ldrb	r3, [r3, #0]
}
 80024d6:	0018      	movs	r0, r3
 80024d8:	46bd      	mov	sp, r7
 80024da:	b004      	add	sp, #16
 80024dc:	bdb0      	pop	{r4, r5, r7, pc}

080024de <uint16_t_to_string>:
#include "print_lcd.h"

uint8_t *uint16_t_to_string( uint16_t value, uint8_t *dest_str )
{
 80024de:	b5b0      	push	{r4, r5, r7, lr}
 80024e0:	b084      	sub	sp, #16
 80024e2:	af00      	add	r7, sp, #0
 80024e4:	0002      	movs	r2, r0
 80024e6:	6039      	str	r1, [r7, #0]
 80024e8:	1dbb      	adds	r3, r7, #6
 80024ea:	801a      	strh	r2, [r3, #0]
   uint8_t item = 0U;
 80024ec:	210f      	movs	r1, #15
 80024ee:	187b      	adds	r3, r7, r1
 80024f0:	2200      	movs	r2, #0
 80024f2:	701a      	strb	r2, [r3, #0]
    
   /* Store the '0' character when decimal value is 0 */
   if ( value == 0U )
 80024f4:	1dbb      	adds	r3, r7, #6
 80024f6:	881b      	ldrh	r3, [r3, #0]
 80024f8:	2b00      	cmp	r3, #0
 80024fa:	d12a      	bne.n	8002552 <uint16_t_to_string+0x74>
   {
      dest_str[ item ] = '0';
 80024fc:	187b      	adds	r3, r7, r1
 80024fe:	781b      	ldrb	r3, [r3, #0]
 8002500:	683a      	ldr	r2, [r7, #0]
 8002502:	18d3      	adds	r3, r2, r3
 8002504:	2230      	movs	r2, #48	; 0x30
 8002506:	701a      	strb	r2, [r3, #0]
        
      item++;
 8002508:	187b      	adds	r3, r7, r1
 800250a:	781a      	ldrb	r2, [r3, #0]
 800250c:	187b      	adds	r3, r7, r1
 800250e:	3201      	adds	r2, #1
 8002510:	701a      	strb	r2, [r3, #0]
   }
    
   /* Split the digits of the integer and store each into the string.
      NOTE: string is stored backwards */
   while ( value > 0U )
 8002512:	e01e      	b.n	8002552 <uint16_t_to_string+0x74>
   {
      dest_str[ item ] = ( value % 10 ) + '0';
 8002514:	1dbb      	adds	r3, r7, #6
 8002516:	881b      	ldrh	r3, [r3, #0]
 8002518:	210a      	movs	r1, #10
 800251a:	0018      	movs	r0, r3
 800251c:	f7fd fe56 	bl	80001cc <__aeabi_uidivmod>
 8002520:	000b      	movs	r3, r1
 8002522:	b29b      	uxth	r3, r3
 8002524:	b2da      	uxtb	r2, r3
 8002526:	250f      	movs	r5, #15
 8002528:	197b      	adds	r3, r7, r5
 800252a:	781b      	ldrb	r3, [r3, #0]
 800252c:	6839      	ldr	r1, [r7, #0]
 800252e:	18cb      	adds	r3, r1, r3
 8002530:	3230      	adds	r2, #48	; 0x30
 8002532:	b2d2      	uxtb	r2, r2
 8002534:	701a      	strb	r2, [r3, #0]
      value /= 10U;
 8002536:	1dbc      	adds	r4, r7, #6
 8002538:	1dbb      	adds	r3, r7, #6
 800253a:	881b      	ldrh	r3, [r3, #0]
 800253c:	210a      	movs	r1, #10
 800253e:	0018      	movs	r0, r3
 8002540:	f7fd fdbe 	bl	80000c0 <__udivsi3>
 8002544:	0003      	movs	r3, r0
 8002546:	8023      	strh	r3, [r4, #0]

      item++;
 8002548:	197b      	adds	r3, r7, r5
 800254a:	781a      	ldrb	r2, [r3, #0]
 800254c:	197b      	adds	r3, r7, r5
 800254e:	3201      	adds	r2, #1
 8002550:	701a      	strb	r2, [r3, #0]
   while ( value > 0U )
 8002552:	1dbb      	adds	r3, r7, #6
 8002554:	881b      	ldrh	r3, [r3, #0]
 8002556:	2b00      	cmp	r3, #0
 8002558:	d1dc      	bne.n	8002514 <uint16_t_to_string+0x36>
   }

   /* Add termination null character '\0' */
   dest_str[ item ] = '\0';
 800255a:	230f      	movs	r3, #15
 800255c:	18fb      	adds	r3, r7, r3
 800255e:	781b      	ldrb	r3, [r3, #0]
 8002560:	683a      	ldr	r2, [r7, #0]
 8002562:	18d3      	adds	r3, r2, r3
 8002564:	2200      	movs	r2, #0
 8002566:	701a      	strb	r2, [r3, #0]
    
   ( void ) reverse_string( dest_str );
 8002568:	683b      	ldr	r3, [r7, #0]
 800256a:	0018      	movs	r0, r3
 800256c:	f000 f805 	bl	800257a <reverse_string>
    
   return dest_str;
 8002570:	683b      	ldr	r3, [r7, #0]
}
 8002572:	0018      	movs	r0, r3
 8002574:	46bd      	mov	sp, r7
 8002576:	b004      	add	sp, #16
 8002578:	bdb0      	pop	{r4, r5, r7, pc}

0800257a <reverse_string>:

uint8_t *reverse_string( uint8_t *src_string )
{
 800257a:	b5b0      	push	{r4, r5, r7, lr}
 800257c:	b084      	sub	sp, #16
 800257e:	af00      	add	r7, sp, #0
 8002580:	6078      	str	r0, [r7, #4]
   uint8_t start = 0U;
 8002582:	210f      	movs	r1, #15
 8002584:	187b      	adds	r3, r7, r1
 8002586:	2200      	movs	r2, #0
 8002588:	701a      	strb	r2, [r3, #0]
   uint8_t end;
   uint8_t temp;
    
   /* Find the end of the string */
   for ( end = start; src_string[ end ] != '\0'; end++ )
 800258a:	230e      	movs	r3, #14
 800258c:	18fb      	adds	r3, r7, r3
 800258e:	187a      	adds	r2, r7, r1
 8002590:	7812      	ldrb	r2, [r2, #0]
 8002592:	701a      	strb	r2, [r3, #0]
 8002594:	e005      	b.n	80025a2 <reverse_string+0x28>
 8002596:	210e      	movs	r1, #14
 8002598:	187b      	adds	r3, r7, r1
 800259a:	781a      	ldrb	r2, [r3, #0]
 800259c:	187b      	adds	r3, r7, r1
 800259e:	3201      	adds	r2, #1
 80025a0:	701a      	strb	r2, [r3, #0]
 80025a2:	210e      	movs	r1, #14
 80025a4:	187b      	adds	r3, r7, r1
 80025a6:	781b      	ldrb	r3, [r3, #0]
 80025a8:	687a      	ldr	r2, [r7, #4]
 80025aa:	18d3      	adds	r3, r2, r3
 80025ac:	781b      	ldrb	r3, [r3, #0]
 80025ae:	2b00      	cmp	r3, #0
 80025b0:	d1f1      	bne.n	8002596 <reverse_string+0x1c>
   {
      /* Do nothing */ 
   }
    
   end--;
 80025b2:	187b      	adds	r3, r7, r1
 80025b4:	781a      	ldrb	r2, [r3, #0]
 80025b6:	187b      	adds	r3, r7, r1
 80025b8:	3a01      	subs	r2, #1
 80025ba:	701a      	strb	r2, [r3, #0]
    
   /* Switch start and end elements successively */
   while ( start < end )
 80025bc:	e025      	b.n	800260a <reverse_string+0x90>
   {
      temp = src_string[ start ];
 80025be:	200f      	movs	r0, #15
 80025c0:	183b      	adds	r3, r7, r0
 80025c2:	781b      	ldrb	r3, [r3, #0]
 80025c4:	687a      	ldr	r2, [r7, #4]
 80025c6:	18d2      	adds	r2, r2, r3
 80025c8:	250d      	movs	r5, #13
 80025ca:	197b      	adds	r3, r7, r5
 80025cc:	7812      	ldrb	r2, [r2, #0]
 80025ce:	701a      	strb	r2, [r3, #0]
        
      src_string[ start ] = src_string[ end ];
 80025d0:	240e      	movs	r4, #14
 80025d2:	193b      	adds	r3, r7, r4
 80025d4:	781b      	ldrb	r3, [r3, #0]
 80025d6:	687a      	ldr	r2, [r7, #4]
 80025d8:	18d2      	adds	r2, r2, r3
 80025da:	183b      	adds	r3, r7, r0
 80025dc:	781b      	ldrb	r3, [r3, #0]
 80025de:	6879      	ldr	r1, [r7, #4]
 80025e0:	18cb      	adds	r3, r1, r3
 80025e2:	7812      	ldrb	r2, [r2, #0]
 80025e4:	701a      	strb	r2, [r3, #0]
      src_string[ end ] = temp;
 80025e6:	0021      	movs	r1, r4
 80025e8:	187b      	adds	r3, r7, r1
 80025ea:	781b      	ldrb	r3, [r3, #0]
 80025ec:	687a      	ldr	r2, [r7, #4]
 80025ee:	18d3      	adds	r3, r2, r3
 80025f0:	197a      	adds	r2, r7, r5
 80025f2:	7812      	ldrb	r2, [r2, #0]
 80025f4:	701a      	strb	r2, [r3, #0]
        
      start++;
 80025f6:	183b      	adds	r3, r7, r0
 80025f8:	781a      	ldrb	r2, [r3, #0]
 80025fa:	183b      	adds	r3, r7, r0
 80025fc:	3201      	adds	r2, #1
 80025fe:	701a      	strb	r2, [r3, #0]
      end--;
 8002600:	187b      	adds	r3, r7, r1
 8002602:	781a      	ldrb	r2, [r3, #0]
 8002604:	187b      	adds	r3, r7, r1
 8002606:	3a01      	subs	r2, #1
 8002608:	701a      	strb	r2, [r3, #0]
   while ( start < end )
 800260a:	230f      	movs	r3, #15
 800260c:	18fa      	adds	r2, r7, r3
 800260e:	230e      	movs	r3, #14
 8002610:	18fb      	adds	r3, r7, r3
 8002612:	7812      	ldrb	r2, [r2, #0]
 8002614:	781b      	ldrb	r3, [r3, #0]
 8002616:	429a      	cmp	r2, r3
 8002618:	d3d1      	bcc.n	80025be <reverse_string+0x44>
   }
    
   return src_string;
 800261a:	687b      	ldr	r3, [r7, #4]
}
 800261c:	0018      	movs	r0, r3
 800261e:	46bd      	mov	sp, r7
 8002620:	b004      	add	sp, #16
 8002622:	bdb0      	pop	{r4, r5, r7, pc}

08002624 <lcd_print_one_axis_info>:

void lcd_print_one_axis_info( LCD_HandleTypeDef *hlcd, float axis )
{
 8002624:	b5b0      	push	{r4, r5, r7, lr}
 8002626:	b084      	sub	sp, #16
 8002628:	af00      	add	r7, sp, #0
 800262a:	6078      	str	r0, [r7, #4]
 800262c:	6039      	str	r1, [r7, #0]
   uint8_t str[ 4 ];
   int8_t integer;
   int16_t fractional;
   uint8_t extradigs = 3U;
 800262e:	230e      	movs	r3, #14
 8002630:	18fb      	adds	r3, r7, r3
 8002632:	2203      	movs	r2, #3
 8002634:	701a      	strb	r2, [r3, #0]

   /* Get the integer part of the x axis data */
   integer = ( int8_t ) axis;
 8002636:	250f      	movs	r5, #15
 8002638:	197c      	adds	r4, r7, r5
 800263a:	6838      	ldr	r0, [r7, #0]
 800263c:	f001 f828 	bl	8003690 <__aeabi_f2iz>
 8002640:	0003      	movs	r3, r0
 8002642:	7023      	strb	r3, [r4, #0]

   /* If x axis value is negative */
   if ( axis < 0 )
 8002644:	2100      	movs	r1, #0
 8002646:	6838      	ldr	r0, [r7, #0]
 8002648:	f7fd fdd8 	bl	80001fc <__aeabi_fcmplt>
 800264c:	1e03      	subs	r3, r0, #0
 800264e:	d00c      	beq.n	800266a <lcd_print_one_axis_info+0x46>
   {
      /* Convert the integer part of the x axis data to its unsiged form 
         by reverting 2's and 1's complement */
      integer = ~( integer - 1 );
 8002650:	0029      	movs	r1, r5
 8002652:	187b      	adds	r3, r7, r1
 8002654:	781b      	ldrb	r3, [r3, #0]
 8002656:	425b      	negs	r3, r3
 8002658:	b2da      	uxtb	r2, r3
 800265a:	187b      	adds	r3, r7, r1
 800265c:	701a      	strb	r2, [r3, #0]

      /* Print negative sign */
      LCD_API_Print_Character( hlcd, '-' );
 800265e:	687b      	ldr	r3, [r7, #4]
 8002660:	212d      	movs	r1, #45	; 0x2d
 8002662:	0018      	movs	r0, r3
 8002664:	f7ff f86a 	bl	800173c <LCD_API_Print_Character>
 8002668:	e004      	b.n	8002674 <lcd_print_one_axis_info+0x50>
   }
   /* If x axis value is negative */
   else
   {
      /* Print positive sign */
      LCD_API_Print_Character( hlcd, '+' );
 800266a:	687b      	ldr	r3, [r7, #4]
 800266c:	212b      	movs	r1, #43	; 0x2b
 800266e:	0018      	movs	r0, r3
 8002670:	f7ff f864 	bl	800173c <LCD_API_Print_Character>
   }

   /* Convert the integer part of the x axis into a string */
   ( void ) uint16_t_to_string( integer, str );
 8002674:	240f      	movs	r4, #15
 8002676:	193b      	adds	r3, r7, r4
 8002678:	781b      	ldrb	r3, [r3, #0]
 800267a:	b25b      	sxtb	r3, r3
 800267c:	b29b      	uxth	r3, r3
 800267e:	2208      	movs	r2, #8
 8002680:	18ba      	adds	r2, r7, r2
 8002682:	0011      	movs	r1, r2
 8002684:	0018      	movs	r0, r3
 8002686:	f7ff ff2a 	bl	80024de <uint16_t_to_string>

   /* If integer part has only 1 digit */
   if ( ( integer / 10 ) < 1 )
 800268a:	193b      	adds	r3, r7, r4
 800268c:	781b      	ldrb	r3, [r3, #0]
 800268e:	b25b      	sxtb	r3, r3
 8002690:	2b09      	cmp	r3, #9
 8002692:	dc04      	bgt.n	800269e <lcd_print_one_axis_info+0x7a>
   {
      /* Append a '0' character to the left */
      LCD_API_Print_Character( hlcd, '0' );
 8002694:	687b      	ldr	r3, [r7, #4]
 8002696:	2130      	movs	r1, #48	; 0x30
 8002698:	0018      	movs	r0, r3
 800269a:	f7ff f84f 	bl	800173c <LCD_API_Print_Character>
   }

   /* Print the integer part of the x axis */
   LCD_API_Print_String( hlcd, str, 2 );
 800269e:	2308      	movs	r3, #8
 80026a0:	18f9      	adds	r1, r7, r3
 80026a2:	687b      	ldr	r3, [r7, #4]
 80026a4:	2202      	movs	r2, #2
 80026a6:	0018      	movs	r0, r3
 80026a8:	f7ff f862 	bl	8001770 <LCD_API_Print_String>

   /* Print decimal point character */
   LCD_API_Print_Character( hlcd, '.' );
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	212e      	movs	r1, #46	; 0x2e
 80026b0:	0018      	movs	r0, r3
 80026b2:	f7ff f843 	bl	800173c <LCD_API_Print_Character>

   /* Get the fractional part of the x axis data by subtracting the integer portion */
   axis = ( axis >= 0 ) ? ( axis - integer ) : ( axis + integer );
 80026b6:	2100      	movs	r1, #0
 80026b8:	6838      	ldr	r0, [r7, #0]
 80026ba:	f7fd fdbd 	bl	8000238 <__aeabi_fcmpge>
 80026be:	1e03      	subs	r3, r0, #0
 80026c0:	d00d      	beq.n	80026de <lcd_print_one_axis_info+0xba>
 80026c2:	230f      	movs	r3, #15
 80026c4:	18fb      	adds	r3, r7, r3
 80026c6:	781b      	ldrb	r3, [r3, #0]
 80026c8:	b25b      	sxtb	r3, r3
 80026ca:	0018      	movs	r0, r3
 80026cc:	f001 f800 	bl	80036d0 <__aeabi_i2f>
 80026d0:	1c03      	adds	r3, r0, #0
 80026d2:	1c19      	adds	r1, r3, #0
 80026d4:	6838      	ldr	r0, [r7, #0]
 80026d6:	f000 fe49 	bl	800336c <__aeabi_fsub>
 80026da:	1c03      	adds	r3, r0, #0
 80026dc:	e00c      	b.n	80026f8 <lcd_print_one_axis_info+0xd4>
 80026de:	230f      	movs	r3, #15
 80026e0:	18fb      	adds	r3, r7, r3
 80026e2:	781b      	ldrb	r3, [r3, #0]
 80026e4:	b25b      	sxtb	r3, r3
 80026e6:	0018      	movs	r0, r3
 80026e8:	f000 fff2 	bl	80036d0 <__aeabi_i2f>
 80026ec:	1c03      	adds	r3, r0, #0
 80026ee:	6839      	ldr	r1, [r7, #0]
 80026f0:	1c18      	adds	r0, r3, #0
 80026f2:	f000 fab5 	bl	8002c60 <__aeabi_fadd>
 80026f6:	1c03      	adds	r3, r0, #0
 80026f8:	603b      	str	r3, [r7, #0]

   /* Convert the fractional part of the x axis data to unsigned integer format,
      4 digits to the right of the decimal point are obtained when multiplying by 10000 */
   fractional = ( axis >= 0 ) ? ( axis * 10000 ) : ( axis * -10000 );
 80026fa:	2100      	movs	r1, #0
 80026fc:	6838      	ldr	r0, [r7, #0]
 80026fe:	f7fd fd9b 	bl	8000238 <__aeabi_fcmpge>
 8002702:	1e03      	subs	r3, r0, #0
 8002704:	d00a      	beq.n	800271c <lcd_print_one_axis_info+0xf8>
 8002706:	492f      	ldr	r1, [pc, #188]	; (80027c4 <lcd_print_one_axis_info+0x1a0>)
 8002708:	6838      	ldr	r0, [r7, #0]
 800270a:	f000 fcf1 	bl	80030f0 <__aeabi_fmul>
 800270e:	1c03      	adds	r3, r0, #0
 8002710:	1c18      	adds	r0, r3, #0
 8002712:	f000 ffbd 	bl	8003690 <__aeabi_f2iz>
 8002716:	0003      	movs	r3, r0
 8002718:	b21b      	sxth	r3, r3
 800271a:	e009      	b.n	8002730 <lcd_print_one_axis_info+0x10c>
 800271c:	492a      	ldr	r1, [pc, #168]	; (80027c8 <lcd_print_one_axis_info+0x1a4>)
 800271e:	6838      	ldr	r0, [r7, #0]
 8002720:	f000 fce6 	bl	80030f0 <__aeabi_fmul>
 8002724:	1c03      	adds	r3, r0, #0
 8002726:	1c18      	adds	r0, r3, #0
 8002728:	f000 ffb2 	bl	8003690 <__aeabi_f2iz>
 800272c:	0003      	movs	r3, r0
 800272e:	b21b      	sxth	r3, r3
 8002730:	210c      	movs	r1, #12
 8002732:	187a      	adds	r2, r7, r1
 8002734:	8013      	strh	r3, [r2, #0]

   /* Obtain the number of digits in the fractional portion, this indicates the number
      of zeros that must be introduced to the right of the decimal point */
   if ( ( fractional / 10 ) < 1 )
 8002736:	187b      	adds	r3, r7, r1
 8002738:	2200      	movs	r2, #0
 800273a:	5e9b      	ldrsh	r3, [r3, r2]
 800273c:	2b09      	cmp	r3, #9
 800273e:	dc0a      	bgt.n	8002756 <lcd_print_one_axis_info+0x132>
   {
      LCD_API_Print_String( hlcd, ( uint8_t* ) "000", 3 );
 8002740:	4922      	ldr	r1, [pc, #136]	; (80027cc <lcd_print_one_axis_info+0x1a8>)
 8002742:	687b      	ldr	r3, [r7, #4]
 8002744:	2203      	movs	r2, #3
 8002746:	0018      	movs	r0, r3
 8002748:	f7ff f812 	bl	8001770 <LCD_API_Print_String>

      extradigs = 0U;
 800274c:	230e      	movs	r3, #14
 800274e:	18fb      	adds	r3, r7, r3
 8002750:	2200      	movs	r2, #0
 8002752:	701a      	strb	r2, [r3, #0]
 8002754:	e021      	b.n	800279a <lcd_print_one_axis_info+0x176>
   }
   else if ( ( fractional / 100 ) < 1 )
 8002756:	230c      	movs	r3, #12
 8002758:	18fb      	adds	r3, r7, r3
 800275a:	2200      	movs	r2, #0
 800275c:	5e9b      	ldrsh	r3, [r3, r2]
 800275e:	2b63      	cmp	r3, #99	; 0x63
 8002760:	dc0a      	bgt.n	8002778 <lcd_print_one_axis_info+0x154>
   {
      LCD_API_Print_String( hlcd, ( uint8_t* ) "00", 2 );
 8002762:	491b      	ldr	r1, [pc, #108]	; (80027d0 <lcd_print_one_axis_info+0x1ac>)
 8002764:	687b      	ldr	r3, [r7, #4]
 8002766:	2202      	movs	r2, #2
 8002768:	0018      	movs	r0, r3
 800276a:	f7ff f801 	bl	8001770 <LCD_API_Print_String>

      /* Indicate number of extra digits to print to the right of the decimal point,
         this does not include the 2 previous zeros appended, i.e: 3 digs in total */
      extradigs = 1U;
 800276e:	230e      	movs	r3, #14
 8002770:	18fb      	adds	r3, r7, r3
 8002772:	2201      	movs	r2, #1
 8002774:	701a      	strb	r2, [r3, #0]
 8002776:	e010      	b.n	800279a <lcd_print_one_axis_info+0x176>
   }
   else if ( ( fractional / 1000 ) < 1 )
 8002778:	230c      	movs	r3, #12
 800277a:	18fb      	adds	r3, r7, r3
 800277c:	2200      	movs	r2, #0
 800277e:	5e9a      	ldrsh	r2, [r3, r2]
 8002780:	23fa      	movs	r3, #250	; 0xfa
 8002782:	009b      	lsls	r3, r3, #2
 8002784:	429a      	cmp	r2, r3
 8002786:	da08      	bge.n	800279a <lcd_print_one_axis_info+0x176>
   {
      LCD_API_Print_Character( hlcd, '0' );
 8002788:	687b      	ldr	r3, [r7, #4]
 800278a:	2130      	movs	r1, #48	; 0x30
 800278c:	0018      	movs	r0, r3
 800278e:	f7fe ffd5 	bl	800173c <LCD_API_Print_Character>
      
      /* Indicate number of extra digits to print to the right of the decimal point,
         this does not include the previous zero appended, i.e: 3 digs in total */
      extradigs = 2U;
 8002792:	230e      	movs	r3, #14
 8002794:	18fb      	adds	r3, r7, r3
 8002796:	2202      	movs	r2, #2
 8002798:	701a      	strb	r2, [r3, #0]
   }

   /* Convert the fractional part to a string */
   ( void ) uint16_t_to_string( fractional, str );
 800279a:	230c      	movs	r3, #12
 800279c:	18fb      	adds	r3, r7, r3
 800279e:	881b      	ldrh	r3, [r3, #0]
 80027a0:	2408      	movs	r4, #8
 80027a2:	193a      	adds	r2, r7, r4
 80027a4:	0011      	movs	r1, r2
 80027a6:	0018      	movs	r0, r3
 80027a8:	f7ff fe99 	bl	80024de <uint16_t_to_string>

   /* Print the fractional part */
   LCD_API_Print_String( hlcd, str, extradigs );
 80027ac:	230e      	movs	r3, #14
 80027ae:	18fb      	adds	r3, r7, r3
 80027b0:	781a      	ldrb	r2, [r3, #0]
 80027b2:	1939      	adds	r1, r7, r4
 80027b4:	687b      	ldr	r3, [r7, #4]
 80027b6:	0018      	movs	r0, r3
 80027b8:	f7fe ffda 	bl	8001770 <LCD_API_Print_String>
}
 80027bc:	46c0      	nop			; (mov r8, r8)
 80027be:	46bd      	mov	sp, r7
 80027c0:	b004      	add	sp, #16
 80027c2:	bdb0      	pop	{r4, r5, r7, pc}
 80027c4:	461c4000 	.word	0x461c4000
 80027c8:	c61c4000 	.word	0xc61c4000
 80027cc:	080037c8 	.word	0x080037c8
 80027d0:	080037cc 	.word	0x080037cc

080027d4 <lcd_print_all_axes_info>:

void lcd_print_all_axes_info( LCD_HandleTypeDef *hlcd, float x, float y, float z )
{
 80027d4:	b580      	push	{r7, lr}
 80027d6:	b084      	sub	sp, #16
 80027d8:	af00      	add	r7, sp, #0
 80027da:	60f8      	str	r0, [r7, #12]
 80027dc:	60b9      	str	r1, [r7, #8]
 80027de:	607a      	str	r2, [r7, #4]
 80027e0:	603b      	str	r3, [r7, #0]
   /* Move cursor to first row and first column on the LCD */
   LCD_API_Move_Cursor( hlcd, 0U, 0U );
 80027e2:	68fb      	ldr	r3, [r7, #12]
 80027e4:	2200      	movs	r2, #0
 80027e6:	2100      	movs	r1, #0
 80027e8:	0018      	movs	r0, r3
 80027ea:	f7fe ff79 	bl	80016e0 <LCD_API_Move_Cursor>

   /* Print x axis data */
   lcd_print_one_axis_info( hlcd, x );
 80027ee:	68ba      	ldr	r2, [r7, #8]
 80027f0:	68fb      	ldr	r3, [r7, #12]
 80027f2:	1c11      	adds	r1, r2, #0
 80027f4:	0018      	movs	r0, r3
 80027f6:	f7ff ff15 	bl	8002624 <lcd_print_one_axis_info>

   /* Print 'X' character to indicate previous data belongs to the x axis  */
   LCD_API_Print_Character( hlcd, 'X' );
 80027fa:	68fb      	ldr	r3, [r7, #12]
 80027fc:	2158      	movs	r1, #88	; 0x58
 80027fe:	0018      	movs	r0, r3
 8002800:	f7fe ff9c 	bl	800173c <LCD_API_Print_Character>

   /* Move cursor to first row and ninth column on the LCD */
   LCD_API_Move_Cursor( hlcd, 0U, 8U );
 8002804:	68fb      	ldr	r3, [r7, #12]
 8002806:	2208      	movs	r2, #8
 8002808:	2100      	movs	r1, #0
 800280a:	0018      	movs	r0, r3
 800280c:	f7fe ff68 	bl	80016e0 <LCD_API_Move_Cursor>

   /* Print y axis data */
   lcd_print_one_axis_info( hlcd, y );
 8002810:	687a      	ldr	r2, [r7, #4]
 8002812:	68fb      	ldr	r3, [r7, #12]
 8002814:	1c11      	adds	r1, r2, #0
 8002816:	0018      	movs	r0, r3
 8002818:	f7ff ff04 	bl	8002624 <lcd_print_one_axis_info>

   /* Print 'Y' character to indicate previous data belongs to the x axis  */
   LCD_API_Print_Character( hlcd, 'Y' );
 800281c:	68fb      	ldr	r3, [r7, #12]
 800281e:	2159      	movs	r1, #89	; 0x59
 8002820:	0018      	movs	r0, r3
 8002822:	f7fe ff8b 	bl	800173c <LCD_API_Print_Character>

   /* Move cursor to second row and fifth column on the LCD */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002826:	68fb      	ldr	r3, [r7, #12]
 8002828:	2204      	movs	r2, #4
 800282a:	2101      	movs	r1, #1
 800282c:	0018      	movs	r0, r3
 800282e:	f7fe ff57 	bl	80016e0 <LCD_API_Move_Cursor>

   /* Print z axis data */
   lcd_print_one_axis_info( hlcd, z );
 8002832:	683a      	ldr	r2, [r7, #0]
 8002834:	68fb      	ldr	r3, [r7, #12]
 8002836:	1c11      	adds	r1, r2, #0
 8002838:	0018      	movs	r0, r3
 800283a:	f7ff fef3 	bl	8002624 <lcd_print_one_axis_info>

   /* Print 'Z' character to indicate previous data belongs to the x axis. 
      NOTE: 2 extra spaces are for clearing possible axes printed due to inactivity event */
   LCD_API_Print_String( hlcd, ( uint8_t* ) "Z  ", 3U );
 800283e:	4905      	ldr	r1, [pc, #20]	; (8002854 <lcd_print_all_axes_info+0x80>)
 8002840:	68fb      	ldr	r3, [r7, #12]
 8002842:	2203      	movs	r2, #3
 8002844:	0018      	movs	r0, r3
 8002846:	f7fe ff93 	bl	8001770 <LCD_API_Print_String>
}
 800284a:	46c0      	nop			; (mov r8, r8)
 800284c:	46bd      	mov	sp, r7
 800284e:	b004      	add	sp, #16
 8002850:	bd80      	pop	{r7, pc}
 8002852:	46c0      	nop			; (mov r8, r8)
 8002854:	080037d0 	.word	0x080037d0

08002858 <lcd_print_single_tap>:

void lcd_print_single_tap( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, uint8_t tap_source, float thresh_tap )
{
 8002858:	b580      	push	{r7, lr}
 800285a:	b084      	sub	sp, #16
 800285c:	af00      	add	r7, sp, #0
 800285e:	60f8      	str	r0, [r7, #12]
 8002860:	60b9      	str	r1, [r7, #8]
 8002862:	603b      	str	r3, [r7, #0]
 8002864:	1dfb      	adds	r3, r7, #7
 8002866:	701a      	strb	r2, [r3, #0]

   /* Move cursor and print "SINGLE TAP >" */
   LCD_API_Move_Cursor( hlcd, 0U, 2U );
 8002868:	68fb      	ldr	r3, [r7, #12]
 800286a:	2202      	movs	r2, #2
 800286c:	2100      	movs	r1, #0
 800286e:	0018      	movs	r0, r3
 8002870:	f7fe ff36 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "SINGLE TAP >", 12U );
 8002874:	491e      	ldr	r1, [pc, #120]	; (80028f0 <lcd_print_single_tap+0x98>)
 8002876:	68fb      	ldr	r3, [r7, #12]
 8002878:	220c      	movs	r2, #12
 800287a:	0018      	movs	r0, r3
 800287c:	f7fe ff78 	bl	8001770 <LCD_API_Print_String>
	
   /* Print single tap threshold value */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002880:	68fb      	ldr	r3, [r7, #12]
 8002882:	2204      	movs	r2, #4
 8002884:	2101      	movs	r1, #1
 8002886:	0018      	movs	r0, r3
 8002888:	f7fe ff2a 	bl	80016e0 <LCD_API_Move_Cursor>
   lcd_print_one_axis_info( hlcd, thresh_tap );
 800288c:	683a      	ldr	r2, [r7, #0]
 800288e:	68fb      	ldr	r3, [r7, #12]
 8002890:	1c11      	adds	r1, r2, #0
 8002892:	0018      	movs	r0, r3
 8002894:	f7ff fec6 	bl	8002624 <lcd_print_one_axis_info>
   
   /* Print 'X', 'Y' or 'Z' character depending on which axis generated the single tap */
   switch ( tap_source )
 8002898:	1dfb      	adds	r3, r7, #7
 800289a:	781b      	ldrb	r3, [r3, #0]
 800289c:	2b04      	cmp	r3, #4
 800289e:	d005      	beq.n	80028ac <lcd_print_single_tap+0x54>
 80028a0:	dc16      	bgt.n	80028d0 <lcd_print_single_tap+0x78>
 80028a2:	2b01      	cmp	r3, #1
 80028a4:	d00e      	beq.n	80028c4 <lcd_print_single_tap+0x6c>
 80028a6:	2b02      	cmp	r3, #2
 80028a8:	d006      	beq.n	80028b8 <lcd_print_single_tap+0x60>
         LCD_API_Print_Character( hlcd, 'Z' );
         break;

      default:
         /* Do nothing */
         break;
 80028aa:	e011      	b.n	80028d0 <lcd_print_single_tap+0x78>
         LCD_API_Print_Character( hlcd, 'X' );
 80028ac:	68fb      	ldr	r3, [r7, #12]
 80028ae:	2158      	movs	r1, #88	; 0x58
 80028b0:	0018      	movs	r0, r3
 80028b2:	f7fe ff43 	bl	800173c <LCD_API_Print_Character>
         break;
 80028b6:	e00c      	b.n	80028d2 <lcd_print_single_tap+0x7a>
         LCD_API_Print_Character( hlcd, 'Y' );
 80028b8:	68fb      	ldr	r3, [r7, #12]
 80028ba:	2159      	movs	r1, #89	; 0x59
 80028bc:	0018      	movs	r0, r3
 80028be:	f7fe ff3d 	bl	800173c <LCD_API_Print_Character>
         break;
 80028c2:	e006      	b.n	80028d2 <lcd_print_single_tap+0x7a>
         LCD_API_Print_Character( hlcd, 'Z' );
 80028c4:	68fb      	ldr	r3, [r7, #12]
 80028c6:	215a      	movs	r1, #90	; 0x5a
 80028c8:	0018      	movs	r0, r3
 80028ca:	f7fe ff37 	bl	800173c <LCD_API_Print_Character>
         break;
 80028ce:	e000      	b.n	80028d2 <lcd_print_single_tap+0x7a>
         break;
 80028d0:	46c0      	nop			; (mov r8, r8)
   }

   /* "Unprint" the +/- sign as single tap can be detected for both positive and negative magnitudes */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 80028d2:	68fb      	ldr	r3, [r7, #12]
 80028d4:	2204      	movs	r2, #4
 80028d6:	2101      	movs	r1, #1
 80028d8:	0018      	movs	r0, r3
 80028da:	f7fe ff01 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, ' ' );
 80028de:	68fb      	ldr	r3, [r7, #12]
 80028e0:	2120      	movs	r1, #32
 80028e2:	0018      	movs	r0, r3
 80028e4:	f7fe ff2a 	bl	800173c <LCD_API_Print_Character>
}
 80028e8:	46c0      	nop			; (mov r8, r8)
 80028ea:	46bd      	mov	sp, r7
 80028ec:	b004      	add	sp, #16
 80028ee:	bd80      	pop	{r7, pc}
 80028f0:	080037d4 	.word	0x080037d4

080028f4 <lcd_print_double_tap>:

void lcd_print_double_tap( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, uint8_t tap_source, float thresh_tap )
{
 80028f4:	b580      	push	{r7, lr}
 80028f6:	b084      	sub	sp, #16
 80028f8:	af00      	add	r7, sp, #0
 80028fa:	60f8      	str	r0, [r7, #12]
 80028fc:	60b9      	str	r1, [r7, #8]
 80028fe:	603b      	str	r3, [r7, #0]
 8002900:	1dfb      	adds	r3, r7, #7
 8002902:	701a      	strb	r2, [r3, #0]
   /* Move cursor and print "SINGLE TAP >" */
   LCD_API_Move_Cursor( hlcd, 0U, 2U );
 8002904:	68fb      	ldr	r3, [r7, #12]
 8002906:	2202      	movs	r2, #2
 8002908:	2100      	movs	r1, #0
 800290a:	0018      	movs	r0, r3
 800290c:	f7fe fee8 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "DOUBLE TAP >", 12U );
 8002910:	491e      	ldr	r1, [pc, #120]	; (800298c <lcd_print_double_tap+0x98>)
 8002912:	68fb      	ldr	r3, [r7, #12]
 8002914:	220c      	movs	r2, #12
 8002916:	0018      	movs	r0, r3
 8002918:	f7fe ff2a 	bl	8001770 <LCD_API_Print_String>
	
   /* Print double tap threshold value */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 800291c:	68fb      	ldr	r3, [r7, #12]
 800291e:	2204      	movs	r2, #4
 8002920:	2101      	movs	r1, #1
 8002922:	0018      	movs	r0, r3
 8002924:	f7fe fedc 	bl	80016e0 <LCD_API_Move_Cursor>
   lcd_print_one_axis_info( hlcd, thresh_tap );
 8002928:	683a      	ldr	r2, [r7, #0]
 800292a:	68fb      	ldr	r3, [r7, #12]
 800292c:	1c11      	adds	r1, r2, #0
 800292e:	0018      	movs	r0, r3
 8002930:	f7ff fe78 	bl	8002624 <lcd_print_one_axis_info>
   
   /* Print 'X', 'Y' or 'Z' character depending on which axis generated the single tap */
   switch ( tap_source )
 8002934:	1dfb      	adds	r3, r7, #7
 8002936:	781b      	ldrb	r3, [r3, #0]
 8002938:	2b04      	cmp	r3, #4
 800293a:	d005      	beq.n	8002948 <lcd_print_double_tap+0x54>
 800293c:	dc16      	bgt.n	800296c <lcd_print_double_tap+0x78>
 800293e:	2b01      	cmp	r3, #1
 8002940:	d00e      	beq.n	8002960 <lcd_print_double_tap+0x6c>
 8002942:	2b02      	cmp	r3, #2
 8002944:	d006      	beq.n	8002954 <lcd_print_double_tap+0x60>
         LCD_API_Print_Character( hlcd, 'Z' );
         break;

      default:
         /* do nothing */
         break;
 8002946:	e011      	b.n	800296c <lcd_print_double_tap+0x78>
         LCD_API_Print_Character( hlcd, 'X' );
 8002948:	68fb      	ldr	r3, [r7, #12]
 800294a:	2158      	movs	r1, #88	; 0x58
 800294c:	0018      	movs	r0, r3
 800294e:	f7fe fef5 	bl	800173c <LCD_API_Print_Character>
         break;
 8002952:	e00c      	b.n	800296e <lcd_print_double_tap+0x7a>
         LCD_API_Print_Character( hlcd, 'Y' );
 8002954:	68fb      	ldr	r3, [r7, #12]
 8002956:	2159      	movs	r1, #89	; 0x59
 8002958:	0018      	movs	r0, r3
 800295a:	f7fe feef 	bl	800173c <LCD_API_Print_Character>
         break;
 800295e:	e006      	b.n	800296e <lcd_print_double_tap+0x7a>
         LCD_API_Print_Character( hlcd, 'Z' );
 8002960:	68fb      	ldr	r3, [r7, #12]
 8002962:	215a      	movs	r1, #90	; 0x5a
 8002964:	0018      	movs	r0, r3
 8002966:	f7fe fee9 	bl	800173c <LCD_API_Print_Character>
         break;
 800296a:	e000      	b.n	800296e <lcd_print_double_tap+0x7a>
         break;
 800296c:	46c0      	nop			; (mov r8, r8)
   }

   /* "Unprint" the +/- sign as single tap can be detected for both positive and negative magnitudes */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 800296e:	68fb      	ldr	r3, [r7, #12]
 8002970:	2204      	movs	r2, #4
 8002972:	2101      	movs	r1, #1
 8002974:	0018      	movs	r0, r3
 8002976:	f7fe feb3 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, ' ' );
 800297a:	68fb      	ldr	r3, [r7, #12]
 800297c:	2120      	movs	r1, #32
 800297e:	0018      	movs	r0, r3
 8002980:	f7fe fedc 	bl	800173c <LCD_API_Print_Character>
}
 8002984:	46c0      	nop			; (mov r8, r8)
 8002986:	46bd      	mov	sp, r7
 8002988:	b004      	add	sp, #16
 800298a:	bd80      	pop	{r7, pc}
 800298c:	080037e4 	.word	0x080037e4

08002990 <lcd_print_activity>:

void lcd_print_activity( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, uint8_t act_source, float thresh_act )
{
 8002990:	b580      	push	{r7, lr}
 8002992:	b084      	sub	sp, #16
 8002994:	af00      	add	r7, sp, #0
 8002996:	60f8      	str	r0, [r7, #12]
 8002998:	60b9      	str	r1, [r7, #8]
 800299a:	603b      	str	r3, [r7, #0]
 800299c:	1dfb      	adds	r3, r7, #7
 800299e:	701a      	strb	r2, [r3, #0]
   /* Move cursor and print "ACTIVITY > " */
   LCD_API_Move_Cursor( hlcd, 0U, 3U );
 80029a0:	68fb      	ldr	r3, [r7, #12]
 80029a2:	2203      	movs	r2, #3
 80029a4:	2100      	movs	r1, #0
 80029a6:	0018      	movs	r0, r3
 80029a8:	f7fe fe9a 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "ACTIVITY >", 10U );
 80029ac:	491e      	ldr	r1, [pc, #120]	; (8002a28 <lcd_print_activity+0x98>)
 80029ae:	68fb      	ldr	r3, [r7, #12]
 80029b0:	220a      	movs	r2, #10
 80029b2:	0018      	movs	r0, r3
 80029b4:	f7fe fedc 	bl	8001770 <LCD_API_Print_String>

   /* Print activity threshold */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 80029b8:	68fb      	ldr	r3, [r7, #12]
 80029ba:	2204      	movs	r2, #4
 80029bc:	2101      	movs	r1, #1
 80029be:	0018      	movs	r0, r3
 80029c0:	f7fe fe8e 	bl	80016e0 <LCD_API_Move_Cursor>
   lcd_print_one_axis_info( hlcd, thresh_act );
 80029c4:	683a      	ldr	r2, [r7, #0]
 80029c6:	68fb      	ldr	r3, [r7, #12]
 80029c8:	1c11      	adds	r1, r2, #0
 80029ca:	0018      	movs	r0, r3
 80029cc:	f7ff fe2a 	bl	8002624 <lcd_print_one_axis_info>

   /* Print 'X', 'Y' or 'Z' character depending on the axis where activity was first detected */
   switch ( act_source )
 80029d0:	1dfb      	adds	r3, r7, #7
 80029d2:	781b      	ldrb	r3, [r3, #0]
 80029d4:	2b40      	cmp	r3, #64	; 0x40
 80029d6:	d005      	beq.n	80029e4 <lcd_print_activity+0x54>
 80029d8:	dc16      	bgt.n	8002a08 <lcd_print_activity+0x78>
 80029da:	2b10      	cmp	r3, #16
 80029dc:	d00e      	beq.n	80029fc <lcd_print_activity+0x6c>
 80029de:	2b20      	cmp	r3, #32
 80029e0:	d006      	beq.n	80029f0 <lcd_print_activity+0x60>
         LCD_API_Print_Character( hlcd, 'Z' );
         break;

      default:
         /* Do nothing */
         break;
 80029e2:	e011      	b.n	8002a08 <lcd_print_activity+0x78>
         LCD_API_Print_Character( hlcd, 'X' );
 80029e4:	68fb      	ldr	r3, [r7, #12]
 80029e6:	2158      	movs	r1, #88	; 0x58
 80029e8:	0018      	movs	r0, r3
 80029ea:	f7fe fea7 	bl	800173c <LCD_API_Print_Character>
         break;
 80029ee:	e00c      	b.n	8002a0a <lcd_print_activity+0x7a>
         LCD_API_Print_Character( hlcd, 'Y' );
 80029f0:	68fb      	ldr	r3, [r7, #12]
 80029f2:	2159      	movs	r1, #89	; 0x59
 80029f4:	0018      	movs	r0, r3
 80029f6:	f7fe fea1 	bl	800173c <LCD_API_Print_Character>
         break;
 80029fa:	e006      	b.n	8002a0a <lcd_print_activity+0x7a>
         LCD_API_Print_Character( hlcd, 'Z' );
 80029fc:	68fb      	ldr	r3, [r7, #12]
 80029fe:	215a      	movs	r1, #90	; 0x5a
 8002a00:	0018      	movs	r0, r3
 8002a02:	f7fe fe9b 	bl	800173c <LCD_API_Print_Character>
         break;
 8002a06:	e000      	b.n	8002a0a <lcd_print_activity+0x7a>
         break;
 8002a08:	46c0      	nop			; (mov r8, r8)
   }

   /* "Unprint" the +/- sign as activity is detected regardless if it is positive or negative */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002a0a:	68fb      	ldr	r3, [r7, #12]
 8002a0c:	2204      	movs	r2, #4
 8002a0e:	2101      	movs	r1, #1
 8002a10:	0018      	movs	r0, r3
 8002a12:	f7fe fe65 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, ' ' );
 8002a16:	68fb      	ldr	r3, [r7, #12]
 8002a18:	2120      	movs	r1, #32
 8002a1a:	0018      	movs	r0, r3
 8002a1c:	f7fe fe8e 	bl	800173c <LCD_API_Print_Character>
}
 8002a20:	46c0      	nop			; (mov r8, r8)
 8002a22:	46bd      	mov	sp, r7
 8002a24:	b004      	add	sp, #16
 8002a26:	bd80      	pop	{r7, pc}
 8002a28:	080037f4 	.word	0x080037f4

08002a2c <lcd_print_inactivity>:

void lcd_print_inactivity( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, uint8_t inact_axes, float thresh_inact )
{
 8002a2c:	b580      	push	{r7, lr}
 8002a2e:	b084      	sub	sp, #16
 8002a30:	af00      	add	r7, sp, #0
 8002a32:	60f8      	str	r0, [r7, #12]
 8002a34:	60b9      	str	r1, [r7, #8]
 8002a36:	603b      	str	r3, [r7, #0]
 8002a38:	1dfb      	adds	r3, r7, #7
 8002a3a:	701a      	strb	r2, [r3, #0]
   /* Move cursor and print "INACTIVITY <" */
   LCD_API_Move_Cursor( hlcd, 0U, 2U );
 8002a3c:	68fb      	ldr	r3, [r7, #12]
 8002a3e:	2202      	movs	r2, #2
 8002a40:	2100      	movs	r1, #0
 8002a42:	0018      	movs	r0, r3
 8002a44:	f7fe fe4c 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "INACTIVITY <", 12U );
 8002a48:	491e      	ldr	r1, [pc, #120]	; (8002ac4 <lcd_print_inactivity+0x98>)
 8002a4a:	68fb      	ldr	r3, [r7, #12]
 8002a4c:	220c      	movs	r2, #12
 8002a4e:	0018      	movs	r0, r3
 8002a50:	f7fe fe8e 	bl	8001770 <LCD_API_Print_String>

   /* Print inactivity threshold */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002a54:	68fb      	ldr	r3, [r7, #12]
 8002a56:	2204      	movs	r2, #4
 8002a58:	2101      	movs	r1, #1
 8002a5a:	0018      	movs	r0, r3
 8002a5c:	f7fe fe40 	bl	80016e0 <LCD_API_Move_Cursor>
   lcd_print_one_axis_info( hlcd, thresh_inact );
 8002a60:	683a      	ldr	r2, [r7, #0]
 8002a62:	68fb      	ldr	r3, [r7, #12]
 8002a64:	1c11      	adds	r1, r2, #0
 8002a66:	0018      	movs	r0, r3
 8002a68:	f7ff fddc 	bl	8002624 <lcd_print_one_axis_info>

   /* Print 'X', 'Y' or 'Z' character depending on the axis involved in the inactivity event */
   switch ( inact_axes )
 8002a6c:	1dfb      	adds	r3, r7, #7
 8002a6e:	781b      	ldrb	r3, [r3, #0]
 8002a70:	2b04      	cmp	r3, #4
 8002a72:	d005      	beq.n	8002a80 <lcd_print_inactivity+0x54>
 8002a74:	dc16      	bgt.n	8002aa4 <lcd_print_inactivity+0x78>
 8002a76:	2b01      	cmp	r3, #1
 8002a78:	d00e      	beq.n	8002a98 <lcd_print_inactivity+0x6c>
 8002a7a:	2b02      	cmp	r3, #2
 8002a7c:	d006      	beq.n	8002a8c <lcd_print_inactivity+0x60>
         LCD_API_Print_Character( hlcd, ( uint8_t ) 'Z' );
         break;

      default:
         /* Do nothing */
         break;
 8002a7e:	e011      	b.n	8002aa4 <lcd_print_inactivity+0x78>
         LCD_API_Print_Character( hlcd, ( uint8_t ) 'X' );
 8002a80:	68fb      	ldr	r3, [r7, #12]
 8002a82:	2158      	movs	r1, #88	; 0x58
 8002a84:	0018      	movs	r0, r3
 8002a86:	f7fe fe59 	bl	800173c <LCD_API_Print_Character>
         break;
 8002a8a:	e00c      	b.n	8002aa6 <lcd_print_inactivity+0x7a>
         LCD_API_Print_Character( hlcd, ( uint8_t ) 'Y' );
 8002a8c:	68fb      	ldr	r3, [r7, #12]
 8002a8e:	2159      	movs	r1, #89	; 0x59
 8002a90:	0018      	movs	r0, r3
 8002a92:	f7fe fe53 	bl	800173c <LCD_API_Print_Character>
         break;
 8002a96:	e006      	b.n	8002aa6 <lcd_print_inactivity+0x7a>
         LCD_API_Print_Character( hlcd, ( uint8_t ) 'Z' );
 8002a98:	68fb      	ldr	r3, [r7, #12]
 8002a9a:	215a      	movs	r1, #90	; 0x5a
 8002a9c:	0018      	movs	r0, r3
 8002a9e:	f7fe fe4d 	bl	800173c <LCD_API_Print_Character>
         break;
 8002aa2:	e000      	b.n	8002aa6 <lcd_print_inactivity+0x7a>
         break;
 8002aa4:	46c0      	nop			; (mov r8, r8)
   }

   /* "Unprint" the +/- sign as inactivity is detected regardless if it is positive or negative */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002aa6:	68fb      	ldr	r3, [r7, #12]
 8002aa8:	2204      	movs	r2, #4
 8002aaa:	2101      	movs	r1, #1
 8002aac:	0018      	movs	r0, r3
 8002aae:	f7fe fe17 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, ' ' );
 8002ab2:	68fb      	ldr	r3, [r7, #12]
 8002ab4:	2120      	movs	r1, #32
 8002ab6:	0018      	movs	r0, r3
 8002ab8:	f7fe fe40 	bl	800173c <LCD_API_Print_Character>
}
 8002abc:	46c0      	nop			; (mov r8, r8)
 8002abe:	46bd      	mov	sp, r7
 8002ac0:	b004      	add	sp, #16
 8002ac2:	bd80      	pop	{r7, pc}
 8002ac4:	08003800 	.word	0x08003800

08002ac8 <lcd_print_freefall>:

void lcd_print_freefall( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, float thresh_ff )
{
 8002ac8:	b580      	push	{r7, lr}
 8002aca:	b084      	sub	sp, #16
 8002acc:	af00      	add	r7, sp, #0
 8002ace:	60f8      	str	r0, [r7, #12]
 8002ad0:	60b9      	str	r1, [r7, #8]
 8002ad2:	607a      	str	r2, [r7, #4]
   /* Clear screen */
   LCD_Send_Instruction( hlcd, CLEAR_DISPLAY_REG );
 8002ad4:	68fb      	ldr	r3, [r7, #12]
 8002ad6:	2101      	movs	r1, #1
 8002ad8:	0018      	movs	r0, r3
 8002ada:	f7fe fce7 	bl	80014ac <LCD_Send_Instruction>

   /* Move cursor and print "FREE-FALL <" */
   LCD_API_Move_Cursor( hlcd, 0U, 2U );
 8002ade:	68fb      	ldr	r3, [r7, #12]
 8002ae0:	2202      	movs	r2, #2
 8002ae2:	2100      	movs	r1, #0
 8002ae4:	0018      	movs	r0, r3
 8002ae6:	f7fe fdfb 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "FREE-FALL <", 11U );
 8002aea:	4910      	ldr	r1, [pc, #64]	; (8002b2c <lcd_print_freefall+0x64>)
 8002aec:	68fb      	ldr	r3, [r7, #12]
 8002aee:	220b      	movs	r2, #11
 8002af0:	0018      	movs	r0, r3
 8002af2:	f7fe fe3d 	bl	8001770 <LCD_API_Print_String>

   /* Print free-fall threshold */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002af6:	68fb      	ldr	r3, [r7, #12]
 8002af8:	2204      	movs	r2, #4
 8002afa:	2101      	movs	r1, #1
 8002afc:	0018      	movs	r0, r3
 8002afe:	f7fe fdef 	bl	80016e0 <LCD_API_Move_Cursor>
   lcd_print_one_axis_info( hlcd, thresh_ff );
 8002b02:	687a      	ldr	r2, [r7, #4]
 8002b04:	68fb      	ldr	r3, [r7, #12]
 8002b06:	1c11      	adds	r1, r2, #0
 8002b08:	0018      	movs	r0, r3
 8002b0a:	f7ff fd8b 	bl	8002624 <lcd_print_one_axis_info>

   /* "Unprint" the +/- sign as free-fall is detected regardless if it is positive or negative */
   LCD_API_Move_Cursor( hlcd, 1U, 4U );
 8002b0e:	68fb      	ldr	r3, [r7, #12]
 8002b10:	2204      	movs	r2, #4
 8002b12:	2101      	movs	r1, #1
 8002b14:	0018      	movs	r0, r3
 8002b16:	f7fe fde3 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, ' ' );
 8002b1a:	68fb      	ldr	r3, [r7, #12]
 8002b1c:	2120      	movs	r1, #32
 8002b1e:	0018      	movs	r0, r3
 8002b20:	f7fe fe0c 	bl	800173c <LCD_API_Print_Character>
}
 8002b24:	46c0      	nop			; (mov r8, r8)
 8002b26:	46bd      	mov	sp, r7
 8002b28:	b004      	add	sp, #16
 8002b2a:	bd80      	pop	{r7, pc}
 8002b2c:	08003810 	.word	0x08003810

08002b30 <lcd_print_watermark>:

void lcd_print_watermark( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel, uint8_t watermark_samples, uint8_t fifo_entries )
{
 8002b30:	b580      	push	{r7, lr}
 8002b32:	b084      	sub	sp, #16
 8002b34:	af00      	add	r7, sp, #0
 8002b36:	60f8      	str	r0, [r7, #12]
 8002b38:	60b9      	str	r1, [r7, #8]
 8002b3a:	0019      	movs	r1, r3
 8002b3c:	1dfb      	adds	r3, r7, #7
 8002b3e:	701a      	strb	r2, [r3, #0]
 8002b40:	1dbb      	adds	r3, r7, #6
 8002b42:	1c0a      	adds	r2, r1, #0
 8002b44:	701a      	strb	r2, [r3, #0]
   /* Move cursor and print "WATERMARK >=" */
   LCD_API_Move_Cursor( hlcd, 0U, 1U );
 8002b46:	68fb      	ldr	r3, [r7, #12]
 8002b48:	2201      	movs	r2, #1
 8002b4a:	2100      	movs	r1, #0
 8002b4c:	0018      	movs	r0, r3
 8002b4e:	f7fe fdc7 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "WATERMARK >=", 12U );
 8002b52:	492e      	ldr	r1, [pc, #184]	; (8002c0c <lcd_print_watermark+0xdc>)
 8002b54:	68fb      	ldr	r3, [r7, #12]
 8002b56:	220c      	movs	r2, #12
 8002b58:	0018      	movs	r0, r3
 8002b5a:	f7fe fe09 	bl	8001770 <LCD_API_Print_String>

   /* Print number of samples for the watermark to be triggered */
   LCD_API_Print_Character( hlcd, ' ' );
 8002b5e:	68fb      	ldr	r3, [r7, #12]
 8002b60:	2120      	movs	r1, #32
 8002b62:	0018      	movs	r0, r3
 8002b64:	f7fe fdea 	bl	800173c <LCD_API_Print_Character>
   LCD_API_Print_Character( hlcd, ( watermark_samples / 10U ) + '0' ); /* 1st digit (tens)  of samples in FIFO_CTL */
 8002b68:	1dfb      	adds	r3, r7, #7
 8002b6a:	781b      	ldrb	r3, [r3, #0]
 8002b6c:	210a      	movs	r1, #10
 8002b6e:	0018      	movs	r0, r3
 8002b70:	f7fd faa6 	bl	80000c0 <__udivsi3>
 8002b74:	0003      	movs	r3, r0
 8002b76:	b2db      	uxtb	r3, r3
 8002b78:	3330      	adds	r3, #48	; 0x30
 8002b7a:	b2da      	uxtb	r2, r3
 8002b7c:	68fb      	ldr	r3, [r7, #12]
 8002b7e:	0011      	movs	r1, r2
 8002b80:	0018      	movs	r0, r3
 8002b82:	f7fe fddb 	bl	800173c <LCD_API_Print_Character>
   LCD_API_Print_Character( hlcd, ( watermark_samples % 10U ) + '0' ); /* 2nd digit (units) of samples in FIFO_CTL */
 8002b86:	1dfb      	adds	r3, r7, #7
 8002b88:	781b      	ldrb	r3, [r3, #0]
 8002b8a:	210a      	movs	r1, #10
 8002b8c:	0018      	movs	r0, r3
 8002b8e:	f7fd fb1d 	bl	80001cc <__aeabi_uidivmod>
 8002b92:	000b      	movs	r3, r1
 8002b94:	b2db      	uxtb	r3, r3
 8002b96:	3330      	adds	r3, #48	; 0x30
 8002b98:	b2da      	uxtb	r2, r3
 8002b9a:	68fb      	ldr	r3, [r7, #12]
 8002b9c:	0011      	movs	r1, r2
 8002b9e:	0018      	movs	r0, r3
 8002ba0:	f7fe fdcc 	bl	800173c <LCD_API_Print_Character>

   /* Print number of entries stored in FIFO */
   LCD_API_Move_Cursor( hlcd, 1U, 2U );
 8002ba4:	68fb      	ldr	r3, [r7, #12]
 8002ba6:	2202      	movs	r2, #2
 8002ba8:	2101      	movs	r1, #1
 8002baa:	0018      	movs	r0, r3
 8002bac:	f7fe fd98 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_Character( hlcd, '(' );
 8002bb0:	68fb      	ldr	r3, [r7, #12]
 8002bb2:	2128      	movs	r1, #40	; 0x28
 8002bb4:	0018      	movs	r0, r3
 8002bb6:	f7fe fdc1 	bl	800173c <LCD_API_Print_Character>
   LCD_API_Print_Character( hlcd, ( fifo_entries / 10U ) + '0' ); /* 1st digit (tens)  of entries */
 8002bba:	1dbb      	adds	r3, r7, #6
 8002bbc:	781b      	ldrb	r3, [r3, #0]
 8002bbe:	210a      	movs	r1, #10
 8002bc0:	0018      	movs	r0, r3
 8002bc2:	f7fd fa7d 	bl	80000c0 <__udivsi3>
 8002bc6:	0003      	movs	r3, r0
 8002bc8:	b2db      	uxtb	r3, r3
 8002bca:	3330      	adds	r3, #48	; 0x30
 8002bcc:	b2da      	uxtb	r2, r3
 8002bce:	68fb      	ldr	r3, [r7, #12]
 8002bd0:	0011      	movs	r1, r2
 8002bd2:	0018      	movs	r0, r3
 8002bd4:	f7fe fdb2 	bl	800173c <LCD_API_Print_Character>
   LCD_API_Print_Character( hlcd, ( fifo_entries % 10U ) + '0' ); /* 2nd digit (units) of entries */
 8002bd8:	1dbb      	adds	r3, r7, #6
 8002bda:	781b      	ldrb	r3, [r3, #0]
 8002bdc:	210a      	movs	r1, #10
 8002bde:	0018      	movs	r0, r3
 8002be0:	f7fd faf4 	bl	80001cc <__aeabi_uidivmod>
 8002be4:	000b      	movs	r3, r1
 8002be6:	b2db      	uxtb	r3, r3
 8002be8:	3330      	adds	r3, #48	; 0x30
 8002bea:	b2da      	uxtb	r2, r3
 8002bec:	68fb      	ldr	r3, [r7, #12]
 8002bee:	0011      	movs	r1, r2
 8002bf0:	0018      	movs	r0, r3
 8002bf2:	f7fe fda3 	bl	800173c <LCD_API_Print_Character>
   LCD_API_Print_String( hlcd, ( uint8_t* ) " samples)", 9U );
 8002bf6:	4906      	ldr	r1, [pc, #24]	; (8002c10 <lcd_print_watermark+0xe0>)
 8002bf8:	68fb      	ldr	r3, [r7, #12]
 8002bfa:	2209      	movs	r2, #9
 8002bfc:	0018      	movs	r0, r3
 8002bfe:	f7fe fdb7 	bl	8001770 <LCD_API_Print_String>
}
 8002c02:	46c0      	nop			; (mov r8, r8)
 8002c04:	46bd      	mov	sp, r7
 8002c06:	b004      	add	sp, #16
 8002c08:	bd80      	pop	{r7, pc}
 8002c0a:	46c0      	nop			; (mov r8, r8)
 8002c0c:	0800381c 	.word	0x0800381c
 8002c10:	0800382c 	.word	0x0800382c

08002c14 <lcd_print_overrun>:

void lcd_print_overrun( LCD_HandleTypeDef *hlcd, ACCEL_HandleTypeDef *haccel )
{  
 8002c14:	b580      	push	{r7, lr}
 8002c16:	b082      	sub	sp, #8
 8002c18:	af00      	add	r7, sp, #0
 8002c1a:	6078      	str	r0, [r7, #4]
 8002c1c:	6039      	str	r1, [r7, #0]
   /* Move cursor and print "OVERRUN," */
   LCD_API_Move_Cursor( hlcd, 0U, 4U );
 8002c1e:	687b      	ldr	r3, [r7, #4]
 8002c20:	2204      	movs	r2, #4
 8002c22:	2100      	movs	r1, #0
 8002c24:	0018      	movs	r0, r3
 8002c26:	f7fe fd5b 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "OVERRUN,", 7U );
 8002c2a:	490b      	ldr	r1, [pc, #44]	; (8002c58 <lcd_print_overrun+0x44>)
 8002c2c:	687b      	ldr	r3, [r7, #4]
 8002c2e:	2207      	movs	r2, #7
 8002c30:	0018      	movs	r0, r3
 8002c32:	f7fe fd9d 	bl	8001770 <LCD_API_Print_String>

   /* Move cursor and print "PRESS BUTTON" */
   LCD_API_Move_Cursor( hlcd, 1U, 2U );
 8002c36:	687b      	ldr	r3, [r7, #4]
 8002c38:	2202      	movs	r2, #2
 8002c3a:	2101      	movs	r1, #1
 8002c3c:	0018      	movs	r0, r3
 8002c3e:	f7fe fd4f 	bl	80016e0 <LCD_API_Move_Cursor>
   LCD_API_Print_String( hlcd, ( uint8_t* ) "PRESS BUTTON", 12U );
 8002c42:	4906      	ldr	r1, [pc, #24]	; (8002c5c <lcd_print_overrun+0x48>)
 8002c44:	687b      	ldr	r3, [r7, #4]
 8002c46:	220c      	movs	r2, #12
 8002c48:	0018      	movs	r0, r3
 8002c4a:	f7fe fd91 	bl	8001770 <LCD_API_Print_String>
}
 8002c4e:	46c0      	nop			; (mov r8, r8)
 8002c50:	46bd      	mov	sp, r7
 8002c52:	b002      	add	sp, #8
 8002c54:	bd80      	pop	{r7, pc}
 8002c56:	46c0      	nop			; (mov r8, r8)
 8002c58:	08003838 	.word	0x08003838
 8002c5c:	08003844 	.word	0x08003844

08002c60 <__aeabi_fadd>:
 8002c60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c62:	0243      	lsls	r3, r0, #9
 8002c64:	0045      	lsls	r5, r0, #1
 8002c66:	0fc4      	lsrs	r4, r0, #31
 8002c68:	0248      	lsls	r0, r1, #9
 8002c6a:	0a42      	lsrs	r2, r0, #9
 8002c6c:	4694      	mov	ip, r2
 8002c6e:	004a      	lsls	r2, r1, #1
 8002c70:	0a5f      	lsrs	r7, r3, #9
 8002c72:	0e2d      	lsrs	r5, r5, #24
 8002c74:	099b      	lsrs	r3, r3, #6
 8002c76:	0e12      	lsrs	r2, r2, #24
 8002c78:	0fc9      	lsrs	r1, r1, #31
 8002c7a:	0980      	lsrs	r0, r0, #6
 8002c7c:	428c      	cmp	r4, r1
 8002c7e:	d022      	beq.n	8002cc6 <__aeabi_fadd+0x66>
 8002c80:	1aae      	subs	r6, r5, r2
 8002c82:	2e00      	cmp	r6, #0
 8002c84:	dd0d      	ble.n	8002ca2 <__aeabi_fadd+0x42>
 8002c86:	2a00      	cmp	r2, #0
 8002c88:	d12d      	bne.n	8002ce6 <__aeabi_fadd+0x86>
 8002c8a:	2800      	cmp	r0, #0
 8002c8c:	d100      	bne.n	8002c90 <__aeabi_fadd+0x30>
 8002c8e:	e083      	b.n	8002d98 <__aeabi_fadd+0x138>
 8002c90:	1e72      	subs	r2, r6, #1
 8002c92:	2e01      	cmp	r6, #1
 8002c94:	d100      	bne.n	8002c98 <__aeabi_fadd+0x38>
 8002c96:	e11b      	b.n	8002ed0 <__aeabi_fadd+0x270>
 8002c98:	2eff      	cmp	r6, #255	; 0xff
 8002c9a:	d100      	bne.n	8002c9e <__aeabi_fadd+0x3e>
 8002c9c:	e0a2      	b.n	8002de4 <__aeabi_fadd+0x184>
 8002c9e:	0016      	movs	r6, r2
 8002ca0:	e027      	b.n	8002cf2 <__aeabi_fadd+0x92>
 8002ca2:	2e00      	cmp	r6, #0
 8002ca4:	d048      	beq.n	8002d38 <__aeabi_fadd+0xd8>
 8002ca6:	1b56      	subs	r6, r2, r5
 8002ca8:	2d00      	cmp	r5, #0
 8002caa:	d000      	beq.n	8002cae <__aeabi_fadd+0x4e>
 8002cac:	e0c1      	b.n	8002e32 <__aeabi_fadd+0x1d2>
 8002cae:	2b00      	cmp	r3, #0
 8002cb0:	d100      	bne.n	8002cb4 <__aeabi_fadd+0x54>
 8002cb2:	e0f7      	b.n	8002ea4 <__aeabi_fadd+0x244>
 8002cb4:	1e74      	subs	r4, r6, #1
 8002cb6:	2e01      	cmp	r6, #1
 8002cb8:	d100      	bne.n	8002cbc <__aeabi_fadd+0x5c>
 8002cba:	e12d      	b.n	8002f18 <__aeabi_fadd+0x2b8>
 8002cbc:	2eff      	cmp	r6, #255	; 0xff
 8002cbe:	d100      	bne.n	8002cc2 <__aeabi_fadd+0x62>
 8002cc0:	e08e      	b.n	8002de0 <__aeabi_fadd+0x180>
 8002cc2:	0026      	movs	r6, r4
 8002cc4:	e0ba      	b.n	8002e3c <__aeabi_fadd+0x1dc>
 8002cc6:	1aa9      	subs	r1, r5, r2
 8002cc8:	2900      	cmp	r1, #0
 8002cca:	dc00      	bgt.n	8002cce <__aeabi_fadd+0x6e>
 8002ccc:	e08c      	b.n	8002de8 <__aeabi_fadd+0x188>
 8002cce:	2a00      	cmp	r2, #0
 8002cd0:	d046      	beq.n	8002d60 <__aeabi_fadd+0x100>
 8002cd2:	2dff      	cmp	r5, #255	; 0xff
 8002cd4:	d100      	bne.n	8002cd8 <__aeabi_fadd+0x78>
 8002cd6:	e085      	b.n	8002de4 <__aeabi_fadd+0x184>
 8002cd8:	2280      	movs	r2, #128	; 0x80
 8002cda:	04d2      	lsls	r2, r2, #19
 8002cdc:	4310      	orrs	r0, r2
 8002cde:	291b      	cmp	r1, #27
 8002ce0:	dd49      	ble.n	8002d76 <__aeabi_fadd+0x116>
 8002ce2:	3301      	adds	r3, #1
 8002ce4:	e016      	b.n	8002d14 <__aeabi_fadd+0xb4>
 8002ce6:	2dff      	cmp	r5, #255	; 0xff
 8002ce8:	d100      	bne.n	8002cec <__aeabi_fadd+0x8c>
 8002cea:	e07b      	b.n	8002de4 <__aeabi_fadd+0x184>
 8002cec:	2280      	movs	r2, #128	; 0x80
 8002cee:	04d2      	lsls	r2, r2, #19
 8002cf0:	4310      	orrs	r0, r2
 8002cf2:	2201      	movs	r2, #1
 8002cf4:	2e1b      	cmp	r6, #27
 8002cf6:	dc07      	bgt.n	8002d08 <__aeabi_fadd+0xa8>
 8002cf8:	2120      	movs	r1, #32
 8002cfa:	1b89      	subs	r1, r1, r6
 8002cfc:	0002      	movs	r2, r0
 8002cfe:	4088      	lsls	r0, r1
 8002d00:	40f2      	lsrs	r2, r6
 8002d02:	1e41      	subs	r1, r0, #1
 8002d04:	4188      	sbcs	r0, r1
 8002d06:	4302      	orrs	r2, r0
 8002d08:	1a9b      	subs	r3, r3, r2
 8002d0a:	015a      	lsls	r2, r3, #5
 8002d0c:	d451      	bmi.n	8002db2 <__aeabi_fadd+0x152>
 8002d0e:	2207      	movs	r2, #7
 8002d10:	401a      	ands	r2, r3
 8002d12:	d042      	beq.n	8002d9a <__aeabi_fadd+0x13a>
 8002d14:	220f      	movs	r2, #15
 8002d16:	401a      	ands	r2, r3
 8002d18:	2a04      	cmp	r2, #4
 8002d1a:	d000      	beq.n	8002d1e <__aeabi_fadd+0xbe>
 8002d1c:	3304      	adds	r3, #4
 8002d1e:	015a      	lsls	r2, r3, #5
 8002d20:	d53b      	bpl.n	8002d9a <__aeabi_fadd+0x13a>
 8002d22:	1c68      	adds	r0, r5, #1
 8002d24:	2dfe      	cmp	r5, #254	; 0xfe
 8002d26:	d034      	beq.n	8002d92 <__aeabi_fadd+0x132>
 8002d28:	019b      	lsls	r3, r3, #6
 8002d2a:	0a5b      	lsrs	r3, r3, #9
 8002d2c:	b2c0      	uxtb	r0, r0
 8002d2e:	05c0      	lsls	r0, r0, #23
 8002d30:	4318      	orrs	r0, r3
 8002d32:	07e4      	lsls	r4, r4, #31
 8002d34:	4320      	orrs	r0, r4
 8002d36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002d38:	26fe      	movs	r6, #254	; 0xfe
 8002d3a:	1c6a      	adds	r2, r5, #1
 8002d3c:	4216      	tst	r6, r2
 8002d3e:	d000      	beq.n	8002d42 <__aeabi_fadd+0xe2>
 8002d40:	e08b      	b.n	8002e5a <__aeabi_fadd+0x1fa>
 8002d42:	2d00      	cmp	r5, #0
 8002d44:	d000      	beq.n	8002d48 <__aeabi_fadd+0xe8>
 8002d46:	e0b1      	b.n	8002eac <__aeabi_fadd+0x24c>
 8002d48:	2b00      	cmp	r3, #0
 8002d4a:	d100      	bne.n	8002d4e <__aeabi_fadd+0xee>
 8002d4c:	e0df      	b.n	8002f0e <__aeabi_fadd+0x2ae>
 8002d4e:	2800      	cmp	r0, #0
 8002d50:	d069      	beq.n	8002e26 <__aeabi_fadd+0x1c6>
 8002d52:	1a1a      	subs	r2, r3, r0
 8002d54:	0156      	lsls	r6, r2, #5
 8002d56:	d400      	bmi.n	8002d5a <__aeabi_fadd+0xfa>
 8002d58:	e0fb      	b.n	8002f52 <__aeabi_fadd+0x2f2>
 8002d5a:	000c      	movs	r4, r1
 8002d5c:	1ac3      	subs	r3, r0, r3
 8002d5e:	e03c      	b.n	8002dda <__aeabi_fadd+0x17a>
 8002d60:	2800      	cmp	r0, #0
 8002d62:	d100      	bne.n	8002d66 <__aeabi_fadd+0x106>
 8002d64:	e0b7      	b.n	8002ed6 <__aeabi_fadd+0x276>
 8002d66:	1e4a      	subs	r2, r1, #1
 8002d68:	2901      	cmp	r1, #1
 8002d6a:	d100      	bne.n	8002d6e <__aeabi_fadd+0x10e>
 8002d6c:	e0aa      	b.n	8002ec4 <__aeabi_fadd+0x264>
 8002d6e:	29ff      	cmp	r1, #255	; 0xff
 8002d70:	d038      	beq.n	8002de4 <__aeabi_fadd+0x184>
 8002d72:	0011      	movs	r1, r2
 8002d74:	e7b3      	b.n	8002cde <__aeabi_fadd+0x7e>
 8002d76:	0002      	movs	r2, r0
 8002d78:	2620      	movs	r6, #32
 8002d7a:	40ca      	lsrs	r2, r1
 8002d7c:	1a71      	subs	r1, r6, r1
 8002d7e:	4088      	lsls	r0, r1
 8002d80:	1e41      	subs	r1, r0, #1
 8002d82:	4188      	sbcs	r0, r1
 8002d84:	4310      	orrs	r0, r2
 8002d86:	181b      	adds	r3, r3, r0
 8002d88:	015a      	lsls	r2, r3, #5
 8002d8a:	d5c0      	bpl.n	8002d0e <__aeabi_fadd+0xae>
 8002d8c:	3501      	adds	r5, #1
 8002d8e:	2dff      	cmp	r5, #255	; 0xff
 8002d90:	d16c      	bne.n	8002e6c <__aeabi_fadd+0x20c>
 8002d92:	20ff      	movs	r0, #255	; 0xff
 8002d94:	2300      	movs	r3, #0
 8002d96:	e7ca      	b.n	8002d2e <__aeabi_fadd+0xce>
 8002d98:	0035      	movs	r5, r6
 8002d9a:	08db      	lsrs	r3, r3, #3
 8002d9c:	2dff      	cmp	r5, #255	; 0xff
 8002d9e:	d144      	bne.n	8002e2a <__aeabi_fadd+0x1ca>
 8002da0:	2b00      	cmp	r3, #0
 8002da2:	d0f6      	beq.n	8002d92 <__aeabi_fadd+0x132>
 8002da4:	2280      	movs	r2, #128	; 0x80
 8002da6:	03d2      	lsls	r2, r2, #15
 8002da8:	4313      	orrs	r3, r2
 8002daa:	025b      	lsls	r3, r3, #9
 8002dac:	20ff      	movs	r0, #255	; 0xff
 8002dae:	0a5b      	lsrs	r3, r3, #9
 8002db0:	e7bd      	b.n	8002d2e <__aeabi_fadd+0xce>
 8002db2:	019e      	lsls	r6, r3, #6
 8002db4:	09b6      	lsrs	r6, r6, #6
 8002db6:	0030      	movs	r0, r6
 8002db8:	f7fd fa48 	bl	800024c <__clzsi2>
 8002dbc:	3805      	subs	r0, #5
 8002dbe:	4086      	lsls	r6, r0
 8002dc0:	4285      	cmp	r5, r0
 8002dc2:	dc20      	bgt.n	8002e06 <__aeabi_fadd+0x1a6>
 8002dc4:	2220      	movs	r2, #32
 8002dc6:	1b40      	subs	r0, r0, r5
 8002dc8:	3001      	adds	r0, #1
 8002dca:	1a12      	subs	r2, r2, r0
 8002dcc:	0033      	movs	r3, r6
 8002dce:	4096      	lsls	r6, r2
 8002dd0:	40c3      	lsrs	r3, r0
 8002dd2:	1e72      	subs	r2, r6, #1
 8002dd4:	4196      	sbcs	r6, r2
 8002dd6:	2500      	movs	r5, #0
 8002dd8:	4333      	orrs	r3, r6
 8002dda:	075a      	lsls	r2, r3, #29
 8002ddc:	d19a      	bne.n	8002d14 <__aeabi_fadd+0xb4>
 8002dde:	e79e      	b.n	8002d1e <__aeabi_fadd+0xbe>
 8002de0:	000c      	movs	r4, r1
 8002de2:	0003      	movs	r3, r0
 8002de4:	08db      	lsrs	r3, r3, #3
 8002de6:	e7db      	b.n	8002da0 <__aeabi_fadd+0x140>
 8002de8:	2900      	cmp	r1, #0
 8002dea:	d010      	beq.n	8002e0e <__aeabi_fadd+0x1ae>
 8002dec:	1b51      	subs	r1, r2, r5
 8002dee:	2d00      	cmp	r5, #0
 8002df0:	d143      	bne.n	8002e7a <__aeabi_fadd+0x21a>
 8002df2:	2b00      	cmp	r3, #0
 8002df4:	d100      	bne.n	8002df8 <__aeabi_fadd+0x198>
 8002df6:	e093      	b.n	8002f20 <__aeabi_fadd+0x2c0>
 8002df8:	1e4d      	subs	r5, r1, #1
 8002dfa:	2901      	cmp	r1, #1
 8002dfc:	d062      	beq.n	8002ec4 <__aeabi_fadd+0x264>
 8002dfe:	29ff      	cmp	r1, #255	; 0xff
 8002e00:	d0ef      	beq.n	8002de2 <__aeabi_fadd+0x182>
 8002e02:	0029      	movs	r1, r5
 8002e04:	e03e      	b.n	8002e84 <__aeabi_fadd+0x224>
 8002e06:	4b55      	ldr	r3, [pc, #340]	; (8002f5c <__aeabi_fadd+0x2fc>)
 8002e08:	1a2d      	subs	r5, r5, r0
 8002e0a:	4033      	ands	r3, r6
 8002e0c:	e7e5      	b.n	8002dda <__aeabi_fadd+0x17a>
 8002e0e:	21fe      	movs	r1, #254	; 0xfe
 8002e10:	1c6a      	adds	r2, r5, #1
 8002e12:	4211      	tst	r1, r2
 8002e14:	d13b      	bne.n	8002e8e <__aeabi_fadd+0x22e>
 8002e16:	2d00      	cmp	r5, #0
 8002e18:	d16a      	bne.n	8002ef0 <__aeabi_fadd+0x290>
 8002e1a:	2b00      	cmp	r3, #0
 8002e1c:	d100      	bne.n	8002e20 <__aeabi_fadd+0x1c0>
 8002e1e:	e08e      	b.n	8002f3e <__aeabi_fadd+0x2de>
 8002e20:	2800      	cmp	r0, #0
 8002e22:	d000      	beq.n	8002e26 <__aeabi_fadd+0x1c6>
 8002e24:	e08d      	b.n	8002f42 <__aeabi_fadd+0x2e2>
 8002e26:	2500      	movs	r5, #0
 8002e28:	08db      	lsrs	r3, r3, #3
 8002e2a:	025b      	lsls	r3, r3, #9
 8002e2c:	0a5b      	lsrs	r3, r3, #9
 8002e2e:	b2e8      	uxtb	r0, r5
 8002e30:	e77d      	b.n	8002d2e <__aeabi_fadd+0xce>
 8002e32:	2aff      	cmp	r2, #255	; 0xff
 8002e34:	d0d4      	beq.n	8002de0 <__aeabi_fadd+0x180>
 8002e36:	2480      	movs	r4, #128	; 0x80
 8002e38:	04e4      	lsls	r4, r4, #19
 8002e3a:	4323      	orrs	r3, r4
 8002e3c:	2401      	movs	r4, #1
 8002e3e:	2e1b      	cmp	r6, #27
 8002e40:	dc07      	bgt.n	8002e52 <__aeabi_fadd+0x1f2>
 8002e42:	2520      	movs	r5, #32
 8002e44:	1bad      	subs	r5, r5, r6
 8002e46:	001c      	movs	r4, r3
 8002e48:	40ab      	lsls	r3, r5
 8002e4a:	40f4      	lsrs	r4, r6
 8002e4c:	1e5d      	subs	r5, r3, #1
 8002e4e:	41ab      	sbcs	r3, r5
 8002e50:	431c      	orrs	r4, r3
 8002e52:	1b03      	subs	r3, r0, r4
 8002e54:	0015      	movs	r5, r2
 8002e56:	000c      	movs	r4, r1
 8002e58:	e757      	b.n	8002d0a <__aeabi_fadd+0xaa>
 8002e5a:	1a1e      	subs	r6, r3, r0
 8002e5c:	0172      	lsls	r2, r6, #5
 8002e5e:	d42e      	bmi.n	8002ebe <__aeabi_fadd+0x25e>
 8002e60:	2e00      	cmp	r6, #0
 8002e62:	d1a8      	bne.n	8002db6 <__aeabi_fadd+0x156>
 8002e64:	2400      	movs	r4, #0
 8002e66:	2000      	movs	r0, #0
 8002e68:	2300      	movs	r3, #0
 8002e6a:	e760      	b.n	8002d2e <__aeabi_fadd+0xce>
 8002e6c:	2201      	movs	r2, #1
 8002e6e:	493c      	ldr	r1, [pc, #240]	; (8002f60 <__aeabi_fadd+0x300>)
 8002e70:	401a      	ands	r2, r3
 8002e72:	085b      	lsrs	r3, r3, #1
 8002e74:	400b      	ands	r3, r1
 8002e76:	4313      	orrs	r3, r2
 8002e78:	e7af      	b.n	8002dda <__aeabi_fadd+0x17a>
 8002e7a:	2aff      	cmp	r2, #255	; 0xff
 8002e7c:	d0b1      	beq.n	8002de2 <__aeabi_fadd+0x182>
 8002e7e:	2580      	movs	r5, #128	; 0x80
 8002e80:	04ed      	lsls	r5, r5, #19
 8002e82:	432b      	orrs	r3, r5
 8002e84:	291b      	cmp	r1, #27
 8002e86:	dd28      	ble.n	8002eda <__aeabi_fadd+0x27a>
 8002e88:	0015      	movs	r5, r2
 8002e8a:	1c43      	adds	r3, r0, #1
 8002e8c:	e742      	b.n	8002d14 <__aeabi_fadd+0xb4>
 8002e8e:	2aff      	cmp	r2, #255	; 0xff
 8002e90:	d100      	bne.n	8002e94 <__aeabi_fadd+0x234>
 8002e92:	e77e      	b.n	8002d92 <__aeabi_fadd+0x132>
 8002e94:	181b      	adds	r3, r3, r0
 8002e96:	085b      	lsrs	r3, r3, #1
 8002e98:	0015      	movs	r5, r2
 8002e9a:	075a      	lsls	r2, r3, #29
 8002e9c:	d000      	beq.n	8002ea0 <__aeabi_fadd+0x240>
 8002e9e:	e739      	b.n	8002d14 <__aeabi_fadd+0xb4>
 8002ea0:	08db      	lsrs	r3, r3, #3
 8002ea2:	e7c2      	b.n	8002e2a <__aeabi_fadd+0x1ca>
 8002ea4:	000c      	movs	r4, r1
 8002ea6:	0035      	movs	r5, r6
 8002ea8:	0003      	movs	r3, r0
 8002eaa:	e776      	b.n	8002d9a <__aeabi_fadd+0x13a>
 8002eac:	2b00      	cmp	r3, #0
 8002eae:	d13a      	bne.n	8002f26 <__aeabi_fadd+0x2c6>
 8002eb0:	2800      	cmp	r0, #0
 8002eb2:	d195      	bne.n	8002de0 <__aeabi_fadd+0x180>
 8002eb4:	2380      	movs	r3, #128	; 0x80
 8002eb6:	2400      	movs	r4, #0
 8002eb8:	20ff      	movs	r0, #255	; 0xff
 8002eba:	03db      	lsls	r3, r3, #15
 8002ebc:	e737      	b.n	8002d2e <__aeabi_fadd+0xce>
 8002ebe:	000c      	movs	r4, r1
 8002ec0:	1ac6      	subs	r6, r0, r3
 8002ec2:	e778      	b.n	8002db6 <__aeabi_fadd+0x156>
 8002ec4:	181b      	adds	r3, r3, r0
 8002ec6:	2502      	movs	r5, #2
 8002ec8:	015a      	lsls	r2, r3, #5
 8002eca:	d4cf      	bmi.n	8002e6c <__aeabi_fadd+0x20c>
 8002ecc:	3d01      	subs	r5, #1
 8002ece:	e71e      	b.n	8002d0e <__aeabi_fadd+0xae>
 8002ed0:	2501      	movs	r5, #1
 8002ed2:	1a1b      	subs	r3, r3, r0
 8002ed4:	e719      	b.n	8002d0a <__aeabi_fadd+0xaa>
 8002ed6:	000d      	movs	r5, r1
 8002ed8:	e75f      	b.n	8002d9a <__aeabi_fadd+0x13a>
 8002eda:	001d      	movs	r5, r3
 8002edc:	2620      	movs	r6, #32
 8002ede:	40cd      	lsrs	r5, r1
 8002ee0:	1a71      	subs	r1, r6, r1
 8002ee2:	408b      	lsls	r3, r1
 8002ee4:	1e59      	subs	r1, r3, #1
 8002ee6:	418b      	sbcs	r3, r1
 8002ee8:	432b      	orrs	r3, r5
 8002eea:	181b      	adds	r3, r3, r0
 8002eec:	0015      	movs	r5, r2
 8002eee:	e74b      	b.n	8002d88 <__aeabi_fadd+0x128>
 8002ef0:	2b00      	cmp	r3, #0
 8002ef2:	d100      	bne.n	8002ef6 <__aeabi_fadd+0x296>
 8002ef4:	e775      	b.n	8002de2 <__aeabi_fadd+0x182>
 8002ef6:	2800      	cmp	r0, #0
 8002ef8:	d100      	bne.n	8002efc <__aeabi_fadd+0x29c>
 8002efa:	e773      	b.n	8002de4 <__aeabi_fadd+0x184>
 8002efc:	2280      	movs	r2, #128	; 0x80
 8002efe:	03d2      	lsls	r2, r2, #15
 8002f00:	4297      	cmp	r7, r2
 8002f02:	d302      	bcc.n	8002f0a <__aeabi_fadd+0x2aa>
 8002f04:	4594      	cmp	ip, r2
 8002f06:	d200      	bcs.n	8002f0a <__aeabi_fadd+0x2aa>
 8002f08:	0003      	movs	r3, r0
 8002f0a:	08db      	lsrs	r3, r3, #3
 8002f0c:	e74a      	b.n	8002da4 <__aeabi_fadd+0x144>
 8002f0e:	2800      	cmp	r0, #0
 8002f10:	d0a8      	beq.n	8002e64 <__aeabi_fadd+0x204>
 8002f12:	000c      	movs	r4, r1
 8002f14:	0003      	movs	r3, r0
 8002f16:	e786      	b.n	8002e26 <__aeabi_fadd+0x1c6>
 8002f18:	000c      	movs	r4, r1
 8002f1a:	1ac3      	subs	r3, r0, r3
 8002f1c:	3501      	adds	r5, #1
 8002f1e:	e6f4      	b.n	8002d0a <__aeabi_fadd+0xaa>
 8002f20:	000d      	movs	r5, r1
 8002f22:	0003      	movs	r3, r0
 8002f24:	e739      	b.n	8002d9a <__aeabi_fadd+0x13a>
 8002f26:	2800      	cmp	r0, #0
 8002f28:	d100      	bne.n	8002f2c <__aeabi_fadd+0x2cc>
 8002f2a:	e75b      	b.n	8002de4 <__aeabi_fadd+0x184>
 8002f2c:	2280      	movs	r2, #128	; 0x80
 8002f2e:	03d2      	lsls	r2, r2, #15
 8002f30:	4297      	cmp	r7, r2
 8002f32:	d3ea      	bcc.n	8002f0a <__aeabi_fadd+0x2aa>
 8002f34:	4594      	cmp	ip, r2
 8002f36:	d2e8      	bcs.n	8002f0a <__aeabi_fadd+0x2aa>
 8002f38:	000c      	movs	r4, r1
 8002f3a:	0003      	movs	r3, r0
 8002f3c:	e7e5      	b.n	8002f0a <__aeabi_fadd+0x2aa>
 8002f3e:	0003      	movs	r3, r0
 8002f40:	e771      	b.n	8002e26 <__aeabi_fadd+0x1c6>
 8002f42:	181b      	adds	r3, r3, r0
 8002f44:	015a      	lsls	r2, r3, #5
 8002f46:	d5ab      	bpl.n	8002ea0 <__aeabi_fadd+0x240>
 8002f48:	4a04      	ldr	r2, [pc, #16]	; (8002f5c <__aeabi_fadd+0x2fc>)
 8002f4a:	3501      	adds	r5, #1
 8002f4c:	4013      	ands	r3, r2
 8002f4e:	08db      	lsrs	r3, r3, #3
 8002f50:	e76b      	b.n	8002e2a <__aeabi_fadd+0x1ca>
 8002f52:	1e13      	subs	r3, r2, #0
 8002f54:	d086      	beq.n	8002e64 <__aeabi_fadd+0x204>
 8002f56:	08db      	lsrs	r3, r3, #3
 8002f58:	e767      	b.n	8002e2a <__aeabi_fadd+0x1ca>
 8002f5a:	46c0      	nop			; (mov r8, r8)
 8002f5c:	fbffffff 	.word	0xfbffffff
 8002f60:	7dffffff 	.word	0x7dffffff

08002f64 <__eqsf2>:
 8002f64:	b570      	push	{r4, r5, r6, lr}
 8002f66:	0042      	lsls	r2, r0, #1
 8002f68:	024e      	lsls	r6, r1, #9
 8002f6a:	004c      	lsls	r4, r1, #1
 8002f6c:	0245      	lsls	r5, r0, #9
 8002f6e:	0a6d      	lsrs	r5, r5, #9
 8002f70:	0e12      	lsrs	r2, r2, #24
 8002f72:	0fc3      	lsrs	r3, r0, #31
 8002f74:	0a76      	lsrs	r6, r6, #9
 8002f76:	0e24      	lsrs	r4, r4, #24
 8002f78:	0fc9      	lsrs	r1, r1, #31
 8002f7a:	2aff      	cmp	r2, #255	; 0xff
 8002f7c:	d010      	beq.n	8002fa0 <__eqsf2+0x3c>
 8002f7e:	2cff      	cmp	r4, #255	; 0xff
 8002f80:	d00c      	beq.n	8002f9c <__eqsf2+0x38>
 8002f82:	2001      	movs	r0, #1
 8002f84:	42a2      	cmp	r2, r4
 8002f86:	d10a      	bne.n	8002f9e <__eqsf2+0x3a>
 8002f88:	42b5      	cmp	r5, r6
 8002f8a:	d108      	bne.n	8002f9e <__eqsf2+0x3a>
 8002f8c:	428b      	cmp	r3, r1
 8002f8e:	d00f      	beq.n	8002fb0 <__eqsf2+0x4c>
 8002f90:	2a00      	cmp	r2, #0
 8002f92:	d104      	bne.n	8002f9e <__eqsf2+0x3a>
 8002f94:	0028      	movs	r0, r5
 8002f96:	1e43      	subs	r3, r0, #1
 8002f98:	4198      	sbcs	r0, r3
 8002f9a:	e000      	b.n	8002f9e <__eqsf2+0x3a>
 8002f9c:	2001      	movs	r0, #1
 8002f9e:	bd70      	pop	{r4, r5, r6, pc}
 8002fa0:	2001      	movs	r0, #1
 8002fa2:	2cff      	cmp	r4, #255	; 0xff
 8002fa4:	d1fb      	bne.n	8002f9e <__eqsf2+0x3a>
 8002fa6:	4335      	orrs	r5, r6
 8002fa8:	d1f9      	bne.n	8002f9e <__eqsf2+0x3a>
 8002faa:	404b      	eors	r3, r1
 8002fac:	0018      	movs	r0, r3
 8002fae:	e7f6      	b.n	8002f9e <__eqsf2+0x3a>
 8002fb0:	2000      	movs	r0, #0
 8002fb2:	e7f4      	b.n	8002f9e <__eqsf2+0x3a>

08002fb4 <__gesf2>:
 8002fb4:	b530      	push	{r4, r5, lr}
 8002fb6:	0042      	lsls	r2, r0, #1
 8002fb8:	0244      	lsls	r4, r0, #9
 8002fba:	024d      	lsls	r5, r1, #9
 8002fbc:	0fc3      	lsrs	r3, r0, #31
 8002fbe:	0048      	lsls	r0, r1, #1
 8002fc0:	0a64      	lsrs	r4, r4, #9
 8002fc2:	0e12      	lsrs	r2, r2, #24
 8002fc4:	0a6d      	lsrs	r5, r5, #9
 8002fc6:	0e00      	lsrs	r0, r0, #24
 8002fc8:	0fc9      	lsrs	r1, r1, #31
 8002fca:	2aff      	cmp	r2, #255	; 0xff
 8002fcc:	d019      	beq.n	8003002 <__gesf2+0x4e>
 8002fce:	28ff      	cmp	r0, #255	; 0xff
 8002fd0:	d00b      	beq.n	8002fea <__gesf2+0x36>
 8002fd2:	2a00      	cmp	r2, #0
 8002fd4:	d11e      	bne.n	8003014 <__gesf2+0x60>
 8002fd6:	2800      	cmp	r0, #0
 8002fd8:	d10b      	bne.n	8002ff2 <__gesf2+0x3e>
 8002fda:	2d00      	cmp	r5, #0
 8002fdc:	d027      	beq.n	800302e <__gesf2+0x7a>
 8002fde:	2c00      	cmp	r4, #0
 8002fe0:	d134      	bne.n	800304c <__gesf2+0x98>
 8002fe2:	2900      	cmp	r1, #0
 8002fe4:	d02f      	beq.n	8003046 <__gesf2+0x92>
 8002fe6:	0008      	movs	r0, r1
 8002fe8:	bd30      	pop	{r4, r5, pc}
 8002fea:	2d00      	cmp	r5, #0
 8002fec:	d128      	bne.n	8003040 <__gesf2+0x8c>
 8002fee:	2a00      	cmp	r2, #0
 8002ff0:	d101      	bne.n	8002ff6 <__gesf2+0x42>
 8002ff2:	2c00      	cmp	r4, #0
 8002ff4:	d0f5      	beq.n	8002fe2 <__gesf2+0x2e>
 8002ff6:	428b      	cmp	r3, r1
 8002ff8:	d107      	bne.n	800300a <__gesf2+0x56>
 8002ffa:	2b00      	cmp	r3, #0
 8002ffc:	d023      	beq.n	8003046 <__gesf2+0x92>
 8002ffe:	0018      	movs	r0, r3
 8003000:	e7f2      	b.n	8002fe8 <__gesf2+0x34>
 8003002:	2c00      	cmp	r4, #0
 8003004:	d11c      	bne.n	8003040 <__gesf2+0x8c>
 8003006:	28ff      	cmp	r0, #255	; 0xff
 8003008:	d014      	beq.n	8003034 <__gesf2+0x80>
 800300a:	1e58      	subs	r0, r3, #1
 800300c:	2302      	movs	r3, #2
 800300e:	4018      	ands	r0, r3
 8003010:	3801      	subs	r0, #1
 8003012:	e7e9      	b.n	8002fe8 <__gesf2+0x34>
 8003014:	2800      	cmp	r0, #0
 8003016:	d0f8      	beq.n	800300a <__gesf2+0x56>
 8003018:	428b      	cmp	r3, r1
 800301a:	d1f6      	bne.n	800300a <__gesf2+0x56>
 800301c:	4282      	cmp	r2, r0
 800301e:	dcf4      	bgt.n	800300a <__gesf2+0x56>
 8003020:	dbeb      	blt.n	8002ffa <__gesf2+0x46>
 8003022:	42ac      	cmp	r4, r5
 8003024:	d8f1      	bhi.n	800300a <__gesf2+0x56>
 8003026:	2000      	movs	r0, #0
 8003028:	42ac      	cmp	r4, r5
 800302a:	d2dd      	bcs.n	8002fe8 <__gesf2+0x34>
 800302c:	e7e5      	b.n	8002ffa <__gesf2+0x46>
 800302e:	2c00      	cmp	r4, #0
 8003030:	d0da      	beq.n	8002fe8 <__gesf2+0x34>
 8003032:	e7ea      	b.n	800300a <__gesf2+0x56>
 8003034:	2d00      	cmp	r5, #0
 8003036:	d103      	bne.n	8003040 <__gesf2+0x8c>
 8003038:	428b      	cmp	r3, r1
 800303a:	d1e6      	bne.n	800300a <__gesf2+0x56>
 800303c:	2000      	movs	r0, #0
 800303e:	e7d3      	b.n	8002fe8 <__gesf2+0x34>
 8003040:	2002      	movs	r0, #2
 8003042:	4240      	negs	r0, r0
 8003044:	e7d0      	b.n	8002fe8 <__gesf2+0x34>
 8003046:	2001      	movs	r0, #1
 8003048:	4240      	negs	r0, r0
 800304a:	e7cd      	b.n	8002fe8 <__gesf2+0x34>
 800304c:	428b      	cmp	r3, r1
 800304e:	d0e8      	beq.n	8003022 <__gesf2+0x6e>
 8003050:	e7db      	b.n	800300a <__gesf2+0x56>
 8003052:	46c0      	nop			; (mov r8, r8)

08003054 <__lesf2>:
 8003054:	b530      	push	{r4, r5, lr}
 8003056:	0042      	lsls	r2, r0, #1
 8003058:	0244      	lsls	r4, r0, #9
 800305a:	024d      	lsls	r5, r1, #9
 800305c:	0fc3      	lsrs	r3, r0, #31
 800305e:	0048      	lsls	r0, r1, #1
 8003060:	0a64      	lsrs	r4, r4, #9
 8003062:	0e12      	lsrs	r2, r2, #24
 8003064:	0a6d      	lsrs	r5, r5, #9
 8003066:	0e00      	lsrs	r0, r0, #24
 8003068:	0fc9      	lsrs	r1, r1, #31
 800306a:	2aff      	cmp	r2, #255	; 0xff
 800306c:	d01a      	beq.n	80030a4 <__lesf2+0x50>
 800306e:	28ff      	cmp	r0, #255	; 0xff
 8003070:	d00e      	beq.n	8003090 <__lesf2+0x3c>
 8003072:	2a00      	cmp	r2, #0
 8003074:	d11e      	bne.n	80030b4 <__lesf2+0x60>
 8003076:	2800      	cmp	r0, #0
 8003078:	d10e      	bne.n	8003098 <__lesf2+0x44>
 800307a:	2d00      	cmp	r5, #0
 800307c:	d02a      	beq.n	80030d4 <__lesf2+0x80>
 800307e:	2c00      	cmp	r4, #0
 8003080:	d00c      	beq.n	800309c <__lesf2+0x48>
 8003082:	428b      	cmp	r3, r1
 8003084:	d01d      	beq.n	80030c2 <__lesf2+0x6e>
 8003086:	1e58      	subs	r0, r3, #1
 8003088:	2302      	movs	r3, #2
 800308a:	4018      	ands	r0, r3
 800308c:	3801      	subs	r0, #1
 800308e:	e010      	b.n	80030b2 <__lesf2+0x5e>
 8003090:	2d00      	cmp	r5, #0
 8003092:	d10d      	bne.n	80030b0 <__lesf2+0x5c>
 8003094:	2a00      	cmp	r2, #0
 8003096:	d120      	bne.n	80030da <__lesf2+0x86>
 8003098:	2c00      	cmp	r4, #0
 800309a:	d11e      	bne.n	80030da <__lesf2+0x86>
 800309c:	2900      	cmp	r1, #0
 800309e:	d023      	beq.n	80030e8 <__lesf2+0x94>
 80030a0:	0008      	movs	r0, r1
 80030a2:	e006      	b.n	80030b2 <__lesf2+0x5e>
 80030a4:	2c00      	cmp	r4, #0
 80030a6:	d103      	bne.n	80030b0 <__lesf2+0x5c>
 80030a8:	28ff      	cmp	r0, #255	; 0xff
 80030aa:	d1ec      	bne.n	8003086 <__lesf2+0x32>
 80030ac:	2d00      	cmp	r5, #0
 80030ae:	d017      	beq.n	80030e0 <__lesf2+0x8c>
 80030b0:	2002      	movs	r0, #2
 80030b2:	bd30      	pop	{r4, r5, pc}
 80030b4:	2800      	cmp	r0, #0
 80030b6:	d0e6      	beq.n	8003086 <__lesf2+0x32>
 80030b8:	428b      	cmp	r3, r1
 80030ba:	d1e4      	bne.n	8003086 <__lesf2+0x32>
 80030bc:	4282      	cmp	r2, r0
 80030be:	dce2      	bgt.n	8003086 <__lesf2+0x32>
 80030c0:	db04      	blt.n	80030cc <__lesf2+0x78>
 80030c2:	42ac      	cmp	r4, r5
 80030c4:	d8df      	bhi.n	8003086 <__lesf2+0x32>
 80030c6:	2000      	movs	r0, #0
 80030c8:	42ac      	cmp	r4, r5
 80030ca:	d2f2      	bcs.n	80030b2 <__lesf2+0x5e>
 80030cc:	2b00      	cmp	r3, #0
 80030ce:	d00b      	beq.n	80030e8 <__lesf2+0x94>
 80030d0:	0018      	movs	r0, r3
 80030d2:	e7ee      	b.n	80030b2 <__lesf2+0x5e>
 80030d4:	2c00      	cmp	r4, #0
 80030d6:	d0ec      	beq.n	80030b2 <__lesf2+0x5e>
 80030d8:	e7d5      	b.n	8003086 <__lesf2+0x32>
 80030da:	428b      	cmp	r3, r1
 80030dc:	d1d3      	bne.n	8003086 <__lesf2+0x32>
 80030de:	e7f5      	b.n	80030cc <__lesf2+0x78>
 80030e0:	2000      	movs	r0, #0
 80030e2:	428b      	cmp	r3, r1
 80030e4:	d0e5      	beq.n	80030b2 <__lesf2+0x5e>
 80030e6:	e7ce      	b.n	8003086 <__lesf2+0x32>
 80030e8:	2001      	movs	r0, #1
 80030ea:	4240      	negs	r0, r0
 80030ec:	e7e1      	b.n	80030b2 <__lesf2+0x5e>
 80030ee:	46c0      	nop			; (mov r8, r8)

080030f0 <__aeabi_fmul>:
 80030f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80030f2:	464f      	mov	r7, r9
 80030f4:	4646      	mov	r6, r8
 80030f6:	46d6      	mov	lr, sl
 80030f8:	0243      	lsls	r3, r0, #9
 80030fa:	0a5b      	lsrs	r3, r3, #9
 80030fc:	4699      	mov	r9, r3
 80030fe:	0043      	lsls	r3, r0, #1
 8003100:	b5c0      	push	{r6, r7, lr}
 8003102:	0e1b      	lsrs	r3, r3, #24
 8003104:	1c0e      	adds	r6, r1, #0
 8003106:	0fc5      	lsrs	r5, r0, #31
 8003108:	2b00      	cmp	r3, #0
 800310a:	d100      	bne.n	800310e <__aeabi_fmul+0x1e>
 800310c:	e085      	b.n	800321a <__aeabi_fmul+0x12a>
 800310e:	2bff      	cmp	r3, #255	; 0xff
 8003110:	d100      	bne.n	8003114 <__aeabi_fmul+0x24>
 8003112:	e08b      	b.n	800322c <__aeabi_fmul+0x13c>
 8003114:	464a      	mov	r2, r9
 8003116:	2180      	movs	r1, #128	; 0x80
 8003118:	00d2      	lsls	r2, r2, #3
 800311a:	04c9      	lsls	r1, r1, #19
 800311c:	4311      	orrs	r1, r2
 800311e:	227f      	movs	r2, #127	; 0x7f
 8003120:	4252      	negs	r2, r2
 8003122:	4690      	mov	r8, r2
 8003124:	4498      	add	r8, r3
 8003126:	2300      	movs	r3, #0
 8003128:	4689      	mov	r9, r1
 800312a:	2700      	movs	r7, #0
 800312c:	469a      	mov	sl, r3
 800312e:	0274      	lsls	r4, r6, #9
 8003130:	0073      	lsls	r3, r6, #1
 8003132:	0a64      	lsrs	r4, r4, #9
 8003134:	0e1b      	lsrs	r3, r3, #24
 8003136:	0ff6      	lsrs	r6, r6, #31
 8003138:	2b00      	cmp	r3, #0
 800313a:	d064      	beq.n	8003206 <__aeabi_fmul+0x116>
 800313c:	2bff      	cmp	r3, #255	; 0xff
 800313e:	d01f      	beq.n	8003180 <__aeabi_fmul+0x90>
 8003140:	2280      	movs	r2, #128	; 0x80
 8003142:	3b7f      	subs	r3, #127	; 0x7f
 8003144:	00e4      	lsls	r4, r4, #3
 8003146:	04d2      	lsls	r2, r2, #19
 8003148:	4443      	add	r3, r8
 800314a:	2000      	movs	r0, #0
 800314c:	4314      	orrs	r4, r2
 800314e:	1c59      	adds	r1, r3, #1
 8003150:	2f0a      	cmp	r7, #10
 8003152:	dc2b      	bgt.n	80031ac <__aeabi_fmul+0xbc>
 8003154:	4075      	eors	r5, r6
 8003156:	2f02      	cmp	r7, #2
 8003158:	dc22      	bgt.n	80031a0 <__aeabi_fmul+0xb0>
 800315a:	3f01      	subs	r7, #1
 800315c:	2f01      	cmp	r7, #1
 800315e:	d900      	bls.n	8003162 <__aeabi_fmul+0x72>
 8003160:	e0bb      	b.n	80032da <__aeabi_fmul+0x1ea>
 8003162:	2802      	cmp	r0, #2
 8003164:	d06b      	beq.n	800323e <__aeabi_fmul+0x14e>
 8003166:	2801      	cmp	r0, #1
 8003168:	d12a      	bne.n	80031c0 <__aeabi_fmul+0xd0>
 800316a:	2000      	movs	r0, #0
 800316c:	2200      	movs	r2, #0
 800316e:	05c0      	lsls	r0, r0, #23
 8003170:	07ed      	lsls	r5, r5, #31
 8003172:	4310      	orrs	r0, r2
 8003174:	4328      	orrs	r0, r5
 8003176:	bce0      	pop	{r5, r6, r7}
 8003178:	46ba      	mov	sl, r7
 800317a:	46b1      	mov	r9, r6
 800317c:	46a8      	mov	r8, r5
 800317e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003180:	2c00      	cmp	r4, #0
 8003182:	d064      	beq.n	800324e <__aeabi_fmul+0x15e>
 8003184:	2203      	movs	r2, #3
 8003186:	4641      	mov	r1, r8
 8003188:	4643      	mov	r3, r8
 800318a:	4317      	orrs	r7, r2
 800318c:	002a      	movs	r2, r5
 800318e:	3101      	adds	r1, #1
 8003190:	33ff      	adds	r3, #255	; 0xff
 8003192:	4072      	eors	r2, r6
 8003194:	31ff      	adds	r1, #255	; 0xff
 8003196:	2f0a      	cmp	r7, #10
 8003198:	dd00      	ble.n	800319c <__aeabi_fmul+0xac>
 800319a:	e0d7      	b.n	800334c <__aeabi_fmul+0x25c>
 800319c:	0015      	movs	r5, r2
 800319e:	2003      	movs	r0, #3
 80031a0:	2201      	movs	r2, #1
 80031a2:	40ba      	lsls	r2, r7
 80031a4:	27a6      	movs	r7, #166	; 0xa6
 80031a6:	00ff      	lsls	r7, r7, #3
 80031a8:	423a      	tst	r2, r7
 80031aa:	d020      	beq.n	80031ee <__aeabi_fmul+0xfe>
 80031ac:	4653      	mov	r3, sl
 80031ae:	2b02      	cmp	r3, #2
 80031b0:	d045      	beq.n	800323e <__aeabi_fmul+0x14e>
 80031b2:	2b03      	cmp	r3, #3
 80031b4:	d100      	bne.n	80031b8 <__aeabi_fmul+0xc8>
 80031b6:	e0bb      	b.n	8003330 <__aeabi_fmul+0x240>
 80031b8:	4650      	mov	r0, sl
 80031ba:	464c      	mov	r4, r9
 80031bc:	2801      	cmp	r0, #1
 80031be:	d0d4      	beq.n	800316a <__aeabi_fmul+0x7a>
 80031c0:	000b      	movs	r3, r1
 80031c2:	337f      	adds	r3, #127	; 0x7f
 80031c4:	2b00      	cmp	r3, #0
 80031c6:	dd70      	ble.n	80032aa <__aeabi_fmul+0x1ba>
 80031c8:	0762      	lsls	r2, r4, #29
 80031ca:	d004      	beq.n	80031d6 <__aeabi_fmul+0xe6>
 80031cc:	220f      	movs	r2, #15
 80031ce:	4022      	ands	r2, r4
 80031d0:	2a04      	cmp	r2, #4
 80031d2:	d000      	beq.n	80031d6 <__aeabi_fmul+0xe6>
 80031d4:	3404      	adds	r4, #4
 80031d6:	0122      	lsls	r2, r4, #4
 80031d8:	d503      	bpl.n	80031e2 <__aeabi_fmul+0xf2>
 80031da:	4b63      	ldr	r3, [pc, #396]	; (8003368 <__aeabi_fmul+0x278>)
 80031dc:	401c      	ands	r4, r3
 80031de:	000b      	movs	r3, r1
 80031e0:	3380      	adds	r3, #128	; 0x80
 80031e2:	2bfe      	cmp	r3, #254	; 0xfe
 80031e4:	dc2b      	bgt.n	800323e <__aeabi_fmul+0x14e>
 80031e6:	01a2      	lsls	r2, r4, #6
 80031e8:	0a52      	lsrs	r2, r2, #9
 80031ea:	b2d8      	uxtb	r0, r3
 80031ec:	e7bf      	b.n	800316e <__aeabi_fmul+0x7e>
 80031ee:	2790      	movs	r7, #144	; 0x90
 80031f0:	00bf      	lsls	r7, r7, #2
 80031f2:	423a      	tst	r2, r7
 80031f4:	d126      	bne.n	8003244 <__aeabi_fmul+0x154>
 80031f6:	3fb9      	subs	r7, #185	; 0xb9
 80031f8:	3fff      	subs	r7, #255	; 0xff
 80031fa:	4217      	tst	r7, r2
 80031fc:	d06d      	beq.n	80032da <__aeabi_fmul+0x1ea>
 80031fe:	0035      	movs	r5, r6
 8003200:	46a1      	mov	r9, r4
 8003202:	4682      	mov	sl, r0
 8003204:	e7d2      	b.n	80031ac <__aeabi_fmul+0xbc>
 8003206:	2c00      	cmp	r4, #0
 8003208:	d141      	bne.n	800328e <__aeabi_fmul+0x19e>
 800320a:	2301      	movs	r3, #1
 800320c:	431f      	orrs	r7, r3
 800320e:	4643      	mov	r3, r8
 8003210:	2001      	movs	r0, #1
 8003212:	1c59      	adds	r1, r3, #1
 8003214:	2f0a      	cmp	r7, #10
 8003216:	dd9d      	ble.n	8003154 <__aeabi_fmul+0x64>
 8003218:	e7c8      	b.n	80031ac <__aeabi_fmul+0xbc>
 800321a:	464b      	mov	r3, r9
 800321c:	2b00      	cmp	r3, #0
 800321e:	d127      	bne.n	8003270 <__aeabi_fmul+0x180>
 8003220:	2300      	movs	r3, #0
 8003222:	4698      	mov	r8, r3
 8003224:	3301      	adds	r3, #1
 8003226:	2704      	movs	r7, #4
 8003228:	469a      	mov	sl, r3
 800322a:	e780      	b.n	800312e <__aeabi_fmul+0x3e>
 800322c:	464b      	mov	r3, r9
 800322e:	2b00      	cmp	r3, #0
 8003230:	d118      	bne.n	8003264 <__aeabi_fmul+0x174>
 8003232:	23ff      	movs	r3, #255	; 0xff
 8003234:	4698      	mov	r8, r3
 8003236:	3bfd      	subs	r3, #253	; 0xfd
 8003238:	2708      	movs	r7, #8
 800323a:	469a      	mov	sl, r3
 800323c:	e777      	b.n	800312e <__aeabi_fmul+0x3e>
 800323e:	20ff      	movs	r0, #255	; 0xff
 8003240:	2200      	movs	r2, #0
 8003242:	e794      	b.n	800316e <__aeabi_fmul+0x7e>
 8003244:	2280      	movs	r2, #128	; 0x80
 8003246:	2500      	movs	r5, #0
 8003248:	20ff      	movs	r0, #255	; 0xff
 800324a:	03d2      	lsls	r2, r2, #15
 800324c:	e78f      	b.n	800316e <__aeabi_fmul+0x7e>
 800324e:	2302      	movs	r3, #2
 8003250:	431f      	orrs	r7, r3
 8003252:	4643      	mov	r3, r8
 8003254:	1c59      	adds	r1, r3, #1
 8003256:	31ff      	adds	r1, #255	; 0xff
 8003258:	2f0a      	cmp	r7, #10
 800325a:	dca7      	bgt.n	80031ac <__aeabi_fmul+0xbc>
 800325c:	2002      	movs	r0, #2
 800325e:	33ff      	adds	r3, #255	; 0xff
 8003260:	4075      	eors	r5, r6
 8003262:	e778      	b.n	8003156 <__aeabi_fmul+0x66>
 8003264:	23ff      	movs	r3, #255	; 0xff
 8003266:	4698      	mov	r8, r3
 8003268:	3bfc      	subs	r3, #252	; 0xfc
 800326a:	270c      	movs	r7, #12
 800326c:	469a      	mov	sl, r3
 800326e:	e75e      	b.n	800312e <__aeabi_fmul+0x3e>
 8003270:	4648      	mov	r0, r9
 8003272:	f7fc ffeb 	bl	800024c <__clzsi2>
 8003276:	464a      	mov	r2, r9
 8003278:	1f43      	subs	r3, r0, #5
 800327a:	409a      	lsls	r2, r3
 800327c:	2376      	movs	r3, #118	; 0x76
 800327e:	425b      	negs	r3, r3
 8003280:	1a1b      	subs	r3, r3, r0
 8003282:	4698      	mov	r8, r3
 8003284:	2300      	movs	r3, #0
 8003286:	4691      	mov	r9, r2
 8003288:	2700      	movs	r7, #0
 800328a:	469a      	mov	sl, r3
 800328c:	e74f      	b.n	800312e <__aeabi_fmul+0x3e>
 800328e:	0020      	movs	r0, r4
 8003290:	f7fc ffdc 	bl	800024c <__clzsi2>
 8003294:	1f43      	subs	r3, r0, #5
 8003296:	409c      	lsls	r4, r3
 8003298:	4643      	mov	r3, r8
 800329a:	1a1b      	subs	r3, r3, r0
 800329c:	3b76      	subs	r3, #118	; 0x76
 800329e:	2000      	movs	r0, #0
 80032a0:	1c59      	adds	r1, r3, #1
 80032a2:	2f0a      	cmp	r7, #10
 80032a4:	dc00      	bgt.n	80032a8 <__aeabi_fmul+0x1b8>
 80032a6:	e755      	b.n	8003154 <__aeabi_fmul+0x64>
 80032a8:	e780      	b.n	80031ac <__aeabi_fmul+0xbc>
 80032aa:	2201      	movs	r2, #1
 80032ac:	1ad3      	subs	r3, r2, r3
 80032ae:	2b1b      	cmp	r3, #27
 80032b0:	dd00      	ble.n	80032b4 <__aeabi_fmul+0x1c4>
 80032b2:	e75a      	b.n	800316a <__aeabi_fmul+0x7a>
 80032b4:	319e      	adds	r1, #158	; 0x9e
 80032b6:	0022      	movs	r2, r4
 80032b8:	408c      	lsls	r4, r1
 80032ba:	40da      	lsrs	r2, r3
 80032bc:	1e63      	subs	r3, r4, #1
 80032be:	419c      	sbcs	r4, r3
 80032c0:	4322      	orrs	r2, r4
 80032c2:	0753      	lsls	r3, r2, #29
 80032c4:	d004      	beq.n	80032d0 <__aeabi_fmul+0x1e0>
 80032c6:	230f      	movs	r3, #15
 80032c8:	4013      	ands	r3, r2
 80032ca:	2b04      	cmp	r3, #4
 80032cc:	d000      	beq.n	80032d0 <__aeabi_fmul+0x1e0>
 80032ce:	3204      	adds	r2, #4
 80032d0:	0153      	lsls	r3, r2, #5
 80032d2:	d537      	bpl.n	8003344 <__aeabi_fmul+0x254>
 80032d4:	2001      	movs	r0, #1
 80032d6:	2200      	movs	r2, #0
 80032d8:	e749      	b.n	800316e <__aeabi_fmul+0x7e>
 80032da:	0c20      	lsrs	r0, r4, #16
 80032dc:	464a      	mov	r2, r9
 80032de:	0424      	lsls	r4, r4, #16
 80032e0:	0c24      	lsrs	r4, r4, #16
 80032e2:	0027      	movs	r7, r4
 80032e4:	0c16      	lsrs	r6, r2, #16
 80032e6:	0412      	lsls	r2, r2, #16
 80032e8:	0c12      	lsrs	r2, r2, #16
 80032ea:	4374      	muls	r4, r6
 80032ec:	4357      	muls	r7, r2
 80032ee:	4346      	muls	r6, r0
 80032f0:	4350      	muls	r0, r2
 80032f2:	0c3a      	lsrs	r2, r7, #16
 80032f4:	1900      	adds	r0, r0, r4
 80032f6:	1812      	adds	r2, r2, r0
 80032f8:	4294      	cmp	r4, r2
 80032fa:	d903      	bls.n	8003304 <__aeabi_fmul+0x214>
 80032fc:	2080      	movs	r0, #128	; 0x80
 80032fe:	0240      	lsls	r0, r0, #9
 8003300:	4684      	mov	ip, r0
 8003302:	4466      	add	r6, ip
 8003304:	043f      	lsls	r7, r7, #16
 8003306:	0410      	lsls	r0, r2, #16
 8003308:	0c3f      	lsrs	r7, r7, #16
 800330a:	19c0      	adds	r0, r0, r7
 800330c:	0184      	lsls	r4, r0, #6
 800330e:	1e67      	subs	r7, r4, #1
 8003310:	41bc      	sbcs	r4, r7
 8003312:	0c12      	lsrs	r2, r2, #16
 8003314:	0e80      	lsrs	r0, r0, #26
 8003316:	1992      	adds	r2, r2, r6
 8003318:	4304      	orrs	r4, r0
 800331a:	0192      	lsls	r2, r2, #6
 800331c:	4314      	orrs	r4, r2
 800331e:	0112      	lsls	r2, r2, #4
 8003320:	d50e      	bpl.n	8003340 <__aeabi_fmul+0x250>
 8003322:	2301      	movs	r3, #1
 8003324:	0862      	lsrs	r2, r4, #1
 8003326:	401c      	ands	r4, r3
 8003328:	4314      	orrs	r4, r2
 800332a:	e749      	b.n	80031c0 <__aeabi_fmul+0xd0>
 800332c:	0035      	movs	r5, r6
 800332e:	46a1      	mov	r9, r4
 8003330:	2280      	movs	r2, #128	; 0x80
 8003332:	464b      	mov	r3, r9
 8003334:	03d2      	lsls	r2, r2, #15
 8003336:	431a      	orrs	r2, r3
 8003338:	0252      	lsls	r2, r2, #9
 800333a:	20ff      	movs	r0, #255	; 0xff
 800333c:	0a52      	lsrs	r2, r2, #9
 800333e:	e716      	b.n	800316e <__aeabi_fmul+0x7e>
 8003340:	0019      	movs	r1, r3
 8003342:	e73d      	b.n	80031c0 <__aeabi_fmul+0xd0>
 8003344:	0192      	lsls	r2, r2, #6
 8003346:	2000      	movs	r0, #0
 8003348:	0a52      	lsrs	r2, r2, #9
 800334a:	e710      	b.n	800316e <__aeabi_fmul+0x7e>
 800334c:	2f0f      	cmp	r7, #15
 800334e:	d1ed      	bne.n	800332c <__aeabi_fmul+0x23c>
 8003350:	2280      	movs	r2, #128	; 0x80
 8003352:	464b      	mov	r3, r9
 8003354:	03d2      	lsls	r2, r2, #15
 8003356:	4213      	tst	r3, r2
 8003358:	d0ea      	beq.n	8003330 <__aeabi_fmul+0x240>
 800335a:	4214      	tst	r4, r2
 800335c:	d1e8      	bne.n	8003330 <__aeabi_fmul+0x240>
 800335e:	0035      	movs	r5, r6
 8003360:	20ff      	movs	r0, #255	; 0xff
 8003362:	4322      	orrs	r2, r4
 8003364:	e703      	b.n	800316e <__aeabi_fmul+0x7e>
 8003366:	46c0      	nop			; (mov r8, r8)
 8003368:	f7ffffff 	.word	0xf7ffffff

0800336c <__aeabi_fsub>:
 800336c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800336e:	0243      	lsls	r3, r0, #9
 8003370:	0045      	lsls	r5, r0, #1
 8003372:	0fc4      	lsrs	r4, r0, #31
 8003374:	0248      	lsls	r0, r1, #9
 8003376:	0a42      	lsrs	r2, r0, #9
 8003378:	4694      	mov	ip, r2
 800337a:	004a      	lsls	r2, r1, #1
 800337c:	0a5e      	lsrs	r6, r3, #9
 800337e:	0e2d      	lsrs	r5, r5, #24
 8003380:	099b      	lsrs	r3, r3, #6
 8003382:	0e12      	lsrs	r2, r2, #24
 8003384:	0fc9      	lsrs	r1, r1, #31
 8003386:	0980      	lsrs	r0, r0, #6
 8003388:	2aff      	cmp	r2, #255	; 0xff
 800338a:	d023      	beq.n	80033d4 <__aeabi_fsub+0x68>
 800338c:	2701      	movs	r7, #1
 800338e:	4079      	eors	r1, r7
 8003390:	1aaf      	subs	r7, r5, r2
 8003392:	428c      	cmp	r4, r1
 8003394:	d00f      	beq.n	80033b6 <__aeabi_fsub+0x4a>
 8003396:	2f00      	cmp	r7, #0
 8003398:	dc00      	bgt.n	800339c <__aeabi_fsub+0x30>
 800339a:	e15d      	b.n	8003658 <__aeabi_fsub+0x2ec>
 800339c:	2a00      	cmp	r2, #0
 800339e:	d12f      	bne.n	8003400 <__aeabi_fsub+0x94>
 80033a0:	2800      	cmp	r0, #0
 80033a2:	d100      	bne.n	80033a6 <__aeabi_fsub+0x3a>
 80033a4:	e090      	b.n	80034c8 <__aeabi_fsub+0x15c>
 80033a6:	1e7a      	subs	r2, r7, #1
 80033a8:	2f01      	cmp	r7, #1
 80033aa:	d100      	bne.n	80033ae <__aeabi_fsub+0x42>
 80033ac:	e11a      	b.n	80035e4 <__aeabi_fsub+0x278>
 80033ae:	2fff      	cmp	r7, #255	; 0xff
 80033b0:	d01c      	beq.n	80033ec <__aeabi_fsub+0x80>
 80033b2:	0017      	movs	r7, r2
 80033b4:	e029      	b.n	800340a <__aeabi_fsub+0x9e>
 80033b6:	2f00      	cmp	r7, #0
 80033b8:	dc00      	bgt.n	80033bc <__aeabi_fsub+0x50>
 80033ba:	e159      	b.n	8003670 <__aeabi_fsub+0x304>
 80033bc:	2a00      	cmp	r2, #0
 80033be:	d052      	beq.n	8003466 <__aeabi_fsub+0xfa>
 80033c0:	2dff      	cmp	r5, #255	; 0xff
 80033c2:	d013      	beq.n	80033ec <__aeabi_fsub+0x80>
 80033c4:	2280      	movs	r2, #128	; 0x80
 80033c6:	04d2      	lsls	r2, r2, #19
 80033c8:	4310      	orrs	r0, r2
 80033ca:	2f1b      	cmp	r7, #27
 80033cc:	dc00      	bgt.n	80033d0 <__aeabi_fsub+0x64>
 80033ce:	e06a      	b.n	80034a6 <__aeabi_fsub+0x13a>
 80033d0:	3301      	adds	r3, #1
 80033d2:	e02b      	b.n	800342c <__aeabi_fsub+0xc0>
 80033d4:	2800      	cmp	r0, #0
 80033d6:	d03b      	beq.n	8003450 <__aeabi_fsub+0xe4>
 80033d8:	428c      	cmp	r4, r1
 80033da:	d04d      	beq.n	8003478 <__aeabi_fsub+0x10c>
 80033dc:	2dff      	cmp	r5, #255	; 0xff
 80033de:	d100      	bne.n	80033e2 <__aeabi_fsub+0x76>
 80033e0:	e08f      	b.n	8003502 <__aeabi_fsub+0x196>
 80033e2:	2d00      	cmp	r5, #0
 80033e4:	d100      	bne.n	80033e8 <__aeabi_fsub+0x7c>
 80033e6:	e0ab      	b.n	8003540 <__aeabi_fsub+0x1d4>
 80033e8:	000c      	movs	r4, r1
 80033ea:	0003      	movs	r3, r0
 80033ec:	08db      	lsrs	r3, r3, #3
 80033ee:	2b00      	cmp	r3, #0
 80033f0:	d067      	beq.n	80034c2 <__aeabi_fsub+0x156>
 80033f2:	2280      	movs	r2, #128	; 0x80
 80033f4:	03d2      	lsls	r2, r2, #15
 80033f6:	4313      	orrs	r3, r2
 80033f8:	025b      	lsls	r3, r3, #9
 80033fa:	20ff      	movs	r0, #255	; 0xff
 80033fc:	0a5b      	lsrs	r3, r3, #9
 80033fe:	e022      	b.n	8003446 <__aeabi_fsub+0xda>
 8003400:	2dff      	cmp	r5, #255	; 0xff
 8003402:	d0f3      	beq.n	80033ec <__aeabi_fsub+0x80>
 8003404:	2280      	movs	r2, #128	; 0x80
 8003406:	04d2      	lsls	r2, r2, #19
 8003408:	4310      	orrs	r0, r2
 800340a:	2201      	movs	r2, #1
 800340c:	2f1b      	cmp	r7, #27
 800340e:	dc07      	bgt.n	8003420 <__aeabi_fsub+0xb4>
 8003410:	2120      	movs	r1, #32
 8003412:	1bc9      	subs	r1, r1, r7
 8003414:	0002      	movs	r2, r0
 8003416:	4088      	lsls	r0, r1
 8003418:	40fa      	lsrs	r2, r7
 800341a:	1e41      	subs	r1, r0, #1
 800341c:	4188      	sbcs	r0, r1
 800341e:	4302      	orrs	r2, r0
 8003420:	1a9b      	subs	r3, r3, r2
 8003422:	015a      	lsls	r2, r3, #5
 8003424:	d456      	bmi.n	80034d4 <__aeabi_fsub+0x168>
 8003426:	2207      	movs	r2, #7
 8003428:	401a      	ands	r2, r3
 800342a:	d04e      	beq.n	80034ca <__aeabi_fsub+0x15e>
 800342c:	220f      	movs	r2, #15
 800342e:	401a      	ands	r2, r3
 8003430:	2a04      	cmp	r2, #4
 8003432:	d000      	beq.n	8003436 <__aeabi_fsub+0xca>
 8003434:	3304      	adds	r3, #4
 8003436:	015a      	lsls	r2, r3, #5
 8003438:	d547      	bpl.n	80034ca <__aeabi_fsub+0x15e>
 800343a:	1c68      	adds	r0, r5, #1
 800343c:	2dfe      	cmp	r5, #254	; 0xfe
 800343e:	d040      	beq.n	80034c2 <__aeabi_fsub+0x156>
 8003440:	019b      	lsls	r3, r3, #6
 8003442:	0a5b      	lsrs	r3, r3, #9
 8003444:	b2c0      	uxtb	r0, r0
 8003446:	05c0      	lsls	r0, r0, #23
 8003448:	4318      	orrs	r0, r3
 800344a:	07e4      	lsls	r4, r4, #31
 800344c:	4320      	orrs	r0, r4
 800344e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003450:	2701      	movs	r7, #1
 8003452:	4079      	eors	r1, r7
 8003454:	428c      	cmp	r4, r1
 8003456:	d1c1      	bne.n	80033dc <__aeabi_fsub+0x70>
 8003458:	2dff      	cmp	r5, #255	; 0xff
 800345a:	d010      	beq.n	800347e <__aeabi_fsub+0x112>
 800345c:	2d00      	cmp	r5, #0
 800345e:	d100      	bne.n	8003462 <__aeabi_fsub+0xf6>
 8003460:	e0e7      	b.n	8003632 <__aeabi_fsub+0x2c6>
 8003462:	2300      	movs	r3, #0
 8003464:	e7c2      	b.n	80033ec <__aeabi_fsub+0x80>
 8003466:	2800      	cmp	r0, #0
 8003468:	d02e      	beq.n	80034c8 <__aeabi_fsub+0x15c>
 800346a:	1e7a      	subs	r2, r7, #1
 800346c:	2f01      	cmp	r7, #1
 800346e:	d07f      	beq.n	8003570 <__aeabi_fsub+0x204>
 8003470:	2fff      	cmp	r7, #255	; 0xff
 8003472:	d0bb      	beq.n	80033ec <__aeabi_fsub+0x80>
 8003474:	0017      	movs	r7, r2
 8003476:	e7a8      	b.n	80033ca <__aeabi_fsub+0x5e>
 8003478:	2dff      	cmp	r5, #255	; 0xff
 800347a:	d000      	beq.n	800347e <__aeabi_fsub+0x112>
 800347c:	e083      	b.n	8003586 <__aeabi_fsub+0x21a>
 800347e:	27fe      	movs	r7, #254	; 0xfe
 8003480:	1c6a      	adds	r2, r5, #1
 8003482:	4217      	tst	r7, r2
 8003484:	d000      	beq.n	8003488 <__aeabi_fsub+0x11c>
 8003486:	e08d      	b.n	80035a4 <__aeabi_fsub+0x238>
 8003488:	2d00      	cmp	r5, #0
 800348a:	d000      	beq.n	800348e <__aeabi_fsub+0x122>
 800348c:	e0ad      	b.n	80035ea <__aeabi_fsub+0x27e>
 800348e:	2b00      	cmp	r3, #0
 8003490:	d100      	bne.n	8003494 <__aeabi_fsub+0x128>
 8003492:	e0d2      	b.n	800363a <__aeabi_fsub+0x2ce>
 8003494:	2800      	cmp	r0, #0
 8003496:	d000      	beq.n	800349a <__aeabi_fsub+0x12e>
 8003498:	e0d1      	b.n	800363e <__aeabi_fsub+0x2d2>
 800349a:	2500      	movs	r5, #0
 800349c:	08db      	lsrs	r3, r3, #3
 800349e:	025b      	lsls	r3, r3, #9
 80034a0:	0a5b      	lsrs	r3, r3, #9
 80034a2:	b2e8      	uxtb	r0, r5
 80034a4:	e7cf      	b.n	8003446 <__aeabi_fsub+0xda>
 80034a6:	2120      	movs	r1, #32
 80034a8:	1bc9      	subs	r1, r1, r7
 80034aa:	0002      	movs	r2, r0
 80034ac:	4088      	lsls	r0, r1
 80034ae:	40fa      	lsrs	r2, r7
 80034b0:	1e41      	subs	r1, r0, #1
 80034b2:	4188      	sbcs	r0, r1
 80034b4:	4310      	orrs	r0, r2
 80034b6:	181b      	adds	r3, r3, r0
 80034b8:	015a      	lsls	r2, r3, #5
 80034ba:	d5b4      	bpl.n	8003426 <__aeabi_fsub+0xba>
 80034bc:	3501      	adds	r5, #1
 80034be:	2dff      	cmp	r5, #255	; 0xff
 80034c0:	d15a      	bne.n	8003578 <__aeabi_fsub+0x20c>
 80034c2:	20ff      	movs	r0, #255	; 0xff
 80034c4:	2300      	movs	r3, #0
 80034c6:	e7be      	b.n	8003446 <__aeabi_fsub+0xda>
 80034c8:	003d      	movs	r5, r7
 80034ca:	08db      	lsrs	r3, r3, #3
 80034cc:	2dff      	cmp	r5, #255	; 0xff
 80034ce:	d100      	bne.n	80034d2 <__aeabi_fsub+0x166>
 80034d0:	e78d      	b.n	80033ee <__aeabi_fsub+0x82>
 80034d2:	e7e4      	b.n	800349e <__aeabi_fsub+0x132>
 80034d4:	019e      	lsls	r6, r3, #6
 80034d6:	09b6      	lsrs	r6, r6, #6
 80034d8:	0030      	movs	r0, r6
 80034da:	f7fc feb7 	bl	800024c <__clzsi2>
 80034de:	3805      	subs	r0, #5
 80034e0:	4086      	lsls	r6, r0
 80034e2:	4285      	cmp	r5, r0
 80034e4:	dc1f      	bgt.n	8003526 <__aeabi_fsub+0x1ba>
 80034e6:	2220      	movs	r2, #32
 80034e8:	1b40      	subs	r0, r0, r5
 80034ea:	3001      	adds	r0, #1
 80034ec:	1a12      	subs	r2, r2, r0
 80034ee:	0033      	movs	r3, r6
 80034f0:	4096      	lsls	r6, r2
 80034f2:	40c3      	lsrs	r3, r0
 80034f4:	1e72      	subs	r2, r6, #1
 80034f6:	4196      	sbcs	r6, r2
 80034f8:	2500      	movs	r5, #0
 80034fa:	4333      	orrs	r3, r6
 80034fc:	075a      	lsls	r2, r3, #29
 80034fe:	d195      	bne.n	800342c <__aeabi_fsub+0xc0>
 8003500:	e799      	b.n	8003436 <__aeabi_fsub+0xca>
 8003502:	27fe      	movs	r7, #254	; 0xfe
 8003504:	1c6a      	adds	r2, r5, #1
 8003506:	4217      	tst	r7, r2
 8003508:	d111      	bne.n	800352e <__aeabi_fsub+0x1c2>
 800350a:	2d00      	cmp	r5, #0
 800350c:	d15a      	bne.n	80035c4 <__aeabi_fsub+0x258>
 800350e:	2b00      	cmp	r3, #0
 8003510:	d100      	bne.n	8003514 <__aeabi_fsub+0x1a8>
 8003512:	e089      	b.n	8003628 <__aeabi_fsub+0x2bc>
 8003514:	2800      	cmp	r0, #0
 8003516:	d0c0      	beq.n	800349a <__aeabi_fsub+0x12e>
 8003518:	1a1a      	subs	r2, r3, r0
 800351a:	0156      	lsls	r6, r2, #5
 800351c:	d400      	bmi.n	8003520 <__aeabi_fsub+0x1b4>
 800351e:	e096      	b.n	800364e <__aeabi_fsub+0x2e2>
 8003520:	000c      	movs	r4, r1
 8003522:	1ac3      	subs	r3, r0, r3
 8003524:	e7ea      	b.n	80034fc <__aeabi_fsub+0x190>
 8003526:	4b58      	ldr	r3, [pc, #352]	; (8003688 <__aeabi_fsub+0x31c>)
 8003528:	1a2d      	subs	r5, r5, r0
 800352a:	4033      	ands	r3, r6
 800352c:	e7e6      	b.n	80034fc <__aeabi_fsub+0x190>
 800352e:	1a1e      	subs	r6, r3, r0
 8003530:	0172      	lsls	r2, r6, #5
 8003532:	d444      	bmi.n	80035be <__aeabi_fsub+0x252>
 8003534:	2e00      	cmp	r6, #0
 8003536:	d1cf      	bne.n	80034d8 <__aeabi_fsub+0x16c>
 8003538:	2400      	movs	r4, #0
 800353a:	2000      	movs	r0, #0
 800353c:	2300      	movs	r3, #0
 800353e:	e782      	b.n	8003446 <__aeabi_fsub+0xda>
 8003540:	25ff      	movs	r5, #255	; 0xff
 8003542:	2b00      	cmp	r3, #0
 8003544:	d038      	beq.n	80035b8 <__aeabi_fsub+0x24c>
 8003546:	1e6e      	subs	r6, r5, #1
 8003548:	2d01      	cmp	r5, #1
 800354a:	d06a      	beq.n	8003622 <__aeabi_fsub+0x2b6>
 800354c:	2dff      	cmp	r5, #255	; 0xff
 800354e:	d100      	bne.n	8003552 <__aeabi_fsub+0x1e6>
 8003550:	e74a      	b.n	80033e8 <__aeabi_fsub+0x7c>
 8003552:	2401      	movs	r4, #1
 8003554:	2e1b      	cmp	r6, #27
 8003556:	dc07      	bgt.n	8003568 <__aeabi_fsub+0x1fc>
 8003558:	2520      	movs	r5, #32
 800355a:	1bad      	subs	r5, r5, r6
 800355c:	001c      	movs	r4, r3
 800355e:	40ab      	lsls	r3, r5
 8003560:	40f4      	lsrs	r4, r6
 8003562:	1e5d      	subs	r5, r3, #1
 8003564:	41ab      	sbcs	r3, r5
 8003566:	431c      	orrs	r4, r3
 8003568:	1b03      	subs	r3, r0, r4
 800356a:	0015      	movs	r5, r2
 800356c:	000c      	movs	r4, r1
 800356e:	e758      	b.n	8003422 <__aeabi_fsub+0xb6>
 8003570:	181b      	adds	r3, r3, r0
 8003572:	2502      	movs	r5, #2
 8003574:	015a      	lsls	r2, r3, #5
 8003576:	d533      	bpl.n	80035e0 <__aeabi_fsub+0x274>
 8003578:	2201      	movs	r2, #1
 800357a:	4944      	ldr	r1, [pc, #272]	; (800368c <__aeabi_fsub+0x320>)
 800357c:	401a      	ands	r2, r3
 800357e:	085b      	lsrs	r3, r3, #1
 8003580:	400b      	ands	r3, r1
 8003582:	4313      	orrs	r3, r2
 8003584:	e7ba      	b.n	80034fc <__aeabi_fsub+0x190>
 8003586:	2d00      	cmp	r5, #0
 8003588:	d131      	bne.n	80035ee <__aeabi_fsub+0x282>
 800358a:	35ff      	adds	r5, #255	; 0xff
 800358c:	2b00      	cmp	r3, #0
 800358e:	d052      	beq.n	8003636 <__aeabi_fsub+0x2ca>
 8003590:	1e69      	subs	r1, r5, #1
 8003592:	2d01      	cmp	r5, #1
 8003594:	d020      	beq.n	80035d8 <__aeabi_fsub+0x26c>
 8003596:	2dff      	cmp	r5, #255	; 0xff
 8003598:	d029      	beq.n	80035ee <__aeabi_fsub+0x282>
 800359a:	291b      	cmp	r1, #27
 800359c:	dd36      	ble.n	800360c <__aeabi_fsub+0x2a0>
 800359e:	0015      	movs	r5, r2
 80035a0:	1c43      	adds	r3, r0, #1
 80035a2:	e743      	b.n	800342c <__aeabi_fsub+0xc0>
 80035a4:	2aff      	cmp	r2, #255	; 0xff
 80035a6:	d08c      	beq.n	80034c2 <__aeabi_fsub+0x156>
 80035a8:	181b      	adds	r3, r3, r0
 80035aa:	085b      	lsrs	r3, r3, #1
 80035ac:	0015      	movs	r5, r2
 80035ae:	075a      	lsls	r2, r3, #29
 80035b0:	d000      	beq.n	80035b4 <__aeabi_fsub+0x248>
 80035b2:	e73b      	b.n	800342c <__aeabi_fsub+0xc0>
 80035b4:	08db      	lsrs	r3, r3, #3
 80035b6:	e772      	b.n	800349e <__aeabi_fsub+0x132>
 80035b8:	000c      	movs	r4, r1
 80035ba:	0003      	movs	r3, r0
 80035bc:	e785      	b.n	80034ca <__aeabi_fsub+0x15e>
 80035be:	000c      	movs	r4, r1
 80035c0:	1ac6      	subs	r6, r0, r3
 80035c2:	e789      	b.n	80034d8 <__aeabi_fsub+0x16c>
 80035c4:	2b00      	cmp	r3, #0
 80035c6:	d114      	bne.n	80035f2 <__aeabi_fsub+0x286>
 80035c8:	2800      	cmp	r0, #0
 80035ca:	d000      	beq.n	80035ce <__aeabi_fsub+0x262>
 80035cc:	e70c      	b.n	80033e8 <__aeabi_fsub+0x7c>
 80035ce:	2380      	movs	r3, #128	; 0x80
 80035d0:	2400      	movs	r4, #0
 80035d2:	20ff      	movs	r0, #255	; 0xff
 80035d4:	03db      	lsls	r3, r3, #15
 80035d6:	e736      	b.n	8003446 <__aeabi_fsub+0xda>
 80035d8:	181b      	adds	r3, r3, r0
 80035da:	3501      	adds	r5, #1
 80035dc:	015a      	lsls	r2, r3, #5
 80035de:	d4cb      	bmi.n	8003578 <__aeabi_fsub+0x20c>
 80035e0:	3d01      	subs	r5, #1
 80035e2:	e720      	b.n	8003426 <__aeabi_fsub+0xba>
 80035e4:	2501      	movs	r5, #1
 80035e6:	1a1b      	subs	r3, r3, r0
 80035e8:	e71b      	b.n	8003422 <__aeabi_fsub+0xb6>
 80035ea:	2b00      	cmp	r3, #0
 80035ec:	d101      	bne.n	80035f2 <__aeabi_fsub+0x286>
 80035ee:	0003      	movs	r3, r0
 80035f0:	e6fc      	b.n	80033ec <__aeabi_fsub+0x80>
 80035f2:	2800      	cmp	r0, #0
 80035f4:	d100      	bne.n	80035f8 <__aeabi_fsub+0x28c>
 80035f6:	e6f9      	b.n	80033ec <__aeabi_fsub+0x80>
 80035f8:	2280      	movs	r2, #128	; 0x80
 80035fa:	03d2      	lsls	r2, r2, #15
 80035fc:	4296      	cmp	r6, r2
 80035fe:	d303      	bcc.n	8003608 <__aeabi_fsub+0x29c>
 8003600:	4594      	cmp	ip, r2
 8003602:	d201      	bcs.n	8003608 <__aeabi_fsub+0x29c>
 8003604:	000c      	movs	r4, r1
 8003606:	0003      	movs	r3, r0
 8003608:	08db      	lsrs	r3, r3, #3
 800360a:	e6f2      	b.n	80033f2 <__aeabi_fsub+0x86>
 800360c:	001d      	movs	r5, r3
 800360e:	2620      	movs	r6, #32
 8003610:	40cd      	lsrs	r5, r1
 8003612:	1a71      	subs	r1, r6, r1
 8003614:	408b      	lsls	r3, r1
 8003616:	1e59      	subs	r1, r3, #1
 8003618:	418b      	sbcs	r3, r1
 800361a:	432b      	orrs	r3, r5
 800361c:	181b      	adds	r3, r3, r0
 800361e:	0015      	movs	r5, r2
 8003620:	e74a      	b.n	80034b8 <__aeabi_fsub+0x14c>
 8003622:	000c      	movs	r4, r1
 8003624:	1ac3      	subs	r3, r0, r3
 8003626:	e6fc      	b.n	8003422 <__aeabi_fsub+0xb6>
 8003628:	2800      	cmp	r0, #0
 800362a:	d085      	beq.n	8003538 <__aeabi_fsub+0x1cc>
 800362c:	000c      	movs	r4, r1
 800362e:	0003      	movs	r3, r0
 8003630:	e733      	b.n	800349a <__aeabi_fsub+0x12e>
 8003632:	25ff      	movs	r5, #255	; 0xff
 8003634:	e7aa      	b.n	800358c <__aeabi_fsub+0x220>
 8003636:	0003      	movs	r3, r0
 8003638:	e747      	b.n	80034ca <__aeabi_fsub+0x15e>
 800363a:	0003      	movs	r3, r0
 800363c:	e72d      	b.n	800349a <__aeabi_fsub+0x12e>
 800363e:	181b      	adds	r3, r3, r0
 8003640:	015a      	lsls	r2, r3, #5
 8003642:	d5b7      	bpl.n	80035b4 <__aeabi_fsub+0x248>
 8003644:	4a10      	ldr	r2, [pc, #64]	; (8003688 <__aeabi_fsub+0x31c>)
 8003646:	3501      	adds	r5, #1
 8003648:	4013      	ands	r3, r2
 800364a:	08db      	lsrs	r3, r3, #3
 800364c:	e727      	b.n	800349e <__aeabi_fsub+0x132>
 800364e:	1e13      	subs	r3, r2, #0
 8003650:	d100      	bne.n	8003654 <__aeabi_fsub+0x2e8>
 8003652:	e771      	b.n	8003538 <__aeabi_fsub+0x1cc>
 8003654:	08db      	lsrs	r3, r3, #3
 8003656:	e722      	b.n	800349e <__aeabi_fsub+0x132>
 8003658:	2f00      	cmp	r7, #0
 800365a:	d100      	bne.n	800365e <__aeabi_fsub+0x2f2>
 800365c:	e751      	b.n	8003502 <__aeabi_fsub+0x196>
 800365e:	1b56      	subs	r6, r2, r5
 8003660:	2d00      	cmp	r5, #0
 8003662:	d101      	bne.n	8003668 <__aeabi_fsub+0x2fc>
 8003664:	0035      	movs	r5, r6
 8003666:	e76c      	b.n	8003542 <__aeabi_fsub+0x1d6>
 8003668:	2480      	movs	r4, #128	; 0x80
 800366a:	04e4      	lsls	r4, r4, #19
 800366c:	4323      	orrs	r3, r4
 800366e:	e770      	b.n	8003552 <__aeabi_fsub+0x1e6>
 8003670:	2f00      	cmp	r7, #0
 8003672:	d100      	bne.n	8003676 <__aeabi_fsub+0x30a>
 8003674:	e703      	b.n	800347e <__aeabi_fsub+0x112>
 8003676:	1b51      	subs	r1, r2, r5
 8003678:	2d00      	cmp	r5, #0
 800367a:	d101      	bne.n	8003680 <__aeabi_fsub+0x314>
 800367c:	000d      	movs	r5, r1
 800367e:	e785      	b.n	800358c <__aeabi_fsub+0x220>
 8003680:	2580      	movs	r5, #128	; 0x80
 8003682:	04ed      	lsls	r5, r5, #19
 8003684:	432b      	orrs	r3, r5
 8003686:	e788      	b.n	800359a <__aeabi_fsub+0x22e>
 8003688:	fbffffff 	.word	0xfbffffff
 800368c:	7dffffff 	.word	0x7dffffff

08003690 <__aeabi_f2iz>:
 8003690:	0241      	lsls	r1, r0, #9
 8003692:	0042      	lsls	r2, r0, #1
 8003694:	0fc3      	lsrs	r3, r0, #31
 8003696:	0a49      	lsrs	r1, r1, #9
 8003698:	2000      	movs	r0, #0
 800369a:	0e12      	lsrs	r2, r2, #24
 800369c:	2a7e      	cmp	r2, #126	; 0x7e
 800369e:	dd03      	ble.n	80036a8 <__aeabi_f2iz+0x18>
 80036a0:	2a9d      	cmp	r2, #157	; 0x9d
 80036a2:	dd02      	ble.n	80036aa <__aeabi_f2iz+0x1a>
 80036a4:	4a09      	ldr	r2, [pc, #36]	; (80036cc <__aeabi_f2iz+0x3c>)
 80036a6:	1898      	adds	r0, r3, r2
 80036a8:	4770      	bx	lr
 80036aa:	2080      	movs	r0, #128	; 0x80
 80036ac:	0400      	lsls	r0, r0, #16
 80036ae:	4301      	orrs	r1, r0
 80036b0:	2a95      	cmp	r2, #149	; 0x95
 80036b2:	dc07      	bgt.n	80036c4 <__aeabi_f2iz+0x34>
 80036b4:	2096      	movs	r0, #150	; 0x96
 80036b6:	1a82      	subs	r2, r0, r2
 80036b8:	40d1      	lsrs	r1, r2
 80036ba:	4248      	negs	r0, r1
 80036bc:	2b00      	cmp	r3, #0
 80036be:	d1f3      	bne.n	80036a8 <__aeabi_f2iz+0x18>
 80036c0:	0008      	movs	r0, r1
 80036c2:	e7f1      	b.n	80036a8 <__aeabi_f2iz+0x18>
 80036c4:	3a96      	subs	r2, #150	; 0x96
 80036c6:	4091      	lsls	r1, r2
 80036c8:	e7f7      	b.n	80036ba <__aeabi_f2iz+0x2a>
 80036ca:	46c0      	nop			; (mov r8, r8)
 80036cc:	7fffffff 	.word	0x7fffffff

080036d0 <__aeabi_i2f>:
 80036d0:	b570      	push	{r4, r5, r6, lr}
 80036d2:	2800      	cmp	r0, #0
 80036d4:	d013      	beq.n	80036fe <__aeabi_i2f+0x2e>
 80036d6:	17c3      	asrs	r3, r0, #31
 80036d8:	18c5      	adds	r5, r0, r3
 80036da:	405d      	eors	r5, r3
 80036dc:	0fc4      	lsrs	r4, r0, #31
 80036de:	0028      	movs	r0, r5
 80036e0:	f7fc fdb4 	bl	800024c <__clzsi2>
 80036e4:	239e      	movs	r3, #158	; 0x9e
 80036e6:	0001      	movs	r1, r0
 80036e8:	1a1b      	subs	r3, r3, r0
 80036ea:	2b96      	cmp	r3, #150	; 0x96
 80036ec:	dc0f      	bgt.n	800370e <__aeabi_i2f+0x3e>
 80036ee:	2808      	cmp	r0, #8
 80036f0:	d034      	beq.n	800375c <__aeabi_i2f+0x8c>
 80036f2:	3908      	subs	r1, #8
 80036f4:	408d      	lsls	r5, r1
 80036f6:	026d      	lsls	r5, r5, #9
 80036f8:	0a6d      	lsrs	r5, r5, #9
 80036fa:	b2d8      	uxtb	r0, r3
 80036fc:	e002      	b.n	8003704 <__aeabi_i2f+0x34>
 80036fe:	2400      	movs	r4, #0
 8003700:	2000      	movs	r0, #0
 8003702:	2500      	movs	r5, #0
 8003704:	05c0      	lsls	r0, r0, #23
 8003706:	4328      	orrs	r0, r5
 8003708:	07e4      	lsls	r4, r4, #31
 800370a:	4320      	orrs	r0, r4
 800370c:	bd70      	pop	{r4, r5, r6, pc}
 800370e:	2b99      	cmp	r3, #153	; 0x99
 8003710:	dc16      	bgt.n	8003740 <__aeabi_i2f+0x70>
 8003712:	1f42      	subs	r2, r0, #5
 8003714:	2805      	cmp	r0, #5
 8003716:	d000      	beq.n	800371a <__aeabi_i2f+0x4a>
 8003718:	4095      	lsls	r5, r2
 800371a:	002a      	movs	r2, r5
 800371c:	4811      	ldr	r0, [pc, #68]	; (8003764 <__aeabi_i2f+0x94>)
 800371e:	4002      	ands	r2, r0
 8003720:	076e      	lsls	r6, r5, #29
 8003722:	d009      	beq.n	8003738 <__aeabi_i2f+0x68>
 8003724:	260f      	movs	r6, #15
 8003726:	4035      	ands	r5, r6
 8003728:	2d04      	cmp	r5, #4
 800372a:	d005      	beq.n	8003738 <__aeabi_i2f+0x68>
 800372c:	3204      	adds	r2, #4
 800372e:	0155      	lsls	r5, r2, #5
 8003730:	d502      	bpl.n	8003738 <__aeabi_i2f+0x68>
 8003732:	239f      	movs	r3, #159	; 0x9f
 8003734:	4002      	ands	r2, r0
 8003736:	1a5b      	subs	r3, r3, r1
 8003738:	0192      	lsls	r2, r2, #6
 800373a:	0a55      	lsrs	r5, r2, #9
 800373c:	b2d8      	uxtb	r0, r3
 800373e:	e7e1      	b.n	8003704 <__aeabi_i2f+0x34>
 8003740:	2205      	movs	r2, #5
 8003742:	1a12      	subs	r2, r2, r0
 8003744:	0028      	movs	r0, r5
 8003746:	40d0      	lsrs	r0, r2
 8003748:	0002      	movs	r2, r0
 800374a:	0008      	movs	r0, r1
 800374c:	301b      	adds	r0, #27
 800374e:	4085      	lsls	r5, r0
 8003750:	0028      	movs	r0, r5
 8003752:	1e45      	subs	r5, r0, #1
 8003754:	41a8      	sbcs	r0, r5
 8003756:	4302      	orrs	r2, r0
 8003758:	0015      	movs	r5, r2
 800375a:	e7de      	b.n	800371a <__aeabi_i2f+0x4a>
 800375c:	026d      	lsls	r5, r5, #9
 800375e:	2096      	movs	r0, #150	; 0x96
 8003760:	0a6d      	lsrs	r5, r5, #9
 8003762:	e7cf      	b.n	8003704 <__aeabi_i2f+0x34>
 8003764:	fbffffff 	.word	0xfbffffff

08003768 <__libc_init_array>:
 8003768:	b570      	push	{r4, r5, r6, lr}
 800376a:	2600      	movs	r6, #0
 800376c:	4c0c      	ldr	r4, [pc, #48]	; (80037a0 <__libc_init_array+0x38>)
 800376e:	4d0d      	ldr	r5, [pc, #52]	; (80037a4 <__libc_init_array+0x3c>)
 8003770:	1b64      	subs	r4, r4, r5
 8003772:	10a4      	asrs	r4, r4, #2
 8003774:	42a6      	cmp	r6, r4
 8003776:	d109      	bne.n	800378c <__libc_init_array+0x24>
 8003778:	2600      	movs	r6, #0
 800377a:	f000 f819 	bl	80037b0 <_init>
 800377e:	4c0a      	ldr	r4, [pc, #40]	; (80037a8 <__libc_init_array+0x40>)
 8003780:	4d0a      	ldr	r5, [pc, #40]	; (80037ac <__libc_init_array+0x44>)
 8003782:	1b64      	subs	r4, r4, r5
 8003784:	10a4      	asrs	r4, r4, #2
 8003786:	42a6      	cmp	r6, r4
 8003788:	d105      	bne.n	8003796 <__libc_init_array+0x2e>
 800378a:	bd70      	pop	{r4, r5, r6, pc}
 800378c:	00b3      	lsls	r3, r6, #2
 800378e:	58eb      	ldr	r3, [r5, r3]
 8003790:	4798      	blx	r3
 8003792:	3601      	adds	r6, #1
 8003794:	e7ee      	b.n	8003774 <__libc_init_array+0xc>
 8003796:	00b3      	lsls	r3, r6, #2
 8003798:	58eb      	ldr	r3, [r5, r3]
 800379a:	4798      	blx	r3
 800379c:	3601      	adds	r6, #1
 800379e:	e7f2      	b.n	8003786 <__libc_init_array+0x1e>
 80037a0:	0800392c 	.word	0x0800392c
 80037a4:	0800392c 	.word	0x0800392c
 80037a8:	08003930 	.word	0x08003930
 80037ac:	0800392c 	.word	0x0800392c

080037b0 <_init>:
 80037b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80037b2:	46c0      	nop			; (mov r8, r8)
 80037b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80037b6:	bc08      	pop	{r3}
 80037b8:	469e      	mov	lr, r3
 80037ba:	4770      	bx	lr

080037bc <_fini>:
 80037bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80037be:	46c0      	nop			; (mov r8, r8)
 80037c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80037c2:	bc08      	pop	{r3}
 80037c4:	469e      	mov	lr, r3
 80037c6:	4770      	bx	lr
